

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Heart">
  <meta name="keywords" content="">
  
    <meta name="description" content="ILRuntimeILRuntime 是一个基于 Unity 的 C# 脚本解释器和运行时库，它可以实现在游戏运行时动态加载和执行 C# 代码。基本原理就是通过Mono.cecil库，去解释热更代码中的DLL包 特殊的热更新工程在使用ILRuntime进行热更新时，通常会创建两个工程：  主工程（Main Project）：主工程是一个Unity项目，包含了游戏的基础框架、资源和静态代码。主工程负">
<meta property="og:type" content="article">
<meta property="og:title" content="ILRuntime">
<meta property="og:url" content="http://fussen.top/2023/10/04/IL/ILRuntime/index.html">
<meta property="og:site_name" content="有个方向">
<meta property="og:description" content="ILRuntimeILRuntime 是一个基于 Unity 的 C# 脚本解释器和运行时库，它可以实现在游戏运行时动态加载和执行 C# 代码。基本原理就是通过Mono.cecil库，去解释热更代码中的DLL包 特殊的热更新工程在使用ILRuntime进行热更新时，通常会创建两个工程：  主工程（Main Project）：主工程是一个Unity项目，包含了游戏的基础框架、资源和静态代码。主工程负">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://fussen.top/photo/20231004155925.png">
<meta property="article:published_time" content="2023-10-04T07:56:42.000Z">
<meta property="article:modified_time" content="2023-10-04T08:26:04.515Z">
<meta property="article:author" content="Heart">
<meta property="article:tag" content="Unity">
<meta property="article:tag" content="ILRuntime">
<meta property="article:tag" content="热更新">
<meta property="article:tag" content="C#">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://fussen.top/photo/20231004155925.png">
  
  
  
  <title>ILRuntime - 有个方向</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"fussen.top","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"C#"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>有个方向</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/article.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="ILRuntime"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Heart
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-10-04 15:56" pubdate>
          2023年10月4日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          32k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          270 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">ILRuntime</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="ILRuntime"><a href="#ILRuntime" class="headerlink" title="ILRuntime"></a><code>ILRuntime</code></h1><p><code>ILRuntime</code> 是一个基于 Unity 的 C# 脚本解释器和运行时库，它可以实现在游戏运行时动态加载和执行 C# 代码。基本原理就是通过Mono.cecil库，去解释热更代码中的DLL包</p>
<h3 id="特殊的热更新工程"><a href="#特殊的热更新工程" class="headerlink" title="特殊的热更新工程"></a>特殊的热更新工程</h3><p>在使用<code>ILRuntime</code>进行热更新时，通常会创建两个工程：</p>
<ol>
<li>主工程（Main Project）：主工程是一个Unity项目，包含了游戏的基础框架、资源和静态代码。主工程负责加载和管理热更新的DLL文件，并提供接口供热更新DLL调用。</li>
<li>热更新工程（Hotfix Project）：热更新工程是一个独立的C#项目，使用<code>ILRuntime</code>进行开发。在热更新工程中，开发者可以编写游戏的逻辑代码，这些代码会<strong>被编译为DLL文件。热更新工程生成的DLL文件可以被主工程动态加载和执行。 在生成热更新工程后Dll包会自动放到<code>StreamingAssets</code> 文件夹内 最终会生成一个DLL文件和Pdb文件</strong></li>
<li>在热更新过程中，主工程会在游戏启动时加载热更新工程生成的DLL文件，并通过反射机制调用其中的方法和属性。这样，当需要更新游戏逻辑时，只需要替换热更新工程生成的DLL文件，而无需重新编译和发布整个游戏</li>
</ol>
<p>所以<code>ILRuntime</code>的开发方式变成了两个部分</p>
<ul>
<li>直接在Unity进行非热更新部分的开发</li>
<li>在热更新工程中进行热更新的开发 我们需要在两个工程内切换开发 两个工程可以相互访问调用</li>
</ul>
<p>这些叫做<em><strong>跨域访问</strong></em>  就比如 在Unity‘工程内使用热更工程声明的内容(类 委托 函数等)</p>
<p>热更工程使用Unity工程中声明的内容</p>
<h3 id="Unity跨域调用ILRuntime"><a href="#Unity跨域调用ILRuntime" class="headerlink" title="Unity跨域调用ILRuntime"></a>Unity跨域调用<code>ILRuntime</code></h3><h4 id="在Unity中跨域调用ILRuntime中的类"><a href="#在Unity中跨域调用ILRuntime中的类" class="headerlink" title="在Unity中跨域调用ILRuntime中的类"></a>在Unity中跨域调用<code>ILRuntime</code>中的类</h4><p>需要让ILRuntime重新生成最新的dll和pdb文件</p>
<img src="/2023/10/04/IL/ILRuntime/image-20231004160419860.png" srcset="/img/loading.gif" lazyload class="" title="image-20231004160419860">

<ul>
<li>方式一：appdomain中的Instantiate方法  参数一： 类的命名空间.类名 参数二： 参数列表</li>
<li><strong>方式二:<code>appdomain</code>中<code>LoadedTypes</code>字典获取<code>IType</code>类型后，强转为<code>ILType</code>后调用<code>Instantiate</code>方法该方式类似反射</strong></li>
<li>方式三通过方式二中得到的IType对象，再去得到它的构造函数进行实例化该方式类似反射</li>
<li><strong>更推荐方式2，因为之后在调用对象方法变量时，通过方式2更方便</strong></li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 在加载完成后执行热更新逻辑</span><br><br>ILRuntime.Runtime.Enviorment.AppDomain appDomain = ILRunTimeManager.Instance.AppDomain;<br><span class="hljs-comment">// 方法一：使用appdomain中的Instantiate方法</span><br><span class="hljs-comment">//      参数一：类的命名空间.类名</span><br><span class="hljs-comment">//      参数二：参数列表</span><br><span class="hljs-built_in">object</span> obj = appDomain.Instantiate(<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>);<br>print(obj);<br>obj = appDomain.Instantiate(<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] &#123; <span class="hljs-string">&quot;我是参数&quot;</span> &#125;);<br>print(obj);<br><br><span class="hljs-comment">// 方法二：通过appdomain中LoadedTypes字典获取IType类型，然后将其强制转换为ILType，再调用Instantiate方法</span><br><span class="hljs-comment">//      该方法类似于反射</span><br>IType type = appDomain.LoadedTypes[<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>];<br>obj = ((ILType)type).Instantiate();<br>print(obj);<br>obj = ((ILType)type).Instantiate(<span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] &#123; <span class="hljs-string">&quot;我是参数2&quot;</span> &#125;);<br>print(obj);<br><br><span class="hljs-comment">// 方法三：通过方法二获取的IType对象，再获取其构造函数进行实例化</span><br><span class="hljs-comment">//      该方法类似于反射</span><br>IType type2 = appDomain.LoadedTypes[<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>];<br>ConstructorInfo info = type2.ReflectionType.GetConstructor(<span class="hljs-keyword">new</span> Type[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 无参构造函数</span><br>obj = info.Invoke(<span class="hljs-literal">null</span>);<br>print(obj);<br>ConstructorInfo info2 = type2.ReflectionType.GetConstructor(<span class="hljs-keyword">new</span> Type[] &#123; <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>) &#125;); <span class="hljs-comment">// 有参构造函数</span><br>obj = info2.Invoke(<span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] &#123; <span class="hljs-string">&quot;1111&quot;</span> &#125;);<br>print(obj);<br></code></pre></td></tr></table></figure>

<h4 id="在Unity中跨域调用ILRuntime中的成员属性"><a href="#在Unity中跨域调用ILRuntime中的成员属性" class="headerlink" title="在Unity中跨域调用ILRuntime中的成员属性"></a>在Unity中跨域调用<code>ILRuntime</code>中的成员属性</h4><p><code>ILRuntime</code>中并没有提供让Unity直接获取或修改成员变量的方案，我们只能通过在<code>ILRuntime</code>中封装属性的形式来达到目的。</p>
<ul>
<li>获取方法信息 通过<code>IType</code>中的<code>GetMethod</code>方法，类似反射一样的获取对应类中的方法</li>
<li>通过<code>appdomain.Invoke</code>（方法名，调用对象，参数）调用</li>
<li>或者通过更节约性能的无<code>GC Alloc</code>（调用完后直接回收）方式调用</li>
<li><strong>其中虽然方式二写起来复杂，但是更加节约性能，推荐使用，可以尝试进行封装</strong></li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs csharp">IType type = appDomain.LoadedTypes[<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>];<br><span class="hljs-built_in">object</span> obj = ((ILType)type).Instantiate(<span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] &#123; <span class="hljs-string">&quot;234&quot;</span> &#125;);<br><br><span class="hljs-comment">// ILRuntime中并没有提供让Unity直接获取或修改成员变量的方案</span><br><span class="hljs-comment">// 我们只能通过在ILRuntime中封装属性的形式来达到目的</span><br><br><span class="hljs-comment">// 1.获取方法信息</span><br><span class="hljs-comment">//   通过IType中的GetMethod方法，类似反射一样的获取对应类中的方法</span><br><span class="hljs-comment">//   规则：get_属性名 为对应属性获取</span><br><span class="hljs-comment">//         set_属性名 为对应属性的赋值</span><br>IMethod getStr = type.GetMethod(<span class="hljs-string">&quot;get_Str&quot;</span>, <span class="hljs-number">0</span>);<br>IMethod setStr = type.GetMethod(<span class="hljs-string">&quot;set_Str&quot;</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 参数set是要传入值</span><br><br><span class="hljs-comment">// 2.调用方法</span><br><span class="hljs-comment">//   有两种方式</span><br><span class="hljs-comment">//   2-1:通过appdomain.Invoke(方法名, 调用对象, 参数)调用</span><br><span class="hljs-comment">// 去获取属性</span><br><span class="hljs-built_in">string</span> str = appDomain.Invoke(getStr, obj, <span class="hljs-literal">null</span>).ToString();<br>print(str);<br><span class="hljs-comment">// 去修改属性</span><br>appDomain.Invoke(setStr, obj, <span class="hljs-string">&quot;我是修改后的值&quot;</span>);<br>str = appDomain.Invoke(getStr, obj).ToString(); <span class="hljs-comment">// 设置完后再次获取，看看是否修改成功</span><br>print(str);<br><br><span class="hljs-comment">//   2-2:通过更节约性能的无GC Alloc（调用完后直接回收）方式调用</span><br><span class="hljs-comment">//     using (var method = appDomain.BeginInvoke(方法名))</span><br><span class="hljs-comment">//     &#123;</span><br><span class="hljs-comment">//           method.PushObject(执行该方法的对象);//传入执行该方法的对象</span><br><span class="hljs-comment">//           method.Push.....(1000);//传入指定类型参数</span><br><span class="hljs-comment">//           method.Invoke();//执行方法</span><br><span class="hljs-comment">//           method.Read....()//获取指定类型返回值</span><br><span class="hljs-comment">//     &#125;</span><br><br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> method = appDomain.BeginInvoke(getStr))<br>&#123;<br>    <span class="hljs-comment">// 这种方式更推荐</span><br>    method.PushObject(obj);<br>    method.Invoke();<br>    str = method.ReadValueType&lt;<span class="hljs-built_in">string</span>&gt;();<br>    print(str + <span class="hljs-string">&quot;2&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// Set 要先设置值，然后装入</span><br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> method = appDomain.BeginInvoke(setStr))<br>&#123;<br>    method.PushObject(obj);<br>    <span class="hljs-built_in">string</span> temp = <span class="hljs-string">&quot;我是再次修改后的值&quot;</span>;<br>    method.PushValueType(<span class="hljs-keyword">ref</span> temp);<br>    method.Invoke();<br>&#125;<br><br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> method = appDomain.BeginInvoke(getStr))<br>&#123;<br>    <span class="hljs-comment">// 这种方式更推荐</span><br>    method.PushObject(obj);<br>    method.Invoke();<br>    str = method.ReadValueType&lt;<span class="hljs-built_in">string</span>&gt;();<br>    print(str);<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="/2023/10/04/IL/ILRuntime/image-20231004160447871.png" srcset="/img/loading.gif" lazyload class="" title="image-20231004160447871">

<h4 id="在Unity中跨域调用ILRuntime中的静态方法"><a href="#在Unity中跨域调用ILRuntime中的静态方法" class="headerlink" title="在Unity中跨域调用ILRuntime中的静态方法"></a>在Unity中跨域调用<code>ILRuntime</code>中的静态方法</h4><p>静态方法调用的规则和成员属性方法调用规则基本类似</p>
<ul>
<li>使用<code>appdomain.Invoke</code>(“命名空间.类名”, “静态方法名”, null, 参数列表)来调用静态方法。</li>
<li>使用<code>appdomain.Invoke</code>(IMethod对象, null, 参数列表)来调用静态方法。</li>
<li>使用无GC Alloc方式，使用using BeginInvoke push Invoke read -&gt; ubpir方式来调用静态方法。</li>
</ul>
<img src="/2023/10/04/IL/ILRuntime/image-20231004160502363.png" srcset="/img/loading.gif" lazyload class="" title="image-20231004160502363">

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs csharp">IType type = appDomain.LoadedTypes[<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>];<br><span class="hljs-built_in">object</span> obj = ((ILType)type).Instantiate();<br><br><span class="hljs-comment">// 静态方法调用有两种方式</span><br><span class="hljs-comment">// 1. 直接通过appdomain.Invoke(&quot;命名空间.类名&quot;, &quot;静态方法名&quot;, null, 参数列表) 调用静态方法</span><br>appDomain.Invoke(<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>, <span class="hljs-string">&quot;TestFun&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br><span class="hljs-keyword">var</span> invoke = appDomain.Invoke(<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>, <span class="hljs-string">&quot;TestFun2&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">20</span>);<br>print(invoke); <span class="hljs-comment">// 有参数有返回值</span><br><br><span class="hljs-comment">// 2. 通过类似反射的IMethod调用方法</span><br><span class="hljs-comment">// 通过IType中的GetMethod方法，类似反射一样的获取对应类中的方法</span><br><span class="hljs-comment">// 两者方式的统一找方法名方式</span><br>IMethod method = type.GetMethod(<span class="hljs-string">&quot;TestFun&quot;</span>, <span class="hljs-number">0</span>);<br>IMethod method2 = type.GetMethod(<span class="hljs-string">&quot;TestFun2&quot;</span>, <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 2-1. 通过appdomain.Invoke（IMethod对象, null, 参数列表）</span><br><span class="hljs-comment">// 获取对应类的IType</span><br>appDomain.Invoke(method, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br><span class="hljs-keyword">var</span> o = appDomain.Invoke(method2, <span class="hljs-literal">null</span>, <span class="hljs-number">110</span>);<br>print(o);<br><br><span class="hljs-comment">// 2-2. 通过更节约性能的无GC Alloc方式（调用完后直接回收）调用，类似上节课的成员属性</span><br><span class="hljs-comment">// using (var method = appDomain.BeginInvoke(methodName))</span><br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">//     method.Push.....(1000); // 传入指定类型参数</span><br><span class="hljs-comment">//     method.Invoke(); // 执行方法</span><br><span class="hljs-comment">//     method.Read....() // 获取指定类型返回值</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> method3 = appDomain.BeginInvoke(method))<br>&#123;<br>    method3.Invoke();<br>&#125;<br><br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> method4 = appDomain.BeginInvoke(method2))<br>&#123;<br>    method4.PushInteger(<span class="hljs-number">1000</span>);<br>    method4.Invoke();<br>    <span class="hljs-keyword">var</span> i = method4.ReadInteger();<br>    print(i);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="在Unity中跨域调用ILRuntime中的成员方法"><a href="#在Unity中跨域调用ILRuntime中的成员方法" class="headerlink" title="在Unity中跨域调用ILRuntime中的成员方法"></a>在Unity中跨域调用<code>ILRuntime</code>中的成员方法</h4><p>在Unity中跨域调用<code>ILRuntime</code>中的成员方法需要遵循以下步骤：</p>
<ol>
<li>获取方法信息：通过<code>IType</code>中的<code>GetMethod</code>方法，类似反射一样获取对应类中的方法。</li>
<li>调用方法：可以通过<code>appdomain.Invoke</code>方法或者更节约性能的无GC Alloc方式调用方法。</li>
<li>对于无GC Alloc方式调用方法，可以使用<code>using</code>语句块结构，通过<code>appDomain.BeginInvoke</code>、<code>method.PushObject</code>和<code>method.Invoke</code>等方法完成方法的调用。</li>
</ol>
<p><strong>成员方法调用和静态方法调用几乎一样</strong></p>
<p><strong>区别就是需要先创建对象，将对象传入之前为null的地方</strong></p>
<img src="/2023/10/04/IL/ILRuntime/image-20231004161247741.png" srcset="/img/loading.gif" lazyload class="" title="image-20231004161247741">

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs csharp">IType type = appDomain.LoadedTypes[<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>];<br><span class="hljs-built_in">object</span> obj = ((ILType)type).Instantiate();<br><br><span class="hljs-comment">// 成员方法调用和静态方法调用几乎一样</span><br><span class="hljs-comment">// 区别就是需要先创建对象，将对象传入之前为null的地方</span><br><span class="hljs-comment">// 1. 直接通过appdomain.Invoke(&quot;命名空间.类名&quot;, &quot;方法名&quot;, 类对象, 参数列表)</span><br>appDomain.Invoke(<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>, <span class="hljs-string">&quot;TestFun&quot;</span>, obj, <span class="hljs-literal">null</span>); <span class="hljs-comment">// 成员方法要传实例对象</span><br><br><span class="hljs-built_in">int</span> i = (<span class="hljs-built_in">int</span>)appDomain.Invoke(<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>, <span class="hljs-string">&quot;TestFun2&quot;</span>, obj, <span class="hljs-number">100</span>); <span class="hljs-comment">// 成员方法要传实例对象</span><br>print(i);<br><br><span class="hljs-comment">// 2. 通过类似反射的IMethod调用方法 两种调用方法</span><br>IMethod method1 = type.GetMethod(<span class="hljs-string">&quot;TestFun&quot;</span>, <span class="hljs-number">0</span>);<br>IMethod method2 = type.GetMethod(<span class="hljs-string">&quot;TestFun2&quot;</span>, <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 2-1. 通过appdomain.Invoke（IMethod对象, 类对象, 参数列表）</span><br>appDomain.Invoke(method1, obj);<br><span class="hljs-built_in">int</span> o = (<span class="hljs-built_in">int</span>)appDomain.Invoke(method2, obj, <span class="hljs-number">1000</span>);<br>print(o);<br><br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> method = appDomain.BeginInvoke(method1))<br>&#123;<br>    method.PushObject(obj);<br>    method.Invoke();<br>&#125;<br><br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> method = appDomain.BeginInvoke(method2))<br>&#123;<br>    method.PushObject(obj);<br>    method.PushInteger(<span class="hljs-number">10000</span>);<br>    method.Invoke();<br>    <span class="hljs-built_in">int</span> count = method.ReadInteger();<br>    print(count);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="在Unity中跨域调用ILRuntime中的重载方法"><a href="#在Unity中跨域调用ILRuntime中的重载方法" class="headerlink" title="在Unity中跨域调用ILRuntime中的重载方法"></a>在Unity中跨域调用<code>ILRuntime</code>中的重载方法</h4><p>在Unity中跨域调用<code>ILRuntime</code>中的重载方法需要遵循以下步骤：</p>
<ol>
<li>获取方法信息：通过<code>IType</code>中的<code>GetMethod</code>方法，类似反射一样获取对应类中的方法。</li>
<li>调用方法：可以通过<code>appdomain.Invoke</code>方法或者更节约性能的无GC Alloc方式调用方法。</li>
<li>对于无GC Alloc方式调用方法，可以使用<code>using</code>语句块结构，通过<code>appDomain.BeginInvoke</code>、<code>method.PushObject</code>和<code>method.Invoke</code>等方法完成方法的调用。</li>
</ol>
<p>重载方法的调用和普通方法的调用类似，只需确保传递的参数类型和数量与目标方法的签名匹配即可。</p>
<p>同时我们也会发现对于重载方法有两种情况</p>
<p>参数数量不同 类型相同</p>
<p>参数数量相同 类型不同 对于类型不同我们需要其他的方法</p>
<ul>
<li>我们需要通过<code>GetMethod</code>方法来获取指定参数类型的函数</li>
<li>获取参数对应的<code>IType</code>类型，利用<code>appDomain</code>中的<code>GetType</code>方法 获取指定变量类型的<code>IType</code></li>
<li>放入参数列表中，将获取到的<code>IType</code>放入<code>List&lt;IType&gt;</code>中</li>
<li>-传入<code>GetMethod</code>中获取指定类型参数，使用<code>GetMethod</code>的另一个重载，传入指定类型获取方法信息</li>
</ul>
<img src="/2023/10/04/IL/ILRuntime/image-20231004161307514.png" srcset="/img/loading.gif" lazyload class="" title="image-20231004161307514">

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs csharp">IType type = appDomain.LoadedTypes[<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>];<br><span class="hljs-built_in">object</span> obj = ((ILType)type).Instantiate();<br><br><span class="hljs-comment">// 1.参数数量不同</span><br><span class="hljs-comment">// 1-1.通过appDomain.Invoke调用参数数量不同格式，传入参数即可自动分别</span><br>appDomain.Invoke(<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>, <span class="hljs-string">&quot;TestFun&quot;</span>, obj, <span class="hljs-literal">null</span>);<br>appDomain.Invoke(<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>, <span class="hljs-string">&quot;TestFun&quot;</span>, obj, <span class="hljs-number">1</span>);<br><span class="hljs-comment">//对于参数数量相同 类型不同 的函数 这样调用会出现问题</span><br><span class="hljs-comment">//appDomain.Invoke(&quot;HotFix_Project.Learn.TestClass&quot;, &quot;TestFun&quot;, obj, 1.1f);</span><br><br><span class="hljs-comment">// 1-2.通过GetMethod的第二个参数来获取对应参数个数的函数</span><br>IMethod method1 = type.GetMethod(<span class="hljs-string">&quot;TestFun&quot;</span>, <span class="hljs-number">0</span>);<br>IMethod method2 = type.GetMethod(<span class="hljs-string">&quot;TestFun&quot;</span>, <span class="hljs-number">1</span>);<br>appDomain.Invoke(method1, obj);<br>appDomain.Invoke(method2, obj, <span class="hljs-number">1</span>);<br><span class="hljs-comment">//appDomain.Invoke(method2,obj,1.1);</span><br><br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> method3 = appDomain.BeginInvoke(method2))<br>&#123;<br>    method3.PushObject(obj);<br>    method3.PushInteger(<span class="hljs-number">6</span>);<br>    method3.Invoke();<br>&#125;<br><br><span class="hljs-comment">// 2.参数数量相同，类型不同，通过上面两种方式直接使用无法确定取出来的函数是谁</span><br><span class="hljs-comment">// 我们需要通过GetMethod方法来获取指定参数类型的函数</span><br><span class="hljs-comment">// 2.1-获取参数对应的IType类型，利用appDomain中的GetType方法 获取指定变量类型的IType</span><br><span class="hljs-comment">// 2.2-放入参数列表中，将获取到的IType放入List&lt;IType&gt;中</span><br><span class="hljs-comment">// 2.3-传入GetMethod中获取指定类型参数，使用GetMethod的另一个重载，传入指定类型获取方法信息</span><br>IType floatType = appDomain.GetType(<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">float</span>));<br>List&lt;IType&gt; list = <span class="hljs-keyword">new</span> List&lt;IType&gt;();<br>list.Add(floatType);<br>method2 = type.GetMethod(<span class="hljs-string">&quot;TestFun&quot;</span>, list, <span class="hljs-literal">null</span>);<br>appDomain.Invoke(method2, obj, <span class="hljs-number">1.1f</span>);<br><br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> method4 = appDomain.BeginInvoke(method2))<br>&#123;<br>    method4.PushObject(obj);<br>    method4.PushFloat(<span class="hljs-number">11.1f</span>);<br>    method4.Invoke();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="在Unity中跨域调用ILRuntime中的ref-out-方法调用"><a href="#在Unity中跨域调用ILRuntime中的ref-out-方法调用" class="headerlink" title="在Unity中跨域调用ILRuntime中的ref/out 方法调用"></a>在Unity中跨域调用<code>ILRuntime</code>中的<code>ref/out</code> 方法调用</h4><p>在Unity中跨域调用<code>ILRuntime</code>中的<code>ref/out</code>方法调用需要遵循以下步骤：</p>
<ul>
<li><p>需要通过IMethod方法调用 并且需要使用无GC Alloc方法调用</p>
</li>
<li><p>和其他函数不一样的地方 需要先压入ref或out参数的初始值</p>
</li>
<li><p>和其它函数调用写法一致 压入调用对象 压入各参数</p>
</li>
<li><p>ref和out因为在一开始就压入了值 在这里需要压入他们的索引位置</p>
</li>
<li><p>ref和out参数 压入参数引用索引值即可 从0开始</p>
</li>
<li><p>通过Read按顺序获取ref&#x2F;out参数的值 和返回值，返回值最后获取</p>
  <img src="/2023/10/04/IL/ILRuntime/image-20231004161324331.png" srcset="/img/loading.gif" lazyload class="" title="image-20231004161324331">

  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs csharp">IType type = appDomain.LoadedTypes[<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>];<br><span class="hljs-built_in">object</span> obj = ((ILType)type).Instantiate();<br><span class="hljs-comment">// 需要通过IMethod方法调用并且需要使用无GC Alloc方法调用</span><br><span class="hljs-comment">// 1.和其他函数不一样的地方需要先压入ref或out参数的初始值</span><br><span class="hljs-comment">// 2.和其他函数调用写法一致，压入调用对象，压入各参数</span><br><span class="hljs-comment">// 3.ref和out因为在一开始就压入了值，在这里需要压入他们的索引位置</span><br><span class="hljs-comment">// ref和out参数，压入参数引用索引值即可，从0开始</span><br><span class="hljs-comment">// 4.通过Read按顺序获取ref/out参数的值和返回值，返回值最后获取</span><br>IMethod methodName = type.GetMethod(<span class="hljs-string">&quot;TestFun3&quot;</span>, <span class="hljs-number">3</span>);<br>List&lt;<span class="hljs-built_in">int</span>&gt; list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;() &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> &#125;;<br><br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> method = appDomain.BeginInvoke(methodName))<br>&#123;<br>    method.PushObject(list); <span class="hljs-comment">// ref 需要在外部初始化</span><br>    method.PushObject(<span class="hljs-literal">null</span>); <span class="hljs-comment">// out 不需要在外部初始化</span><br>    method.PushObject(obj);<br>    method.PushInteger(<span class="hljs-number">100</span>);<br>    <span class="hljs-comment">// ref和out的索引值，只算它们，从0开始</span><br>    method.PushReference(<span class="hljs-number">0</span>);<br>    method.PushReference(<span class="hljs-number">1</span>);<br><br>    method.Invoke();<br><br>    <span class="hljs-comment">// 获取ref和out参数的值</span><br>    List&lt;<span class="hljs-built_in">int</span>&gt; list2 = method.ReadObject&lt;List&lt;<span class="hljs-built_in">int</span>&gt;&gt;(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">float</span> f = method.ReadFloat(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 获取函数返回值</span><br>    <span class="hljs-built_in">float</span> returnValue = method.ReadFloat();<br><br>    print(<span class="hljs-string">&quot;ref参数的长度: &quot;</span> + list2.Count);<br>    print(<span class="hljs-string">&quot;out参数: &quot;</span> + f);<br>    print(<span class="hljs-string">&quot;返回值: &quot;</span> + returnValue);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  在调用时多了三个步骤</p>
<p>  需要先压入ref或out参数的初始值</p>
<p>  压入参数环节压入引用索引值</p>
<p>  通过Read按顺序获取ref、out参数，返回值最后获取</p>
</li>
</ul>
<h3 id="ILRuntime调用Unity"><a href="#ILRuntime调用Unity" class="headerlink" title="ILRuntime调用Unity"></a><code>ILRuntime</code>调用Unity</h3><p>我们在做有热更新功能的项目时，往往会有大量的逻辑是在热更工程中完成的。类似与<code>Xlua</code>中的热更新。所以我们会在热更工程中做主入口。</p>
<p>调用Unity工程相关的内容就像在Unity开发中使用样引用命名空间后，直接使用即可，之所以我们能够直接使用，是因为热更工程已经引用了Unity对应的<code>Dll</code>文件</p>
<p>注意：</p>
<p>测试热更工程中 只关联引用了部分Unity相关<code>dll</code></p>
<p>如果想要使用更多，只需要把对应Unity的Dll文件拷贝到热更工程中的<code>**UnityDlls**</code>文件夹中即可</p>
<p>首先我们需要找到Unity对应的DLL文件 一般在</p>
<blockquote>
<p>X:\XXX\UnityEngine\Unity版本\Editor\Data\Managed\UnityEngine\</p>
</blockquote>
<p>这个路径之下，例如，我在热更工程里加上一个Unity物理系统 <code>UnityEngine.PhysicsModule.dll</code> 就需要这个dll<code>文件</code> 添加到热更工程的<code>UnityDlls</code>文件夹之后，就需要在程序集中添加引用</p>
<img src="/2023/10/04/IL/ILRuntime/image-20231004161451982.png" srcset="/img/loading.gif" lazyload class="" title="image-20231004161451982">

<p>ILRuntime与Unity通讯</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ILRuntimeMain</span><br>    &#123;<br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 把逻辑处理权交给热更工程</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 主入口函数</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>        &#123;<br>            GameObject obj = <span class="hljs-keyword">new</span> GameObject(<span class="hljs-string">&quot;ILRunTime创建的空物体&quot;</span>);<br>            obj.transform.position = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br>            Debug.Log(obj.transform.position);<br>            Rigidbody rig = obj.AddComponent&lt;Rigidbody&gt;();<br>            rig.mass = <span class="hljs-number">999</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<img src="/2023/10/04/IL/ILRuntime/image-20231004161512545.png" srcset="/img/loading.gif" lazyload class="" title="image-20231004161512545">

<img src="/2023/10/04/IL/ILRuntime/image-20231004161529394.png" srcset="/img/loading.gif" lazyload class="" title="image-20231004161529394">

<p>可以看见，都设置成功了</p>
<h3 id="更多跨域调用"><a href="#更多跨域调用" class="headerlink" title="更多跨域调用"></a>更多跨域调用</h3><h4 id="委托调用"><a href="#委托调用" class="headerlink" title="委托调用"></a>委托调用</h4><p>在Unity中自定义委托后使用</p>
<ul>
<li>1.<code>ILRuntime</code>中委托成员 关联<code>ILRuntime</code>工程中函数直接常规使用即可 不会出现报错</li>
<li>2.Unity中委托成员 关联<code>ILRuntime</code>工程中函数直接关联会出现报错，这里就涉及到委托成员的跨域 相当于Unity中的委托成员中存储了<code>ILRuntime</code>工程中的函数 就存在了跨域调用</li>
<li>我们需要进行以下处理：可以通过报错信息中的提示 在进行初始化时进行代码的添加主要有两部分：</li>
<li>1.注册委托(主要目的，避免<code>IL2CPP</code>打包裁剪报错)</li>
<li>2.注册委托转换器（主要目的，<code>ILRuntime</code>内部所有的委托都是以Action或Fun来存储的）自己定义的委托需要转换成Action或Fun</li>
<li>注意：</li>
<li>1.委托的注册相关流程必须在主工程中完成，在<code>ILRuntime</code>中没用</li>
<li>2.为了避免添加自定义委托转换器我们在使用委托时 尽量使用System命名空间中的  Action和Fun 这样就不需要进行注册委托转换器了，只需要注册即可</li>
</ul>
<p>在<code>ILRuntime</code>中自定义委托后使用</p>
<ul>
<li>1.<code>ILRuntime</code>中委托成员 关联<code>ILRuntime</code>工程中函数</li>
<li>2.Unity中委托成员 关联<code>ILRuntime</code>工程中函数</li>
<li>一般不会出现基础工程中 使用还无法预知的可变代码</li>
<li>所以我们不需要考虑这种情况</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs csharp">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyUnityDel1</span>()</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MyUnityDel2</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> j</span>)</span>;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>: <span class="hljs-title">MonoBehaviour</span><br>  &#123;<br>      <span class="hljs-keyword">public</span> MyUnityDel1 fun1;<br>      <span class="hljs-keyword">public</span> MyUnityDel2 fun2;<br>&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyILDel1</span>()</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MyILDel2</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> j</span>)</span>;<br>  <br>  <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ILRuntimeMain</span><br>  &#123;<br>      <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>      <span class="hljs-comment"><span class="hljs-doctag">///</span> 把逻辑处理权交给热更工程</span><br>      <span class="hljs-comment"><span class="hljs-doctag">///</span> 主入口函数</span><br>      <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>      &#123;<br>          <span class="hljs-comment">//在ILRuntime中声明委托成员 关联Unity工程中的函数</span><br>          MyUnityDel1 fun = Fun1;<br>          fun();<br>          MyUnityDel2 fun2 = Fun2;<br>          <span class="hljs-built_in">int</span> result = fun2(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);<br>          Debug.Log(result);<br>          <br>          <span class="hljs-comment">//在Unity中声明委托成员 关联IL工程中的函数</span><br>          ILRuntimeCallUnity ilcu = GameObject.Find(<span class="hljs-string">&quot;ILRuntimeCallUnity&quot;</span>).GetComponent&lt;ILRuntimeCallUnity&gt;();<br>          ilcu.fun1 = Fun1; <span class="hljs-comment">//关联</span><br>          ilcu.fun1(); <span class="hljs-comment">//调用</span><br>          ilcu.fun2 = Fun2;<br>          result = ilcu.fun2(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>);<br>          Debug.Log(result);<br><br>          <span class="hljs-comment">//使用Action和Func 这种委托就不需要进行注册委托和转换器了</span><br>          ilcu.FunAction = Fun1;<br>          ilcu.FunAction();<br>          ilcu.Func = Fun2;<br>          result =ilcu.Func(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br>          Debug.Log(result);<br>          <br>          <span class="hljs-comment">//IL的委托 直接用就行 不需要注册</span><br><br>      &#125;<br><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Fun1</span>()</span><br>      &#123;<br>          Debug.Log(<span class="hljs-string">&quot;IL_Fun1&quot;</span>);<br>      &#125;<br><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Fun2</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span><br>      &#123;<br>          Debug.Log(<span class="hljs-string">&quot;Il_Fun2&quot;</span>);<br>          <span class="hljs-keyword">return</span> a + b;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>我们注册就得去注册委托和*<code>委托转换器</code> 一般都是在初始化操作中 对委托进行注册*</p>
<img src="/2023/10/04/IL/ILRuntime/image-20231004161559951.png" srcset="/img/loading.gif" lazyload class="" title="image-20231004161559951">

<img src="/2023/10/04/IL/ILRuntime/image-20231004161614002.png" srcset="/img/loading.gif" lazyload class="" title="image-20231004161614002">

<h4 id="跨域继承类"><a href="#跨域继承类" class="headerlink" title="跨域继承类"></a>跨域继承类</h4><p>建议： 最好不要跨域去继承类</p>
<p><code>ILRuntime</code>支持在热更工程中继承Unity主工程中的类  这就是跨域继承</p>
<p>注意：</p>
<p><code>ILRuntime</code>中的跨域继承主要指热更工程继承Unity工程中的类</p>
<p>不存在Unity继承<code>ILRuntime</code>中的类一说</p>
<p>只需要记住，一般都是可变的（热更工程）使用不变的（Unity工程）内容</p>
<p><strong>跨域继承基本原理：</strong></p>
<p>ILRuntime中的跨域继承实际上并不是直接继承Unity中的基类</p>
<p>而是继承的适配器类</p>
<p>基类（Unity中）</p>
<p>|</p>
<p>适配器类（Unity工程中的实际类型）</p>
<p>|</p>
<p>子类（ILRuntime中）</p>
<p>例如，如果我在Unity工程内声明一个接口，跨域继承之后 这个接口就被适配器变为类了就相当于跨越继承了两个类，这是C#所不允许的</p>
<p><strong>注意事项</strong>：</p>
<p>1.跨域继承时，不支持多继承，即同时继承类和接口</p>
<p>2.<strong>如果项目框架设计中一定要出现多继承  那么在跨域继承时可以在主工程中声明一个多继承的基类用于跨域继承 意思就是 声明一个基础类 ，让这个基础类继承接口和要继承的那个类，再将它作为被跨域继承的那个类 ，去让适配器创建该类的适配器类。</strong></p>
<p>3.跨域继承中，<strong>不能在基类的构造函数中调用该类的虚函数 会报错</strong></p>
<p><strong>如何进行跨域继承</strong></p>
<p>1.在Untiy工程中实现基类</p>
<p>2.在ILRuntime工程中继承基类</p>
<p>3.通过工具生成跨域继承适配器</p>
<blockquote>
<p>ILRuntime\Assets\Samples\ILRuntime\2.1.0\Demo\Editor\ILRuntimeCrossBinding.cs</p>
</blockquote>
<p>其中生成跨域继承适配器 只需要找到这个脚本 然后根据模版修改内容 一般是<strong>适配器生成的文件路径</strong> 方法里的<strong>类名</strong> 和<strong>创建类的命名空间</strong></p>
<p>4.在初始化时，注册跨域继承适配器对象</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">appDomain.RegisterCrossBindingAdaptor(<span class="hljs-keyword">new</span> <span class="hljs-type"></span>适配器类名());<br></code></pre></td></tr></table></figure>

<p>例子：</p>
<p>我们首先来写一个测试类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs csharp">    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 跨域调用类</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ILClass</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> valuePublic;<br>        <span class="hljs-keyword">protected</span> <span class="hljs-built_in">int</span> valueProtected;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-built_in">int</span> ValuePro<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">set</span>;<br>        &#125;<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TestFun</span>(<span class="hljs-params"> <span class="hljs-built_in">string</span> str</span>)</span><br>        &#123;<br>            Debug.Log(<span class="hljs-string">&quot;TestFun 成员方法&quot;</span>+str);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TestAvstract</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i</span>)</span>;<br>    &#125;<br><br><span class="hljs-comment">// 热更工程中 实现 Unity工程的这个类</span><br>						ILClassU i = <span class="hljs-keyword">new</span> ILClassU();<br>            i.TestFun(<span class="hljs-string">&quot;Heart&quot;</span>);<br>            i.TestAvstract(<span class="hljs-number">100</span>);<br>            i.valuePublic = <span class="hljs-number">1000</span>;<br>     <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 继承来自Unity工程的类</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ILClassU</span> : <span class="hljs-title">ILClass</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">int</span> ValuePro<br>        &#123;<br>            <span class="hljs-keyword">get</span> =&gt; valueProtected;<br>            <span class="hljs-keyword">set</span> =&gt; valueProtected = <span class="hljs-keyword">value</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TestFun</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> str</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">base</span>.TestFun(str);<br>            Debug.Log(<span class="hljs-string">&quot;ILClassU TestFun 成员方法&quot;</span> + str);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TestAvstract</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i</span>)</span><br>        &#123;<br>            Debug.Log(<span class="hljs-string">&quot;TestAvstract 成员方法&quot;</span> + i);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<img src="/2023/10/04/IL/ILRuntime/image-20231004161709727.png" srcset="/img/loading.gif" lazyload class="" title="image-20231004161709727">

<h4 id="CLR重定向和CLR绑定"><a href="#CLR重定向和CLR绑定" class="headerlink" title="CLR重定向和CLR绑定"></a>CLR重定向和CLR绑定</h4><p>CLR（公共语言运行时 Common Language Runtime）它提供了内存管理、垃圾回收、安全性和代码访问控制等功能，它帮助我们实现跨平台和跨语言</p>
<p>CLR重定向（CLR Redirection）是一种机制，允许将程序集的引用从一个版本重定向到另一个版本。我们可以通过CLR重定向，将<strong>某一个方法的执行</strong>定位到我们的<strong>自定义逻辑中</strong>，而不是执行原本的方法逻辑   有点类似重写</p>
<p>CLR绑定（CLR Binding）是指在运行时将程序集和类型加载到应用程序的过程。CLR会根据程序的需求来查找和加载程序集，并将其加载到应用程序域中以供使用。</p>
<p><strong>默认情况下</strong>，ILRuntime热更工程调用Unity主工程相关内容都会通过反射来调用</p>
<p>这样有2个缺点：</p>
<ul>
<li>1.性能较低，反射调用比直接调用效率低</li>
<li>2.IL2CPP打包时容易被裁剪</li>
</ul>
<p>因此ILRuntime提供了自动分析生成CLR绑定的工具</p>
<p><strong>为什么要进行 CLR绑定</strong></p>
<p>它的作用是：</p>
<ul>
<li>1**.可以提高性能，将反射调用变为了直接调用**</li>
<li>2**.避免IL2CPP裁剪有用内容**</li>
</ul>
<p>原理：</p>
<p>CLR绑定，就是借助了ILRuntime的CLR重定向机制来实现的</p>
<p>本质上就是将方法的反射调用重定向到了我们自定义的方法里面来</p>
<p>注意：</p>
<p><strong>每次我们打包发布工程之前都要记得生成CLR绑定</strong></p>
<p><strong>如何进行CLR绑定</strong></p>
<ul>
<li><ol>
<li>打开 Samples\ILRuntime\2.1.0\Demo\Editor`ILRuntimeCLRBinding<code>.cs 代码 在 </code>InitILRuntime&#96; 函数中注册跨域继承相关的类 以及 其他内容（以后会讲解）</li>
</ol>
</li>
<li><ol>
<li>点击 工具栏——&gt;ILRuntime——&gt;通过自动分析热更DLL生成CLR绑定</li>
</ol>
</li>
</ul>
<p>此时就可以在<code>ILRuntimeCLRBinding.cs</code> 代码中设置的到处路径中看到生成的绑定代码</p>
<ol>
<li>在初始化处 添加：<code>ILRuntime.Runtime.Generated.CLRBindings.Initialize(appDomain);</code></li>
</ol>
<p>注意：</p>
<p>如果在CLR绑定注册前进行了CLR重定向相关设置   为了保证自定义的重定向能够正常使用初始化CLR绑定   一定要放在最后一步   这样就不会影响自己想要保留的重定向等初始化操作了</p>
<p>CLR生成的代码</p>
<img src="/2023/10/04/IL/ILRuntime/image-20231004161732218.png" srcset="/img/loading.gif" lazyload class="" title="image-20231004161732218">

<p>使用CLR之后的性能优化</p>
<img src="/2023/10/04/IL/ILRuntime/image-20231004161745689.png" srcset="/img/loading.gif" lazyload class="" title="image-20231004161745689">

<p>自定义CLR重定向是指在ILRuntime中重新定义CLR所需的类型和方法的映射关系。通过自定义CLR重定向，可以实现在热更新中使用不同于Unity环境下的类型和方法。</p>
<p>在ILRuntime中，可以通过自定义实现<code>ILRuntime.CLR.TypeRedirection.ILTypeRedirectionAttribute</code>和<code>ILRuntime.CLR.MethodRedirection.ILMethodRedirectionAttribute</code>来进行CLR重定向。通过这些属性，可以指定需要重定向的类型和方法，以及它们的替代实现。</p>
<p>自定义CLR重定向的步骤如下：</p>
<ol>
<li>创建自定义重定向类，实现<code>ILRuntime.CLR.TypeRedirection.ILTypeRedirection</code>或<code>ILRuntime.CLR.MethodRedirection.ILMethodRedirection</code>接口。</li>
<li>在自定义重定向类上使用<code>ILRuntime.CLR.TypeRedirection.ILTypeRedirectionAttribute</code>或<code>ILRuntime.CLR.MethodRedirection.ILMethodRedirectionAttribute</code>，并指定要重定向的类型或方法。</li>
<li>在ILRuntime的初始化代码中，调用<code>ILRuntime.Runtime.Enviorment.AppDomain.RegisterCLRRedirection</code>方法，注册自定义的CLR重定向类。</li>
</ol>
<p>通过自定义CLR重定向，可以实现在热更新中替换CLR的类型和方法，从而达到热更新逻辑与Unity环境解耦的目的。</p>
<p>CLR绑定就是利用CLR重定向将原本需要反射调用的内容变为直接调用  可以帮助我们</p>
<ul>
<li>1.提升ILRuntime的性能</li>
<li>2.避免IL2CPP打包时裁剪我们需要用的内容</li>
</ul>
<h4 id="值类型绑定"><a href="#值类型绑定" class="headerlink" title="值类型绑定"></a>值类型绑定</h4><p>ILRuntime支持将值类型绑定到引擎的值类型，以实现在热更工程中使用引擎值类型的功能。</p>
<p>就是把Unity当中的一些常用值类型方法进行CLR绑定，可以大幅度提升热更新工程的效率</p>
<p>值类型绑定的步骤如下：</p>
<ol>
<li>创建值类型绑定类，在该类中实现值类型的转换逻辑。</li>
<li>注册值类型绑定 <code>appDomain.RegisterValueTypeBinder(typeof(值类型),new 绑定类());</code></li>
<li>在CLR绑定脚本中注册，在加载dll和pdb后注册</li>
</ol>
<p>值类型绑定的作用是为了在热更工程中使用引擎的值类型，例如Vector3、Quaternion等。通过值类型绑定，我们可以直接在热更工程中使用这些值类型，而无需使用引擎提供的其他替代方案。</p>
<p>在<code>ILRuntimeCLRBinding</code> 文件添加值类型绑定代码 在<strong>初始化</strong>的时候一样添加</p>
<p>可以优化性能</p>
<h4 id="MonoBehaviour"><a href="#MonoBehaviour" class="headerlink" title="MonoBehaviour"></a><code>MonoBehaviour</code></h4><ul>
<li>ILRuntime中支持在热更工程中跨域继承MonoBehaviour</li>
<li>注册跨域继承适配器</li>
<li>对泛型方法AddComponent进行重定向（较为复杂）</li>
<li>推荐大家类似Lua中一样使用MonoBehaviour</li>
<li>在主工程中通过委托或事件的形式派发生命周期函数 到 热更中</li>
<li>主要原因：MonoBehaviour是一个很特殊的类，很多底层逻辑是在C++中处理的</li>
<li>比如其中public字段的序列化，在Inspector窗口中显示的功能  如果在热更工程中去写，底层C++逻辑无法获取到热更工程中C#相关的信息</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ILRuntimeMono</span> : <span class="hljs-title">MonoBehaviour</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> Action startEvent;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> Action updateEvent;<br><br>        <span class="hljs-comment">//特殊的函数  Awake</span><br>        <span class="hljs-comment">//在ILRuntime中，MonoBehaviour的Awake函数是不会被调用的 因为Awake的执行时机很快</span><br>        <span class="hljs-comment">//在脚本添加的时候就会自动执行 所以不能使用事件分发的方式进行调用</span><br>        <span class="hljs-comment">//我们可以在脚本添加的时候 添加相关逻辑就可以 无需模拟</span><br>        <br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>        &#123;<br>            startEvent?.Invoke();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>        &#123;<br>            updateEvent?.Invoke();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<img src="/2023/10/04/IL/ILRuntime/image-20231004161808874.png" srcset="/img/loading.gif" lazyload class="" title="image-20231004161808874">

<h4 id="协程和异步函数"><a href="#协程和异步函数" class="headerlink" title="协程和异步函数"></a>协程和异步函数</h4><p>我们只需要在<strong>初始化</strong><code>InitILRuntime</code>中注册协同程序的跨域继承适配器就能使用协同程序了</p>
<p>同步协程的适配器我们可以在示例工程中获取<code>CoroutineAdapter</code></p>
<blockquote>
<p>异步我们可以使用网上的<a target="_blank" rel="noopener" href="https://github.com/jumpst/jumpst.github.io/blob/abc112a1ad718910f39bdd34323ae2633551a650/">https://github.com/jumpst/jumpst.github.io/blob/abc112a1ad718910f39bdd34323ae2633551a650/</a></p>
</blockquote>
<img src="/2023/10/04/IL/ILRuntime/image-20231004161831292.png" srcset="/img/loading.gif" lazyload class="" title="image-20231004161831292">

<p>之所以需要注册跨域继承适配器</p>
<p>是因为在ILRuntime中的协同程序和异步函数</p>
<p>编译后本质上是通过状态机利用对象的状态来达到的异步</p>
<p>这里面的对象就用到了跨域继承</p>
<p>所以我们需要注册他们的跨域继承适配器来让热更新工程正常使用他们</p>
<h4 id="Unity反射调用ILRuntime"><a href="#Unity反射调用ILRuntime" class="headerlink" title="Unity反射调用ILRuntime"></a>Unity反射调用ILRuntime</h4><p>在热更工程中使用反射  按照反射的规则正常使用即可 和C#中反射没有任何区别</p>
<p>在主入口之后就使用</p>
<p>在Unity工程中利用反射获取热更工程中的内容</p>
<img src="/2023/10/04/IL/ILRuntime/image-20231004161936277.png" srcset="/img/loading.gif" lazyload class="" title="image-20231004161936277">

<img src="/2023/10/04/IL/ILRuntime/image-20231004161943482.png" srcset="/img/loading.gif" lazyload class="" title="image-20231004161943482">

<img src="/2023/10/04/IL/ILRuntime/image-20231004161949879.png" srcset="/img/loading.gif" lazyload class="" title="image-20231004161949879">

<h4 id="序列化库"><a href="#序列化库" class="headerlink" title="序列化库"></a>序列化库</h4><p>常见的序列化库有以下几种：</p>
<ul>
<li><code>Json.NET</code>: 一个流行的高性能JSON框架，支持.NET平台和多种编程语言。</li>
<li><code>Protocol Buffers</code>: 由Google开发的二进制序列化格式，具有高效的编解码速度和紧凑的数据大小。</li>
<li><code>MessagePack</code>: 一种快速、小巧的二进制序列化格式，支持多种编程语言。</li>
<li><code>BinaryFormatter</code>: .NET框架自带的二进制序列化器，可以将对象序列化为二进制格式。</li>
<li><code>XmlSerializer</code>: .NET框架自带的XML序列化器，可以将对象序列化为XML格式。</li>
</ul>
<p>这些库都是存在于主工程中的 那么当使用他们序列化反序列化热更工程中的对象时 他们是不能识别的，所以就得在IL中使用序列化库 ListJson库在demo工程中就能获取</p>
<p>Protobuf库获取：<a target="_blank" rel="noopener" href="https://gitee.com/cyecp/protobuf-net">下载地址</a></p>
<p>如何自己改相关库</p>
<p>1.正确创建热更类型的实例（利用之前反射相关的创建方式）</p>
<p>2.获取泛型容器类的真实热热更类型</p>
<p>3.序列化子对象</p>
<p>4.重定向泛型方法</p>
<p><strong>改写序列化库时，不能通过Activator来创建实例</strong></p>
<p>我使用ListJson，同样的一样需要在<strong>初始化</strong><code>InitILRuntime</code>的时候注册ListJson</p>
<img src="/2023/10/04/IL/ILRuntime/image-20231004162010373.png" srcset="/img/loading.gif" lazyload class="" title="image-20231004162010373">

<h3 id="调试相关"><a href="#调试相关" class="headerlink" title="调试相关"></a>调试相关</h3><p>调试ILRuntime 下载专门的调试工具 在初始化的位置<code>InitILRuntime</code>添加</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">AppDomain<span class="hljs-selector-class">.DebugService</span><span class="hljs-selector-class">.StartDebugService</span>(端口号)<br></code></pre></td></tr></table></figure>

<p>在热更工程的 调试页签中 选择 <strong>Attach to ILRuntime</strong> 即可开始断点调试</p>
<p>如果想要断点调试 得保证Unity工程或者项目已经启动才能附加调试</p>
<p>通过协同程序，等待调试器链接（否则我们无法对一开始的逻辑 进行断点）</p>
<p>判断调试器链接的API为 <strong><code>appDomain.DebugService.IsDebuggerAttached</code></strong></p>
<p>注意：</p>
<p>1.附加到ILRuntime后</p>
<p>弹出窗口中填写的内容为IP地址和端口号，意味着我们可以调试各种设备</p>
<p>只要保证IP地址和端口号正确即可</p>
<p>2.如果ILRuntime相关的dll和pdb文件没有加载成功，调试会失败</p>
<h3 id="性能相关"><a href="#性能相关" class="headerlink" title="性能相关"></a>性能相关</h3><h3 id="寄存器模式"><a href="#寄存器模式" class="headerlink" title="寄存器模式"></a>寄存器模式</h3><p>该模式通过ILRuntime自己的 编译器以及指令集(JIT Compiler) 将原始DLL的 微软中间语言(MSIL) 指令集转换成一个  自定义的基于寄存器的指令集，再进行解译执行</p>
<p>在ILRuntime中使用寄存器模式可以有效的提高性能，主要有以下特点</p>
<ol>
<li>数值计算性能会大幅提升，包括for循环等需要数值计算的控制流</li>
<li>属性的调用开销，for循环里调用其他热更内方法的性能会有所提升</li>
<li>注意：如果一个方法即没有数值计算，也没有频繁调用热更内的的方法或者访问属性，只是调用系统或UnityAPI，那么不会产生任何优化   甚至一些情况下性能还会低于传统模式</li>
</ol>
<p>开启寄存器，有两种方式</p>
<p><strong>全局开启</strong> 在启动IL时<code>StartILRunTime</code>  <strong>new</strong>的时候调用构造函数  有五种模式</p>
<img src="/2023/10/04/IL/ILRuntime/image-20231004162030018.png" srcset="/img/loading.gif" lazyload class="" title="image-20231004162030018">

<ol>
<li>None：不启用寄存器模式</li>
<li><code>JITOnDemand</code>:  如果要全局开启寄存器 那么模式一定是这个 按需即时编译(JIT)模式，使用该模式在默认的情况下会按照原始的方式运行，当该方法被反复执行时，会被标记为需要被JIT，并在后台线程完成JIT编译后切换到寄存器模式运行</li>
<li><code>JITImmediately</code>(全局开启时不推荐)：立即JIT模式，使用该模式时，当方法被调用的瞬间即会被执行JIT编译 在第一次执行时即使用寄存器模式运行。 JIT会在当前线程发生，因此如果方法过于复杂在第一次执行时可能会有较大的初始化时间</li>
<li><code>NoJIT</code>： 禁用JIT模式，该方法在执行时会始终以传统方式执行</li>
<li><code>ForceInline</code>(全局开启时不使用)：强制内联模式，该模式只对方法的Attribute生效， 标注该模式的方法在被调用时将会无视方法体内容大小，强制被内联</li>
</ol>
<p><strong>指定开启</strong></p>
<p>在指定的类和方式前加上特性 <code>[ILRuntimeJIT(寄存器模式)]</code> 自己指定哪些类和方法使用</p>
<p>注意：在热更工程中使用该特性，我们需要引用ILRuntime库</p>
<p>可以在项目工程文件中找到 <code>Library\\ScriptAssemblies\\ILRuntime.dll</code> 进行引用（将复制本地设置为false，避免生成时导出）</p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><h3 id="相关代码-相关初始化"><a href="#相关代码-相关初始化" class="headerlink" title="相关代码  相关初始化"></a>相关代码  相关初始化</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ILRunTimeManager</span> : <span class="hljs-title">MonoBehaviour</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ILRunTimeManager _instance;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ILRunTimeManager Instance<br>        &#123;<br>            <span class="hljs-keyword">get</span><br>            &#123;<br>                <span class="hljs-keyword">if</span> (_instance == <span class="hljs-literal">null</span>)<br>                &#123;<br>                    <span class="hljs-comment">//这样就是一个长久存在的单例了</span><br>                    <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> GameObject(<span class="hljs-string">&quot;ILRunTimeManager&quot;</span>);<br>                    _instance = obj.AddComponent&lt;ILRunTimeManager&gt;();<br>                    DontDestroyOnLoad(obj);<br>                &#125;<br><br>                <span class="hljs-keyword">return</span> _instance;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> AppDomain AppDomain;<br>        <span class="hljs-keyword">private</span> MemoryStream _dllStream;<br>        <span class="hljs-keyword">private</span> MemoryStream _pdbStream;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> _isStart = <span class="hljs-literal">false</span>; <span class="hljs-comment">//是否启动了ILRunTime 避免重复启动</span><br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 启动ILRunTime</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StartILRunTime</span>(<span class="hljs-params">UnityAction callBack = <span class="hljs-literal">null</span></span>)</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (!_isStart)<br>            &#123;<br>                _isStart = <span class="hljs-literal">true</span>;<br>                AppDomain = <span class="hljs-keyword">new</span> AppDomain();<br>                <span class="hljs-comment">//寄存器模式</span><br>                <span class="hljs-comment">//AppDomain = new AppDomain(ILRuntimeJITFlags.JITOnDemand);</span><br>                StartCoroutine(LoadHotUpdateInfo(callBack));<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 初始化ILRuntime相关内容</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitILRuntime</span>()</span><br>        &#123;<br>						<span class="hljs-comment">//如果想使用Unity自带的性能调试窗口 调试ILRuntime的内容 就需要加入该行代码</span><br>            AppDomain.UnityMainThreadID = Thread.CurrentThread.ManagedThreadId;<br><br>            <span class="hljs-comment">//其他的初始化操作</span><br>            <span class="hljs-comment">//委托转换器 注册(把自定义委托转为Action或者Func) 无参无返回值的委托就不需要注册委托 只需要注册转换器</span><br>            AppDomain.DelegateManager.RegisterDelegateConvertor&lt;Learn.MyUnityDel1&gt;((act) =&gt;<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Learn.MyUnityDel1(() =&gt; &#123; ((System.Action)act)(); &#125;);<br>            &#125;);<br>            <span class="hljs-comment">//委托注册</span><br>            AppDomain.DelegateManager.RegisterFunctionDelegate&lt;System.Int32, System.Int32, System.Int32&gt;();<br>            <span class="hljs-comment">//委托转换器 注册</span><br>            AppDomain.DelegateManager.RegisterDelegateConvertor&lt;Learn.MyUnityDel2&gt;((act) =&gt;<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Learn.MyUnityDel2((i, j) =&gt;<br>                &#123;<br>                    <span class="hljs-keyword">return</span> ((System.Func&lt;System.Int32, System.Int32, System.Int32&gt;)act)(i, j);<br>                &#125;);<br>            &#125;);<br><br>            <span class="hljs-comment">//注册跨域继承适配器</span><br>            AppDomain.RegisterCrossBindingAdaptor(<span class="hljs-keyword">new</span> ILClassAdapter());<br>            <span class="hljs-comment">//注册协同程序相关的 跨域继承适配器</span><br>            AppDomain.RegisterCrossBindingAdaptor(<span class="hljs-keyword">new</span> CoroutineAdapter());<br>            <span class="hljs-comment">//注册协同程序相关的 跨域继承适配器 异步</span><br>            AppDomain.RegisterCrossBindingAdaptor(<span class="hljs-keyword">new</span> IAsyncStateMachineClassInheritanceAdaptor());<br>            <br>            <span class="hljs-comment">//值类型绑定的注册</span><br>            AppDomain.RegisterValueTypeBinder(<span class="hljs-keyword">typeof</span>(Vector3), <span class="hljs-keyword">new</span> Vector3Binder());<br>            AppDomain.RegisterValueTypeBinder(<span class="hljs-keyword">typeof</span>(Vector2), <span class="hljs-keyword">new</span> Vector2Binder());<br>            AppDomain.RegisterValueTypeBinder(<span class="hljs-keyword">typeof</span>(Quaternion), <span class="hljs-keyword">new</span> QuaternionBinder());<br>            <br>            <span class="hljs-comment">//注册ListJson相关的</span><br>            LitJson.JsonMapper.RegisterILRuntimeCLRRedirection(AppDomain);<br>            <br><br>            <span class="hljs-comment">//CLR重定向内容 要写到CLR绑定之前</span><br>            System.Type debugType = <span class="hljs-keyword">typeof</span>(Debug);<br>            MethodInfo methodInfo = debugType.GetMethod(<span class="hljs-string">&quot;Log&quot;</span>, <span class="hljs-keyword">new</span> System.Type[] &#123; <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">object</span>) &#125;);<br>            <span class="hljs-comment">//进行CLR重定向 重定向到MyLog方法 获取到热更新的Debug行号信息 </span><br>            <span class="hljs-comment">//AppDomain.RegisterCLRMethodRedirection(methodInfo,MyLog);</span><br><br>            <span class="hljs-comment">//注册CLR绑定相关的信息</span><br>            ILRuntime.Runtime.Generated.CLRBindings.Initialize(AppDomain);<br>            <br>        &#125;<br>        <br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">unsafe</span> StackObject* MyLog(ILIntepreter __intp, StackObject* __esp, List&lt;<span class="hljs-built_in">object</span>&gt; __mStack, CLRMethod method, <span class="hljs-built_in">bool</span> isnewobj)<br>        &#123;<br>            ILRuntime.Runtime.Enviorment.AppDomain __domain = __intp.AppDomain;<br>            <span class="hljs-comment">//移动到栈底 用于之后返回</span><br>            StackObject* __ret = ILIntepreter.Minus(__esp, <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//获取参数值</span><br>            StackObject* ptr_of_this_method;<br>            ptr_of_this_method = ILIntepreter.Minus(__esp, <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//类型转换 将StackObject转换为Unity当中的类型</span><br>            System.Object @message = (System.Object)<span class="hljs-keyword">typeof</span>(System.Object).CheckCLRTypes(StackObject.ToObject(ptr_of_this_method, __domain, __mStack), (ILRuntime.CLR.Utils.Extensions.TypeFlags)<span class="hljs-number">0</span>);<br>            <span class="hljs-comment">//清理当前栈指针内存</span><br>            __intp.Free(ptr_of_this_method);<br>            <span class="hljs-comment">//获取对应的 行号等等相关信息</span><br>            <span class="hljs-keyword">var</span> stackTrace = __domain.DebugService.GetStackTrace(__intp);<br><br>            <span class="hljs-comment">//重定向相关逻辑代码</span><br>            UnityEngine.Debug.Log(@message + <span class="hljs-string">&quot;\\n&quot;</span> + stackTrace);<br><br>            <span class="hljs-comment">//返回</span><br>            <span class="hljs-keyword">return</span> __ret;<br>        &#125;<br>        <br>        <br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 启动完毕并且初始化完毕后 想要执行的热更新的逻辑</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ILRunTimeLoadOverDoSomthing</span>()</span><br>        &#123;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> </span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StopILRunTime</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (_dllStream != <span class="hljs-literal">null</span>)<br>                _dllStream.Close();<br>            <span class="hljs-keyword">if</span> (_pdbStream != <span class="hljs-literal">null</span>)<br>                _pdbStream.Close();<br>            _dllStream = <span class="hljs-literal">null</span>;<br>            _pdbStream = <span class="hljs-literal">null</span>;<br>            AppDomain = <span class="hljs-literal">null</span>;<br>            _isStart = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 加载热更DLL的配置文件</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br>        <span class="hljs-function">IEnumerator <span class="hljs-title">LoadHotUpdateInfo</span>(<span class="hljs-params">UnityAction callBack = <span class="hljs-literal">null</span></span>)</span><br>        &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> UNITY_ANDROID</span><br>            <span class="hljs-keyword">var</span> reqDll = UnityWebRequest.Get(Application.streamingAssetsPath+ <span class="hljs-string">&quot;/HotFix_Project.dll&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>            UnityWebRequest reqDll =<br>                UnityWebRequest.Get(<span class="hljs-string">&quot;file:///&quot;</span> + Application.streamingAssetsPath + <span class="hljs-string">&quot;/HotFix_Project.dll&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> reqDll.SendWebRequest();<br>            <span class="hljs-keyword">if</span> (reqDll.isNetworkError || reqDll.isHttpError)<br>            &#123;<br>                Debug.LogError(<span class="hljs-string">&quot;加载热更DLL失败&quot;</span> + reqDll.error);<br>            &#125;<br><br>            <span class="hljs-keyword">var</span> dllBytes = reqDll.downloadHandler.data;<br>            reqDll.Dispose();<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> UNITY_ANDROID</span><br>            <span class="hljs-keyword">var</span> reqPdb = UnityWebRequest.Get(Application.streamingAssetsPath+ <span class="hljs-string">&quot;/HotFix_Project.pdb&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>            <span class="hljs-keyword">var</span> reqPdb = UnityWebRequest.Get(<span class="hljs-string">&quot;file:///&quot;</span> + Application.streamingAssetsPath + <span class="hljs-string">&quot;/HotFix_Project.pdb&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> reqPdb.SendWebRequest();<br>            <span class="hljs-keyword">if</span> (reqPdb.isNetworkError || reqPdb.isHttpError)<br>            &#123;<br>                Debug.LogError(<span class="hljs-string">&quot;加载热更Pdb失败&quot;</span> + reqPdb.error);<br>            &#125;<br><br>            <span class="hljs-keyword">var</span> pdbBytes = reqPdb.downloadHandler.data;<br>            reqPdb.Dispose();<br><br>            _dllStream = <span class="hljs-keyword">new</span> MemoryStream(dllBytes);<br>            _pdbStream = <span class="hljs-keyword">new</span> MemoryStream(pdbBytes);<br><br>            <span class="hljs-comment">//PS:记得一个要加载 </span><br>            AppDomain.LoadAssembly(_dllStream, _pdbStream, <span class="hljs-keyword">new</span> PdbReaderProvider());<br><br>            InitILRuntime();<br>            ILRunTimeLoadOverDoSomthing();<br><br>            <span class="hljs-comment">//当ILRuntime初始化完毕 想要在外部执行的内容</span><br>            callBack?.Invoke();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>相关代码</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UnityCallILRunTime</span> : <span class="hljs-title">MonoBehaviour</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>        &#123;<br>            ILRunTimeManager.Instance.StartILRunTime(() =&gt;<br>            &#123;<br>                <span class="hljs-comment">//这里面做的事情就是在加载完毕后执行的热更新的逻辑</span><br>                ILRuntime.Runtime.Enviorment.AppDomain appDomain = ILRunTimeManager.Instance.AppDomain;<br>                <span class="hljs-comment">//CallClass(appDomain);</span><br>                <span class="hljs-comment">//CallProp(appDomain);</span><br>                <span class="hljs-comment">//CallStatic(appDomain);</span><br>                <span class="hljs-comment">//CallMember(appDomain);</span><br>                <span class="hljs-comment">//CallOverMember(appDomain);</span><br>                CallRefOut(appDomain);<br>            &#125;);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallClass</span>(<span class="hljs-params">AppDomain appDomain</span>)</span><br>        &#123;<br>            <span class="hljs-comment">//方式一：appdomain中的Instantiate方法</span><br>            <span class="hljs-comment">//       参数一：类的命名空间.类名</span><br>            <span class="hljs-comment">//       参数二：参数列表</span><br>            <span class="hljs-built_in">object</span> obj = appDomain.Instantiate(<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>);<br>            print(obj);<br>            obj = appDomain.Instantiate(<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] &#123; <span class="hljs-string">&quot;我是参数&quot;</span> &#125;);<br>            print(obj);<br><br>            <span class="hljs-comment">//方式二：appdomain中LoadedTypes字典获取IType类型后，强转为ILType后调用Instantiate方法</span><br>            <span class="hljs-comment">//       该方式类似反射  更加推荐 在调用对象方法和变量时 更方便</span><br>            IType type = appDomain.LoadedTypes[<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>];<br>            obj = ((ILType)type).Instantiate();<br>            print(obj);<br>            obj = ((ILType)type).Instantiate(<span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] &#123; <span class="hljs-string">&quot;我是参数2&quot;</span> &#125;);<br>            print(obj);<br><br>            <span class="hljs-comment">//方式三：通过方式二中得到的IType对象，再去得到它的构造函数进行实例化</span><br>            <span class="hljs-comment">//       该方式类似反射</span><br>            IType type2 = appDomain.LoadedTypes[<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>];<br>            ConstructorInfo info = type2.ReflectionType.GetConstructor(<span class="hljs-keyword">new</span> Type[<span class="hljs-number">0</span>]); <span class="hljs-comment">//无参构造函数</span><br>            obj = info.Invoke(<span class="hljs-literal">null</span>);<br>            print(obj);<br>            ConstructorInfo info2 = type2.ReflectionType.GetConstructor(<span class="hljs-keyword">new</span> Type[] &#123; <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>) &#125;); <span class="hljs-comment">//有参</span><br>            obj = info2.Invoke(<span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] &#123; <span class="hljs-string">&quot;1111&quot;</span> &#125;);<br>            print(obj);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallProp</span>(<span class="hljs-params">AppDomain appDomain</span>)</span><br>        &#123;<br>            IType type = appDomain.LoadedTypes[<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>];<br>            <span class="hljs-built_in">object</span> obj = ((ILType)type).Instantiate(<span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] &#123; <span class="hljs-string">&quot;234&quot;</span> &#125;);<br><br>            <span class="hljs-comment">//ILRuntime中并没有提供让Unity直接获取或修改成员变量的方案</span><br>            <span class="hljs-comment">//我们只能通过在ILRuntime中封装属性的形式来达到目的</span><br><br>            <span class="hljs-comment">//1.获取方法信息</span><br>            <span class="hljs-comment">//  通过IType中的GetMethod方法，类似反射一样的获取对应类中的方法</span><br>            <span class="hljs-comment">//  规则：get_属性名 为对应属性获取</span><br>            <span class="hljs-comment">//        set_属性名 为对应属性的赋值</span><br>            IMethod getStr = type.GetMethod(<span class="hljs-string">&quot;get_Str&quot;</span>, <span class="hljs-number">0</span>);<br>            IMethod setStr = type.GetMethod(<span class="hljs-string">&quot;set_Str&quot;</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">//参数 set是要传入值 </span><br>            <span class="hljs-comment">//2.调用方法</span><br>            <span class="hljs-comment">//  有两种方式</span><br>            <span class="hljs-comment">//  2-1:通过appdomain.Invoke（方法名，调用对象，参数）调用</span><br>            <span class="hljs-comment">//去获取属性</span><br>            <span class="hljs-built_in">string</span> str = appDomain.Invoke(getStr, obj, <span class="hljs-literal">null</span>).ToString();<br>            print(str);<br>            <span class="hljs-comment">//去修改属性</span><br>            appDomain.Invoke(setStr, obj, <span class="hljs-string">&quot;我是修改后的值&quot;</span>);<br>            str = appDomain.Invoke(getStr, obj).ToString(); <span class="hljs-comment">//设置完后再次获取 看看是否修改成功</span><br>            print(str);<br><br>            <span class="hljs-comment">//  2-2:通过更节约性能的无GC Alloc（调用完后直接回收）方式调用</span><br>            <span class="hljs-comment">//    using (var method = appDomain.BeginInvoke(methodName))</span><br>            <span class="hljs-comment">//    &#123;</span><br>            <span class="hljs-comment">//          method.PushObject(obj);//传入执行该方法的对象</span><br>            <span class="hljs-comment">//          method.Push.....(1000);//传入指定类型参数</span><br>            <span class="hljs-comment">//          method.Invoke();//执行方法</span><br>            <span class="hljs-comment">//          method.Read....()//获取指定类型返回值</span><br>            <span class="hljs-comment">//    &#125;</span><br><br>            <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> method = appDomain.BeginInvoke(getStr))<br>            &#123;<br>                <span class="hljs-comment">//这种方式更推荐</span><br>                method.PushObject(obj);<br>                method.Invoke();<br>                str = method.ReadValueType&lt;<span class="hljs-built_in">string</span>&gt;();<br>                print(str + <span class="hljs-string">&quot;2&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-comment">//Set 要先设置值 然后装入</span><br>            <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> method = appDomain.BeginInvoke(setStr))<br>            &#123;<br>                method.PushObject(obj);<br>                <span class="hljs-built_in">string</span> temp = <span class="hljs-string">&quot;我是再次修改后的值&quot;</span>;<br>                method.PushValueType(<span class="hljs-keyword">ref</span> temp);<br>                method.Invoke();<br>            &#125;<br><br>            <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> method = appDomain.BeginInvoke(getStr))<br>            &#123;<br>                <span class="hljs-comment">//这种方式更推荐</span><br>                method.PushObject(obj);<br>                method.Invoke();<br>                str = method.ReadValueType&lt;<span class="hljs-built_in">string</span>&gt;();<br>                print(str);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallStatic</span>(<span class="hljs-params">AppDomain appDomain</span>)</span><br>        &#123;<br>            IType type = appDomain.LoadedTypes[<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>];<br>            <span class="hljs-built_in">object</span> obj = ((ILType)type).Instantiate();<br><br>            <span class="hljs-comment">//静态方法调用有两种方式</span><br>            <span class="hljs-comment">//1.直接通过appdomain.Invoke(&quot;命名空间.类名&quot;, &quot;静态方法名&quot;, null, 参数列表)</span><br>            <span class="hljs-comment">//  调用静态方法</span><br>            appDomain.Invoke(<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>, <span class="hljs-string">&quot;TestStaticFun&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">var</span> invoke = appDomain.Invoke(<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>, <span class="hljs-string">&quot;TestStaticFun2&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">20</span>);<br>            print(invoke); <span class="hljs-comment">//有参数有返回值</span><br><br>            <span class="hljs-comment">//2.通过类似反射的IMethod调用方法</span><br>            <span class="hljs-comment">//  通过IType中的GetMethod方法，类似反射一样的获取对应类中的方法</span><br>            <span class="hljs-comment">//两者方式的统一找方法名方式</span><br>            IMethod method = type.GetMethod(<span class="hljs-string">&quot;TestStaticFun&quot;</span>, <span class="hljs-number">0</span>);<br>            IMethod method2 = type.GetMethod(<span class="hljs-string">&quot;TestStaticFun2&quot;</span>, <span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">//  2-1.通过appdomain.Invoke（IMethod对象, null, 参数列表）</span><br>            <span class="hljs-comment">//获取对应类 的 Itype</span><br>            appDomain.Invoke(method, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">var</span> o = appDomain.Invoke(method2, <span class="hljs-literal">null</span>, <span class="hljs-number">110</span>);<br>            print(o);<br><br>            <span class="hljs-comment">//  2-2.通过更节约性能的无GC Alloc方式（调用完后直接回收）调用，类似上节课的成员属性</span><br>            <span class="hljs-comment">//    using (var method = appDomain.BeginInvoke(methodName))</span><br>            <span class="hljs-comment">//    &#123;</span><br>            <span class="hljs-comment">//          method.Push.....(1000);//传入指定类型参数</span><br>            <span class="hljs-comment">//          method.Invoke();//执行方法</span><br>            <span class="hljs-comment">//          method.Read....()//获取指定类型返回值</span><br>            <span class="hljs-comment">//    &#125;</span><br><br>            <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> method3 = appDomain.BeginInvoke(method))<br>            &#123;<br>                method3.Invoke();<br>            &#125;<br><br>            <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> method4 = appDomain.BeginInvoke(method2))<br>            &#123;<br>                method4.PushInteger(<span class="hljs-number">1000</span>);<br>                method4.Invoke();<br>                <span class="hljs-keyword">var</span> i = method4.ReadInteger();<br>                print(i);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallMember</span>(<span class="hljs-params">AppDomain appDomain</span>)</span><br>        &#123;<br>            IType type = appDomain.LoadedTypes[<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>];<br>            <span class="hljs-built_in">object</span> obj = ((ILType)type).Instantiate();<br><br>            <span class="hljs-comment">//成员方法调用和静态方法调用几乎一样</span><br>            <span class="hljs-comment">//区别就是需要先创建对象，将对象传入之前为null的地方</span><br>            <span class="hljs-comment">//1.直接通过appdomain.Invoke(&quot;命名空间.类名&quot;, &quot;方法名&quot;, 类对象, 参数列表)</span><br>            appDomain.Invoke(<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>, <span class="hljs-string">&quot;TestFun&quot;</span>, obj, <span class="hljs-literal">null</span>); <span class="hljs-comment">//成员方法要传实例对象</span><br><br>            <span class="hljs-built_in">int</span> i = (<span class="hljs-built_in">int</span>)appDomain.Invoke(<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>, <span class="hljs-string">&quot;TestFun2&quot;</span>, obj, <span class="hljs-number">100</span>); <span class="hljs-comment">//成员方法要传实例对象</span><br>            print(i);<br><br>            <span class="hljs-comment">//2.通过类似反射的IMethod调用方法 两种调用方法</span><br>            IMethod method1 = type.GetMethod(<span class="hljs-string">&quot;TestFun&quot;</span>, <span class="hljs-number">0</span>);<br>            IMethod method2 = type.GetMethod(<span class="hljs-string">&quot;TestFun2&quot;</span>, <span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">//  2-1.通过appdomain.Invoke（IMethod对象, 类对象, 参数列表）</span><br>            appDomain.Invoke(method1, obj);<br>            <span class="hljs-built_in">int</span> o = (<span class="hljs-built_in">int</span>)appDomain.Invoke(method2, obj, <span class="hljs-number">1000</span>);<br>            print(o);<br><br>            <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> method = appDomain.BeginInvoke(method1))<br>            &#123;<br>                method.PushObject(obj);<br>                method.Invoke();<br>            &#125;<br><br>            <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> method = appDomain.BeginInvoke(method2))<br>            &#123;<br>                method.PushObject(obj);<br>                method.PushInteger(<span class="hljs-number">10000</span>);<br>                method.Invoke();<br>                <span class="hljs-built_in">int</span> count = method.ReadInteger();<br>                print(count);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallOverMember</span>(<span class="hljs-params">AppDomain appDomain</span>)</span><br>        &#123;<br>            IType type = appDomain.LoadedTypes[<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>];<br>            <span class="hljs-built_in">object</span> obj = ((ILType)type).Instantiate();<br><br>            <span class="hljs-comment">//1.参数数量不同</span><br>            <span class="hljs-comment">//1-1.通过appDomain.Invoke调用参数数量不同格式，传入参数即可自动分别</span><br>            appDomain.Invoke(<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>, <span class="hljs-string">&quot;TestFun&quot;</span>, obj, <span class="hljs-literal">null</span>);<br>            appDomain.Invoke(<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>, <span class="hljs-string">&quot;TestFun&quot;</span>, obj, <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//对于参数数量相同 类型不同 的函数 这样调用会出现问题</span><br>            <span class="hljs-comment">//appDomain.Invoke(&quot;HotFix_Project.Learn.TestClass&quot;, &quot;TestFun&quot;, obj, 1.1f);</span><br><br>            <span class="hljs-comment">//1-2.通过GetMethod的第二个参数来获取对应参数个数的函数</span><br>            IMethod method1 = type.GetMethod(<span class="hljs-string">&quot;TestFun&quot;</span>, <span class="hljs-number">0</span>);<br>            IMethod method2 = type.GetMethod(<span class="hljs-string">&quot;TestFun&quot;</span>, <span class="hljs-number">1</span>);<br>            appDomain.Invoke(method1, obj);<br>            appDomain.Invoke(method2, obj, <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//appDomain.Invoke(method2,obj,1.1);</span><br><br>            <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> method3 = appDomain.BeginInvoke(method2))<br>            &#123;<br>                method3.PushObject(obj);<br>                method3.PushInteger(<span class="hljs-number">6</span>);<br>                method3.Invoke();<br>            &#125;<br><br>            <span class="hljs-comment">//2.参数数量相同，类型不同，通过上面两种方式直接使用无法确定取出来的函数是谁</span><br>            <span class="hljs-comment">//  我们需要通过GetMethod方法来获取指定参数类型的函数</span><br>            <span class="hljs-comment">//  2.1-获取参数对应的IType类型，利用appDomain中的GetType方法 获取指定变量类型的IType</span><br>            <span class="hljs-comment">//  2.2-放入参数列表中，将获取到的IType放入List&lt;IType&gt;中</span><br>            <span class="hljs-comment">//  2.3-传入GetMethod中获取指定类型参数，使用GetMethod的另一个重载，传入指定类型获取方法信息</span><br>            IType floatType = appDomain.GetType(<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">float</span>));<br>            List&lt;IType&gt; list = <span class="hljs-keyword">new</span> List&lt;IType&gt;();<br>            list.Add(floatType);<br>            method2 = type.GetMethod(<span class="hljs-string">&quot;TestFun&quot;</span>, list, <span class="hljs-literal">null</span>);<br>            appDomain.Invoke(method2, obj, <span class="hljs-number">1.1f</span>);<br><br>            <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> method4 = appDomain.BeginInvoke(method2))<br>            &#123;<br>                method4.PushObject(obj);<br>                method4.PushFloat(<span class="hljs-number">11.1f</span>);<br>                method4.Invoke();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallRefOut</span>(<span class="hljs-params">AppDomain appDomain</span>)</span><br>        &#123;<br>            IType type = appDomain.LoadedTypes[<span class="hljs-string">&quot;HotFix_Project.Learn.TestClass&quot;</span>];<br>            <span class="hljs-built_in">object</span> obj = ((ILType)type).Instantiate();<br>            <span class="hljs-comment">//需要通过IMethod方法调用 并且需要使用无GC Alloc方法调用</span><br>            <span class="hljs-comment">//1.和其他函数不一样的地方 需要先压入ref或out参数的初始值</span><br>            <span class="hljs-comment">//2.和其它函数调用写法一致 压入调用对象 压入各参数</span><br>            <span class="hljs-comment">//3.ref和out因为在一开始就压入了值</span><br>            <span class="hljs-comment">//在这里需要压入他们的索引位置</span><br>            <span class="hljs-comment">//ref和out参数 压入参数引用索引值即可 从0开始</span><br>            <span class="hljs-comment">//4.通过Read按顺序获取ref/out参数的值 和返回值，返回值最后获取</span><br>            IMethod methodName = type.GetMethod(<span class="hljs-string">&quot;TestFun3&quot;</span>, <span class="hljs-number">3</span>);<br>            List&lt;<span class="hljs-built_in">int</span>&gt; list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;() &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> &#125;;<br><br>            <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> method = appDomain.BeginInvoke(methodName))<br>            &#123;<br>                method.PushObject(list); <span class="hljs-comment">//ref 需要在外部初始化</span><br>                method.PushObject(<span class="hljs-literal">null</span>); <span class="hljs-comment">//out 不需要在外部初始化</span><br>                method.PushObject(obj);<br>                method.PushInteger(<span class="hljs-number">100</span>);<br>                <span class="hljs-comment">//ref和out的索引值 只算他们 从0开始</span><br>                method.PushReference(<span class="hljs-number">0</span>);<br>                method.PushReference(<span class="hljs-number">1</span>);<br><br>                method.Invoke();<br><br>                <span class="hljs-comment">//获取ref和out参数的值</span><br>                List&lt;<span class="hljs-built_in">int</span>&gt; list2 = method.ReadObject&lt;List&lt;<span class="hljs-built_in">int</span>&gt;&gt;(<span class="hljs-number">0</span>);<br>                <span class="hljs-built_in">float</span> f = method.ReadFloat(<span class="hljs-number">1</span>);<br><br>                <span class="hljs-comment">//获取函数返回值</span><br>                <span class="hljs-built_in">float</span> returnValue = method.ReadFloat();<br><br>                print(<span class="hljs-string">&quot;ref参数的长度: &quot;</span> + list2.Count);<br>                print(<span class="hljs-string">&quot;out参数: &quot;</span> + f);<br>                print(<span class="hljs-string">&quot;返回值: &quot;</span> + returnValue);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/IL/" class="category-chain-item">IL</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Unity/" class="print-no-link">#Unity</a>
      
        <a href="/tags/ILRuntime/" class="print-no-link">#ILRuntime</a>
      
        <a href="/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/" class="print-no-link">#热更新</a>
      
        <a href="/tags/C/" class="print-no-link">#C#</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>ILRuntime</div>
      <div>http://fussen.top/2023/10/04/IL/ILRuntime/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Heart</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年10月4日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/11/01/CSharp/%E7%BD%91%E7%BB%9C%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/" title="网络开发基础">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">网络开发基础</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/10/04/Engine/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96-%E4%BA%8C%E8%BF%9B%E5%88%B6/" title="数据持久化-二进制">
                        <span class="hidden-mobile">数据持久化-二进制</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      赣ICP备2023005513号
    </a>
  </span>
  
    
      <span>
        <a
          href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=36078102000072"
          rel="nofollow noopener"
          class="beian-police"
          target="_blank"
        >
          
            <span style="visibility: hidden; width: 0">|</span>
            <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
          
          <span>赣公网安备 36078102000072号</span>
        </a>
      </span>
    
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
