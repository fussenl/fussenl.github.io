<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Xlua</title>
    <link href="/2023/04/04/Lua/Xlua/"/>
    <url>/2023/04/04/Lua/Xlua/</url>
    
    <content type="html"><![CDATA[<h1 id="XLua"><a href="#XLua" class="headerlink" title="XLua"></a>XLua</h1><p>xLua是用来实现Lua代码与C#代码相互调用的插件。我们可以借助这个插件来实现热更新方案。</p><p>可以运行时把C#实现（方法，操作符，属性，事件，构造函数，析构函数，支持泛化）替换成lua实现<br>为Unity提供Lua编程能力，让C#和Lua可以相互调用访问</p><p>热更新原理：</p><img src="/2023/04/04/Lua/Xlua/image-20230607210704674.png" class="" title="image-20230607210704674"><blockquote><p>万物 Hello World</p></blockquote><p>在C#中运行Lua代码首先我们要创建Lua运行环境，XLua中有一个LuaEnv可供我们使用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">LuaEnv luaEnv = <span class="hljs-keyword">new</span> LuaEnv();<br><span class="hljs-comment">//打印字符串 可传入三个参数 内容, 哪个脚本, 哪个解析器   </span><br>luaEnv.DoString(<span class="hljs-string">&quot;print(&#x27;HelloWord&#x27;)&quot;</span>);<br></code></pre></td></tr></table></figure><p>XLua常用方法：</p><ul><li>DoString</li></ul>]]></content>
    
    
    <categories>
      
      <category>Lua</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>Lua</tag>
      
      <tag>热更新</tag>
      
      <tag>Xlua</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lua</title>
    <link href="/2023/04/03/Lua/Lua/"/>
    <url>/2023/04/03/Lua/Lua/</url>
    
    <content type="html"><![CDATA[<h2 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h2><h4 id="类型与值"><a href="#类型与值" class="headerlink" title="类型与值"></a>类型与值</h4><p>lua是一种动态类型的语言，并没有类型定义的语法，每个值都携带<strong>类型</strong>的信息</p><p>函数<strong>type</strong> 可根据传入的值返回其类型</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs lua">                <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-string">&quot;Hello wold&quot;</span>))        <span class="hljs-comment">-- string</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-number">10.4</span>*<span class="hljs-number">3</span>))              <span class="hljs-comment">-- number</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-built_in">print</span>))               <span class="hljs-comment">-- function</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-built_in">type</span>))                <span class="hljs-comment">-- function</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-literal">true</span>))                <span class="hljs-comment">-- boolean</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-literal">nil</span>))                 <span class="hljs-comment">-- nil</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-built_in">type</span>(X)))             <span class="hljs-comment">-- string</span><br><br><br>变量没有预定义的类型，任何类型值都可以包含进变量<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(a))                <span class="hljs-comment">-- nil （a尚未初始化）</span><br>                a = <span class="hljs-number">10</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(a))                <span class="hljs-comment">-- number</span><br>                a = <span class="hljs-string">&quot;a string!!&quot;</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(a))                <span class="hljs-comment">-- string</span><br>                a = <span class="hljs-built_in">print</span>                     <span class="hljs-comment">-- 是的，这是合法的！</span><br>                a(<span class="hljs-built_in">type</span>(a))                    <span class="hljs-comment">-- function</span><br><br></code></pre></td></tr></table></figure><ul><li>其中 boolean不是一个条件值的唯一表现形式 false 和nil 都被视为nil</li><li>Number类型值可以是32位的 0.3e12 ， 5e+20 都是合法值</li><li>string 我们可以使用 字符# 来获取字符串长度</li></ul><p>string常用API：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lua">str=<span class="hljs-string">&quot;abcdefg&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">upper</span>(str)) <span class="hljs-comment">--小转大</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">lower</span>(str)) <span class="hljs-comment">--大转小</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">reverse</span>(str)) <span class="hljs-comment">--翻转</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">find</span>(str,<span class="hljs-string">&quot;cd&quot;</span>)) <span class="hljs-comment">--查找 按索引查找 按1开始</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">sub</span>(str,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)) <span class="hljs-comment">--截取 按索引查找  索引按1开始</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">rep</span>(str,<span class="hljs-number">2</span>)) <span class="hljs-comment">--重复</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">gsub</span>(str,<span class="hljs-string">&quot;ab&quot;</span>,<span class="hljs-string">&quot;QW&quot;</span>)) <span class="hljs-comment">--修改 第二个参数是修改了多少次</span><br><span class="hljs-comment">--别的类型转字符串</span><br>a=<span class="hljs-number">123</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">tostring</span>(a)==<span class="hljs-string">&quot;123&quot;</span>) <span class="hljs-comment">--tostring是显示</span><br><span class="hljs-comment">-- 字符转ASCII码</span><br>a=<span class="hljs-built_in">string</span>.<span class="hljs-built_in">byte</span>(<span class="hljs-string">&quot;Lua&quot;</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">--第二个参数是指定位置</span><br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-comment">-- ASCII码 转字符</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">char</span>(a))<br><span class="hljs-comment">--字符串拼接使用 .. %d</span><br></code></pre></td></tr></table></figure><p>是的，Lua包含类似于C语言的转义字符</p><table><thead><tr><th align="left">转义符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>\a</code></td><td align="left">响铃</td></tr><tr><td align="left"><code>\b</code></td><td align="left">退格</td></tr><tr><td align="left"><code>\f</code></td><td align="left">提供表格</td></tr><tr><td align="left"><code>\n</code></td><td align="left">换行</td></tr><tr><td align="left"><code>\r</code></td><td align="left">回车</td></tr><tr><td align="left"><code>\t</code></td><td align="left">水平tab</td></tr><tr><td align="left"><code>\v</code></td><td align="left">垂直tab</td></tr><tr><td align="left"><code>\\</code></td><td align="left">反斜杠</td></tr><tr><td align="left"><code>\&quot;</code></td><td align="left">双引号</td></tr><tr><td align="left"><code>\&#39;</code></td><td align="left">单引号</td></tr></tbody></table><h5 id="table"><a href="#table" class="headerlink" title="table"></a>table</h5><p> <code>table</code>类型实现了“关联数组”。“关联数组”是一种具有特殊索引方式的数组。不仅可以通过整数来索引它，还可以使用字符串或其他类型的值（除了<code>nil</code>）来索引它。</p><p>  <code>table</code>没有固定的大小，可以动态地添加任意数量的元素到一个<code>table</code>中。</p><p>  <code>table</code>是Lua中主要的（事实上也是仅有的）数据结构机制，具有强大的功能。</p><p>  在Lua中，table既不是“值”也不是“变量”，而是“对象”。</p><p>  <code>table</code>的创建是通过“构造表达式”完成的，最简单的构造表达式就是<code>&#123; &#125;</code>。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua">a = &#123; &#125;             <span class="hljs-comment">-- 创建一个table，并将它的引用存储到a</span><br>k = <span class="hljs-string">&quot;x&quot;</span><br>a[k] = <span class="hljs-number">10</span>           <span class="hljs-comment">-- 新条目，key = &quot;x&quot;, value = 10</span><br>a[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;great&quot;</span>     <span class="hljs-comment">-- 新条目，key = 20, value = &quot;great&quot;</span><br><span class="hljs-built_in">print</span>(a[<span class="hljs-string">&quot;x&quot;</span>])       <span class="hljs-comment">-- 10</span><br>k = <span class="hljs-number">20</span><br><span class="hljs-built_in">print</span>(a[k])         <span class="hljs-comment">-- “great&quot;</span><br>a[<span class="hljs-string">&quot;x&quot;</span>] = a[<span class="hljs-string">&quot;x&quot;</span>] + <span class="hljs-number">1</span> <span class="hljs-comment">-- 递增条目&quot;x&quot;</span><br><span class="hljs-built_in">print</span>(a[<span class="hljs-string">&quot;x&quot;</span>])       <span class="hljs-comment">-- 11</span><br></code></pre></td></tr></table></figure><p>  <code>table</code>永远是“匿名的”，一个持有<code>table</code>的变量与<code>table</code>自身之间没有固定的关联性。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua">a = &#123; &#125;<br>a[<span class="hljs-string">&quot;x&quot;</span>] = <span class="hljs-number">10</span><br>b = a               <span class="hljs-comment">-- b与a引用了同一个table</span><br><span class="hljs-built_in">print</span>(b[<span class="hljs-string">&quot;x&quot;</span>])       <span class="hljs-comment">-- 10</span><br>b[<span class="hljs-string">&quot;x&quot;</span>] = <span class="hljs-number">20</span><br><span class="hljs-built_in">print</span>(a[<span class="hljs-string">&quot;x&quot;</span>])       <span class="hljs-comment">-- 20</span><br>a = <span class="hljs-literal">nil</span>             <span class="hljs-comment">-- 现在只有b还在引用table</span><br>b = <span class="hljs-literal">nil</span>             <span class="hljs-comment">-- 再也没有对table的引用了</span><br><span class="hljs-comment">-- 当一个程序再也没有对一个table的引用时，Lua的垃圾收集器最终会删除该table，并复用它的内存。</span><br></code></pre></td></tr></table></figure><p>  所有<code>table</code>都可以用不同类型的索引来访问<code>value</code>（值），当需要容纳新条目时，<code>table</code>会自动增长。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua">a = &#123; &#125;<br><br><span class="hljs-comment">-- 创建1000个新条目</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>, <span class="hljs-number">1000</span> <span class="hljs-keyword">do</span> a[i] = i*<span class="hljs-number">2</span> <span class="hljs-keyword">end</span><br><span class="hljs-built_in">print</span>(a[<span class="hljs-number">9</span>])         <span class="hljs-comment">-- 18</span><br>a[<span class="hljs-string">&quot;x&quot;</span>] = <span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(a[<span class="hljs-string">&quot;x&quot;</span>])       <span class="hljs-comment">-- 10</span><br><span class="hljs-built_in">print</span>(a[<span class="hljs-string">&quot;y&quot;</span>])       <span class="hljs-comment">-- nil 该元素没有初始化</span><br><span class="hljs-comment">-- 可以将nil赋予table的某个元素来删除该元素。</span><br></code></pre></td></tr></table></figure><p>  Lua对于诸如<code>a[&quot;name&quot;]</code>的写法提供了一种更简便的“语法糖（syntactic sugar）”，可以直接输入<code>a.name</code>。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs lua">a.x = <span class="hljs-number">10</span>            <span class="hljs-comment">-- 等同于a[&quot;x&quot;] = 10</span><br><span class="hljs-built_in">print</span>(a.x)          <span class="hljs-comment">-- 等同于print(a[&quot;x&quot;])</span><br><span class="hljs-built_in">print</span>(a.y)          <span class="hljs-comment">-- 等同于print(a[&quot;y&quot;])</span><br><br><span class="hljs-comment">-- 对于Lua来说，这两种形式是等价的，可供自由选择使用。</span><br>a.x                 <span class="hljs-comment">-- 等同于a[&quot;x&quot;]</span><br>a[x]                <span class="hljs-comment">-- 以变量x的值来索引table</span><br><br><span class="hljs-comment">----------</span><br>a = &#123; &#125;<br>x = <span class="hljs-string">&quot;y&quot;</span><br>a[x] = <span class="hljs-number">10</span>           <span class="hljs-comment">-- 将10放入字段“y”</span><br><span class="hljs-built_in">print</span>(a[x])         <span class="hljs-comment">-- 10 字段“y”的值</span><br><span class="hljs-built_in">print</span>(a.x)          <span class="hljs-comment">-- nil 字段“x”（未定义）的值</span><br><span class="hljs-built_in">print</span>(a.y)          <span class="hljs-comment">-- 10 字段“y”的值</span><br></code></pre></td></tr></table></figure><p>  若要表示一个传统的数组或线性表，只需以整数作为<code>key</code>来使用<code>table</code>即可。这里不需要（也没有必要）声明一个大小值，直接初始化元素就可以了</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 读取10行内容，并存储到一个table中</span><br><br>a = &#123; &#125;<br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">10</span> <span class="hljs-keyword">do</span><br>    a[i] = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>()<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>  虽然可以用任何值作为一个<code>table</code>的索引，也可以用任何数字作为数组索引的起始值。但<strong>数组通常以1作为索引的起始值</strong>。</p><p> 长度操作符“<code>#</code>”用于返回一个数组或线性表的最后一个索引值（或为其大小）。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,#a <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(a[i])<br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>(a[#a])            <span class="hljs-comment">-- 打印列表a的最后一个值</span><br>a[#a] = <span class="hljs-literal">nil</span>             <span class="hljs-comment">-- 删除最后一个值</span><br>a[#a+<span class="hljs-number">1</span>] = v             <span class="hljs-comment">-- 将v添加到列表末尾</span><br><br><span class="hljs-comment">-- 读取一个文件的前10行</span><br>a = &#123; &#125;<br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">10</span> <span class="hljs-keyword">do</span><br>    a[#a+<span class="hljs-number">1</span>] = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>()<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>  当对索引的实际类型不是很确定时，可以明确地使用一个显式转换</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua">i = <span class="hljs-number">10</span>; j = <span class="hljs-string">&quot;10&quot;</span>; k = <span class="hljs-string">&quot;+10&quot;</span><br>a = &#123; &#125;<br>a[i] = <span class="hljs-string">&quot;one value&quot;</span><br>a[j] = <span class="hljs-string">&quot;another value&quot;</span><br>a[k] = <span class="hljs-string">&quot;yet another value&quot;</span><br><span class="hljs-built_in">print</span>(a[j])  <span class="hljs-comment">--&gt; another value</span><br><span class="hljs-built_in">print</span>(a[k]) <span class="hljs-comment">--&gt; yet another value</span><br><span class="hljs-built_in">print</span>(a[<span class="hljs-built_in">tonumber</span>(j)]) <span class="hljs-comment">--&gt; one value</span><br><span class="hljs-built_in">print</span>(a[<span class="hljs-built_in">tonumber</span>(k)]) <span class="hljs-comment">--&gt; one value</span><br></code></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">days = &#123;<span class="hljs-string">&quot;Sunday&quot;</span>, <span class="hljs-string">&quot;Monday&quot;</span>, <span class="hljs-string">&quot;Tuesday&quot;</span>, <span class="hljs-string">&quot;Wednesday&quot;</span>, <span class="hljs-string">&quot;Thursday&quot;</span>, <span class="hljs-string">&quot;Friday&quot;</span>, <span class="hljs-string">&quot;Saturday&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>  会将<code>days[1]</code>初始化为字符串“<code>Sunday</code>”、<code>days[2]</code>初始化为“<code>Monday</code>”，以此类推。</p><h5 id="复杂数据结构"><a href="#复杂数据结构" class="headerlink" title="复杂数据结构"></a>复杂数据结构</h5><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;******复杂数据类型**********&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;******字典**********&quot;</span>)<br><span class="hljs-comment">--字典是键值对组成的</span><br>dic = &#123; [<span class="hljs-string">&quot;id1&quot;</span>] = <span class="hljs-string">&quot;dove&quot;</span>, [<span class="hljs-string">&quot;age&quot;</span>] = <span class="hljs-number">12</span>, [<span class="hljs-string">&quot;socre&quot;</span>] = <span class="hljs-number">90</span>,[<span class="hljs-number">2</span>]= <span class="hljs-number">100</span> &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;访问方式1&quot;</span>)<br><span class="hljs-built_in">print</span>(dic[<span class="hljs-string">&quot;id1&quot;</span>])<br><span class="hljs-built_in">print</span>(dic[<span class="hljs-string">&quot;age&quot;</span>])<br><span class="hljs-built_in">print</span>(dic[<span class="hljs-string">&quot;socre&quot;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;访问方式2&quot;</span>)<br><span class="hljs-built_in">print</span>(dic.id1)<br><span class="hljs-built_in">print</span>(dic.age)<br><span class="hljs-built_in">print</span>(dic.socre)<br><span class="hljs-comment">--print(dic.2)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;不能通过数字&quot;</span>)<br><span class="hljs-built_in">print</span>(dic[<span class="hljs-number">2</span>])<br><span class="hljs-comment">--改 都是适用dic[键名]的</span><br>dic.age=<span class="hljs-number">20</span>;<br><span class="hljs-built_in">print</span>(dic.age)<br><span class="hljs-comment">--增</span><br>dic.sex=<span class="hljs-literal">false</span>;<br><span class="hljs-built_in">print</span>(dic.sex)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;******字典的遍历**********&quot;</span>)<br><br><span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(dic) <span class="hljs-keyword">do</span><br>    <span class="hljs-comment">--可以传N个参数</span><br>    <span class="hljs-built_in">print</span>(i,v)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(dic) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(dic[i])<br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;***********类和结构体*************&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;***********lua里没有类的概念，需要自己实现*************&quot;</span>)<br><span class="hljs-comment">--lua没有面对对象的，需要我们自己去实现</span><br><span class="hljs-comment">--类也是一个表,利用表的概念去实现一个类</span><br>Student=&#123;<br>    <span class="hljs-comment">--变量</span><br>    age=<span class="hljs-number">1</span>,<br>    sex=<span class="hljs-literal">true</span>,<br>    up=<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>        <span class="hljs-comment">--Lua中不能这样访问变量 这样写是一个全局的变量，值会为nil</span><br>        <span class="hljs-comment">--print(age)</span><br>        <span class="hljs-comment">--想要在表内部函数中，调用表本身的方法或者属性</span><br>        <span class="hljs-comment">--一定要指定是谁的，所以 表名.属性</span><br>        <span class="hljs-built_in">print</span>(Student.age)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我成长了&quot;</span>)<br>    <span class="hljs-keyword">end</span>,<br>    <span class="hljs-comment">--函数</span><br>    eat=<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我吃饭了&quot;</span>)<br>    <span class="hljs-keyword">end</span><br>&#125;<br><span class="hljs-comment">--声明表后，在表外添加变量和方法</span><br>Student.name=<span class="hljs-string">&quot;heart&quot;</span><br>Student.Learn=<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(t)</span></span><br>    <span class="hljs-built_in">print</span>(t.sex)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我学习了&quot;</span>)<br><span class="hljs-keyword">end</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student.goSchool</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;去学校了&quot;</span>)<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">--C#中使用类需要实例化new 或者静态直接点</span><br><span class="hljs-comment">--lua这中的表现形式更加像是很多个静态类</span><br><span class="hljs-built_in">print</span>(Student.age)<br>Student.up()<br><span class="hljs-built_in">print</span>(Student.name)<br>Student.Learn(Student) <span class="hljs-comment">--第二种使用变量的方法</span><br><span class="hljs-comment">--Lua中点和冒号的区别</span><br><span class="hljs-comment">--冒号调用方法会默认把调用者作为第一个参数，传入方法中</span><br>Student:Learn()<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student:Run</span><span class="hljs-params">()</span></span><br>    <span class="hljs-comment">--Lua中有一个关键字self 表示默认传入的第一个参数</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">self</span>.name..<span class="hljs-string">&quot;跑&quot;</span>)<br><span class="hljs-keyword">end</span><br>Student.goSchool()<br>Student:Run()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;***********表的公共操作*************&quot;</span>)<br><span class="hljs-comment">--table中提供了一些公共操作方法</span><br>t1=&#123;&#123;age=<span class="hljs-number">1</span>,name=<span class="hljs-string">&quot;heart&quot;</span>&#125;,&#123;age=<span class="hljs-number">2</span>,name=<span class="hljs-string">&quot;easily&quot;</span>&#125;&#125;<br>t2=&#123;name=<span class="hljs-string">&quot;heart&quot;</span>,sex=<span class="hljs-literal">true</span>&#125;<br><span class="hljs-comment">--插入</span><br><span class="hljs-built_in">print</span>(#t1)<br><span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(t1,t2);<br><span class="hljs-built_in">print</span>(#t1)<br><span class="hljs-built_in">print</span>(t1[<span class="hljs-number">3</span>].name)<br><br><span class="hljs-comment">--删除指定元素</span><br><span class="hljs-comment">--会移除最后一个索引的内容</span><br><span class="hljs-built_in">table</span>.<span class="hljs-built_in">remove</span>(t1)<br><span class="hljs-built_in">print</span>(#t1)<br><span class="hljs-built_in">print</span>(t1[<span class="hljs-number">1</span>].name)<br><span class="hljs-built_in">print</span>(t1[<span class="hljs-number">2</span>].name)<br><span class="hljs-comment">--移除内容的指定位置</span><br><span class="hljs-built_in">table</span>.<span class="hljs-built_in">remove</span>(t1,<span class="hljs-number">1</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;升序&quot;</span>)<br>t3=&#123;<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;<br><span class="hljs-built_in">table</span>.<span class="hljs-built_in">sort</span>(t3)<br><span class="hljs-keyword">for</span> _, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(t3) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(v)<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">--降序</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;降序&quot;</span>)<br>t4=&#123;<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;<br><span class="hljs-comment">--第二个参数是排序的规则</span><br><span class="hljs-built_in">table</span>.<span class="hljs-built_in">sort</span>(t4,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span></span><br>    <span class="hljs-keyword">if</span> a&gt;b  <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span>)<br><span class="hljs-keyword">for</span> _, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(t4) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(v)<br><span class="hljs-keyword">end</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;拼接&quot;</span>)<br>tb=&#123;<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-string">&quot;456&quot;</span>,<span class="hljs-string">&quot;789&quot;</span>&#125;<br><span class="hljs-comment">--拼接函数 返回值为字符串</span><br>str=<span class="hljs-built_in">table</span>.<span class="hljs-built_in">concat</span>(tb,<span class="hljs-string">&quot;;&quot;</span>)<br><span class="hljs-built_in">print</span>(str)<br></code></pre></td></tr></table></figure><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><ul><li>算术运算符 +（加法）、-（减法）、*（乘法）、／（除法）、^（指数）、%（取模）、-（负号）</li><li>关系操作符  &lt;  &gt;  &lt;&#x3D;  &gt;&#x3D;  &#x3D;&#x3D;   ~&#x3D;(不等于) 这些结果返回的都是true或者false</li><li>逻辑操作符 and(逻辑与)  or(逻辑或)  not</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs lua"> <span class="hljs-comment">--与条件控制语句一样，所有的逻辑操作符将false和nil视为假，而将其他的任何东西视为真。</span><br><br> <span class="hljs-comment">--对于操作符and来说，如果它的第一个操作数为假，就返回第一个操作数；不然返回第二个操作数。</span><br><br> <span class="hljs-comment">--对于操作符or来说，如果它的第一个操作数为真，就返回第一个操作数；不然返回第二个操作数。</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-number">4</span> <span class="hljs-keyword">and</span> <span class="hljs-number">5</span>)        <span class="hljs-comment">--&gt; 5</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-literal">nil</span> <span class="hljs-keyword">and</span> <span class="hljs-number">13</span>)     <span class="hljs-comment">--&gt; nil</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-literal">false</span> <span class="hljs-keyword">and</span> <span class="hljs-number">13</span>)   <span class="hljs-comment">--&gt; false</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-number">4</span> <span class="hljs-keyword">or</span> <span class="hljs-number">5</span>)         <span class="hljs-comment">--&gt; 4</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-literal">false</span> <span class="hljs-keyword">or</span> <span class="hljs-number">5</span>)     <span class="hljs-comment">--&gt; 5</span><br>  <br><span class="hljs-comment">--and和or都是用“短路求值”，也就是说，它们只会在需要时才去评估第二个操作数。</span><br>  <span class="hljs-comment">--短路求值可以确保像（type(v)==&quot;table&quot; and v.tag == &quot;h1&quot;）这样的表达式不会导致运行时错误。</span><br><br> <span class="hljs-comment">-- 有一种常用的Lua习惯写法“x = x or v”，它等价于：</span><br>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> x <span class="hljs-keyword">then</span> x = v <span class="hljs-keyword">end</span><br><br> <span class="hljs-comment">-- 另外，还有一种习惯写法是“（a and b）or c”，这等价于表达式a?b:c，但前提是b不为假。</span><br> <span class="hljs-comment">--三目运算符</span><br> <span class="hljs-comment">--例如，为了选出数字x和y中的较大者，可以使用以下语句：</span><br>  <span class="hljs-built_in">max</span> = (x &gt; y) <span class="hljs-keyword">and</span> x <span class="hljs-keyword">or</span> y<br> <span class="hljs-comment">-- 操作符not永远只返回true或false：</span><br>      <span class="hljs-built_in">print</span>(<span class="hljs-keyword">not</span> <span class="hljs-literal">nil</span>)        <span class="hljs-comment">--&gt; true</span><br>      <span class="hljs-built_in">print</span>(<span class="hljs-keyword">not</span> <span class="hljs-literal">false</span>)      <span class="hljs-comment">--&gt; true</span><br>      <span class="hljs-built_in">print</span>(<span class="hljs-keyword">not</span> <span class="hljs-number">0</span>)          <span class="hljs-comment">--&gt; false</span><br>      <span class="hljs-built_in">print</span>(<span class="hljs-keyword">not</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">nil</span>)    <span class="hljs-comment">--&gt; false</span><br></code></pre></td></tr></table></figure><h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><p>Lua的常规语句和C语言差不多 同时也有一些不太常见的语句 如 多重赋值，和局部变量声明</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">a = <span class="hljs-string">&quot;hello&quot;</span> .. <span class="hljs-string">&quot;world&quot;</span><br>t = &#123; n = <span class="hljs-number">0</span> &#125;<br>t.n = t.n + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>  Lua允许“多重赋值”，也就是一下子将多个值赋予多个变量。每个值或每个变量之间以逗号分隔。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">a, b = <span class="hljs-number">10</span>, <span class="hljs-number">2</span>*x    <span class="hljs-comment">-- a为10，b为2*x</span><br></code></pre></td></tr></table></figure><p>  在多重赋值中，Lua先对等号右边的所有元素求值，然后才执行赋值。这样便可以用一句多重赋值来交互两个变量了。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">x, y = y, x                    <span class="hljs-comment">-- 交换x与x</span><br>a[i], a[j] = a[j], a[i]        <span class="hljs-comment">-- 交换a[i]与a[j]</span><br></code></pre></td></tr></table></figure><p>相对于全局变量 lua的局部变量用 <code>local</code>语句来创建</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">do</span><br>        <span class="hljs-keyword">local</span> a = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">local</span> b = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">end</span>            <span class="hljs-comment">-- a和b的作用域至此结束 do end</span><br></code></pre></td></tr></table></figure><p>Lua提供了一组传统的、小巧的控制结构，包括用于条件执行的<code>if</code>，用于迭代的<code>while</code>、<code>repeat</code>和<code>for</code>。所有的控制结构都有一个显式的终止符：<code>if</code>、<code>for</code>和<code>while</code>以<code>end</code>作为结尾，<code>repeat</code>以<code>until</code>作为结尾。控制结构中的条件表达式可以是任何值，Lua将所有不是<code>false</code>和<code>nil</code>的值视为“真”</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;******循环语句*****&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;******while循环语句*****&quot;</span>)<br>x = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> x &lt; <span class="hljs-number">10</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(x)<br>    x = x + <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;******do while循环 也就是repeat*****&quot;</span>)  <span class="hljs-comment">--</span><br>y = <span class="hljs-number">0</span><br><span class="hljs-keyword">repeat</span><br>    <span class="hljs-built_in">print</span>(y)<br>    y = y + <span class="hljs-number">1</span><br><span class="hljs-keyword">until</span> y &gt; <span class="hljs-number">5</span>   <span class="hljs-comment">--满足条件退出</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;lua中的do whlie 和C# 不一样 用repeat until 同时条件是退出条件不是进入条件&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;******for循环语句*****&quot;</span>)<br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">5</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(i)<br><span class="hljs-keyword">end</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;lua i 会默认自增&quot;</span>)<br><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">5</span>,<span class="hljs-number">2</span> <span class="hljs-keyword">do</span>  <span class="hljs-comment">--另外一个值是指定自增多少  自减的话 改成-1</span><br>    <span class="hljs-built_in">print</span>(i)<br><span class="hljs-keyword">end</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;自减&quot;</span>)<br><span class="hljs-keyword">for</span> i = <span class="hljs-number">10</span>, <span class="hljs-number">1</span>,<span class="hljs-number">-2</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(i)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;******增强for循环语句*****&quot;</span>)<br>arr=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;<br><span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(arr) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(v)<br><span class="hljs-keyword">end</span><br><br></code></pre></td></tr></table></figure><p><code>for</code>语句有两种形式：数字型<code>for</code>和泛型<code>for</code>。</p><h5 id="数字型-for"><a href="#数字型-for" class="headerlink" title="数字型 for"></a>数字型 for</h5><p>  <code>for</code>语句有两种形式：数字型<code>for</code>和泛型<code>for</code>。</p><p>  数字型<code>for</code>的语法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> var=exp1, exp2,exp3 <span class="hljs-keyword">do</span><br>    &lt;执行体&gt;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>  <code>var</code>从<code>exp1</code>变化到<code>exp2</code>，每次变化都以<code>exp3</code>作为步长（<code>step</code>）递增<code>var</code>，并执行一次“执行体”。第三个表达式是可选的，若不指定的话，Lua会将步长默认为1。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>, f(x) <span class="hljs-keyword">do</span> <span class="hljs-built_in">print</span>(i) <span class="hljs-keyword">end</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span> <span class="hljs-keyword">do</span> <span class="hljs-built_in">print</span>(i) <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>  如果不想给循环设置上限的话，可以使用常量<code>math.huge</code>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>, <span class="hljs-built_in">math</span>.<span class="hljs-built_in">huge</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0.3</span>*i^<span class="hljs-number">3</span> - <span class="hljs-number">20</span>*i^<span class="hljs-number">2</span> - <span class="hljs-number">500</span> &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">print</span>(i)<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>  首先，<code>for</code>的3个表达式是在循环开始前一次性求值的。例如，上例中的<code>f(x)</code>只会执行一次。其次，控制变量会被自动地声明为<code>for</code>语句的局部变量，并且仅在循环体内可见。</p><h5 id="泛型for"><a href="#泛型for" class="headerlink" title="泛型for"></a>泛型for</h5><p>  泛型<code>for</code>循环通过一个迭代器函数来遍历所有值：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 打印数组a的所有值</span><br><span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(a) <span class="hljs-keyword">do</span> <span class="hljs-built_in">print</span>(v) <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>  Lua的基础库提供了<code>ipairs</code>，这是一个用于遍历数组的迭代器函数。在每次循环中，<code>i</code>会被赋予一个索引值，同时<code>v</code>被赋予一个对应于该索引的数组元素值。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 打印table t中所有的key</span><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(t) <span class="hljs-keyword">do</span> <span class="hljs-built_in">print</span>(k) <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><blockquote><p>  迭代table元素的（pairs）、迭代数组元素的（ipairs）、迭代字符串中单词的（string.gmatch）等。</p></blockquote><p>  </p><p>  <strong>泛型for循环与数字型for循环有两个相同点：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lua">循环变量是循环体的局部变量；<br>绝不应该对循环变量作任何赋值。<br><span class="hljs-comment">-- 例：</span><br><br>days = &#123;<span class="hljs-string">&quot;Sunday&quot;</span>, <span class="hljs-string">&quot;Monday&quot;</span>, <span class="hljs-string">&quot;Tuesday&quot;</span>, <span class="hljs-string">&quot;Wednesday&quot;</span>, <span class="hljs-string">&quot;Thursday&quot;</span>, <span class="hljs-string">&quot;Friday&quot;</span>, <span class="hljs-string">&quot;Saturday&quot;</span>&#125;<br><br><span class="hljs-comment">-- 需要创建如下talbe</span><br>revDays = &#123;[<span class="hljs-string">&quot;Sunday&quot;</span>] = <span class="hljs-number">1</span>, [<span class="hljs-string">&quot;Monday&quot;</span>] = <span class="hljs-number">2</span>, [<span class="hljs-string">&quot;Tuesday&quot;</span>] = <span class="hljs-number">3</span>, [<span class="hljs-string">&quot;Wednesday&quot;</span>] = <span class="hljs-number">4</span>, [<span class="hljs-string">&quot;Thursday&quot;</span>] = <span class="hljs-number">5</span>, [<span class="hljs-string">&quot;Friday&quot;</span>] = <span class="hljs-number">6</span>, [<span class="hljs-string">&quot;Saturday&quot;</span>] = <span class="hljs-number">7</span>&#125;<br><br><span class="hljs-comment">-- 则可以按如下实现</span><br>revDays = &#123;&#125;<br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(day) <span class="hljs-keyword">do</span><br>    revDays[v]<br></code></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><blockquote><p>Lua为面向对象式的调用也提供了一种特殊的语法—冒号操作符。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">o.foo(o, x)      <span class="hljs-comment">-- 另一种写法是 o::foo(x)</span><br></code></pre></td></tr></table></figure><p>  冒号操作符使调用<code>o.foo</code>时将<code>o</code>隐含地作为函数第一个参数。</p><p>Lua中函数不支持重载，默认调用最后一个函数 </p></blockquote><h5 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h5><p>调用函数时提供的实参数量可以与形參数量不同。Lua会自动调整实参的数量，以匹配参数表的要求。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 假设一个函数如下：</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(a, b)</span></span> <span class="hljs-keyword">return</span> a <span class="hljs-keyword">or</span> b <span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 在以下几种调用中，实参与形參的对应关系为：</span><br><span class="hljs-comment">-- 调用        形參</span><br>f(<span class="hljs-number">3</span>)          a=<span class="hljs-number">3</span>, b=<span class="hljs-literal">nil</span><br>f(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)       a=<span class="hljs-number">3</span>, b=<span class="hljs-number">4</span><br>f(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)    a=<span class="hljs-number">3</span>, b=<span class="hljs-number">4</span> (<span class="hljs-number">5</span>被丢弃了)<br><span class="hljs-comment">-- 默认实参的应用</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">incCount</span><span class="hljs-params">(n)</span></span><br>    n = n <span class="hljs-keyword">or</span> <span class="hljs-number">1</span><br>    count = count + n<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p> Lua允许函数返回多个结果。只需在<code>return</code>关键字后列出所有的返回值即可。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 查找数组中的最大元素，并返回该元素的位置：</span><br><br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maximum</span><span class="hljs-params">(a)</span></span><br>       <span class="hljs-keyword">local</span> index = <span class="hljs-number">1</span>         <span class="hljs-comment">-- 最大值的索引</span><br>       <span class="hljs-keyword">local</span> <span class="hljs-built_in">max</span> = a[index]    <span class="hljs-comment">-- 最大值</span><br>       <span class="hljs-keyword">for</span> i,val <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(a) <span class="hljs-keyword">do</span><br>           <span class="hljs-keyword">if</span> val &gt; <span class="hljs-built_in">max</span> <span class="hljs-keyword">then</span><br>               <span class="hljs-built_in">max</span> = val; index = i<br>           <span class="hljs-keyword">end</span><br>       <span class="hljs-keyword">end</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>, index<br>   <span class="hljs-keyword">end</span><br><br>   <span class="hljs-built_in">print</span>(maximum&#123;<span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">23</span>, <span class="hljs-number">12</span>, <span class="hljs-number">5</span>&#125;)    <span class="hljs-comment">--&gt; 23   3</span><br></code></pre></td></tr></table></figure><p> Lua会调整一个函数的返回值数量以适应不同的调用情况。若将函数调用作为一条单独语句时，Lua会丢弃函数的所有返回值。<strong>如果你传入的参数，和函数个数不匹配，不会报错，但会补nil或者丢弃</strong>，若将函数作为表达式的一部分来调用时，Lua只保留函数的第一个返回值。<strong>只有当一个函数调用是一系列表达式中的最后一个元素（或仅有一个元素）时，才能获得它的所有返回值。</strong> </p><h5 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h5><p>Lua中的函数可以接受不同数量的实参。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 这个函数返回了所有参数的总和：</span><br><br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span><span class="hljs-params">( ... )</span></span><br>       <span class="hljs-keyword">local</span> s = <span class="hljs-number">0</span><br>       <span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>( ... ) <span class="hljs-keyword">do</span>  <span class="hljs-comment">-- 表达式&#123;...&#125;表示一个由所有变长参数构成的数组。</span><br>           s = s + v<br>       <span class="hljs-keyword">end</span><br>       <span class="hljs-keyword">return</span> s<br>   <span class="hljs-keyword">end</span><br><br>   <span class="hljs-built_in">print</span>(add(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>, <span class="hljs-number">25</span>, <span class="hljs-number">12</span>))        <span class="hljs-comment">--&gt; 54</span><br></code></pre></td></tr></table></figure><p> 参数中的3个点（<code>...</code>）表示该函数可接受不同数量的实参。    </p><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><p>若将一个函数写在另一个函数之内，那么这个位于内部的函数便可以访问外部函数中的局部变量，这项特征称之为“词法域”。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pack1</span><span class="hljs-params">(x)</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(y)</span></span><br>        <span class="hljs-keyword">return</span> x+y<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--闭包机制改变了传入参数的生命周期</span><br>p=pack1(<span class="hljs-number">10</span>)<br>P= p(<span class="hljs-number">5</span>) <br><span class="hljs-built_in">print</span>(P)  <span class="hljs-comment">--&gt; 15  x的值为10 y为5</span><br></code></pre></td></tr></table></figure><h5 id="函数的嵌套"><a href="#函数的嵌套" class="headerlink" title="函数的嵌套"></a>函数的嵌套</h5><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F8</span><span class="hljs-params">()</span></span><br>    F9=<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-number">123</span>)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> F9<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F10</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-number">456</span>)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br>f9=F8()<br>f9() <span class="hljs-comment">--&gt;123</span><br>f10= F10()<br>f10() <span class="hljs-comment">--456</span><br></code></pre></td></tr></table></figure><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><blockquote><p>Lua将所有关于协同程序的函数放置在一个名为“<code>coroutine</code>”的<code>table</code>中。</p></blockquote><p>函数<code>create</code>用于创建新的协同程序，它只有一个参数，就是一个函数。该函数的代码就是协同程序所需执行的内容。<code>create</code>会返回一个<code>thread</code>类型的值，用以表示新的协同程序。通常<code>create</code>的参数是一个匿名函数。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua">    co = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span>( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span> <span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;hi&quot;</span> ) <span class="hljs-keyword">end</span> )<br>    <span class="hljs-built_in">print</span>( co )    <span class="hljs-comment">-- thread: 0x7fe2f1506218</span><br><span class="hljs-comment">--一个协程有四种状态</span><br><span class="hljs-comment">--coroutine.status(协程对象)</span><br><span class="hljs-comment">--dead 结束</span><br><span class="hljs-comment">--suspended 暂停</span><br><span class="hljs-comment">--running 进行中</span><br><span class="hljs-comment">--通过 print( coroutine.status( co ) )来检查状态</span><br></code></pre></td></tr></table></figure><p>函数<code>coroutine.resume</code>用于启动或再次启动一个协同程序的执行，并将其状态由挂起改为运行：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>( co )             <span class="hljs-comment">-- hi</span><br></code></pre></td></tr></table></figure><p>在运行后协程变终止了 处于<code>dead</code>状态</p><p>协程的本质是一个线程对象</p><p>到目前为止，协同程序看上去还只是像一种复杂的函数调用方法。其实协同程序的真正强大之处在于函数<code>yield</code>的使用上，该函数可以让一个运行中的协同程序挂起，而之后可以再恢复它的运行。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua">co = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span>( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span> <span class="hljs-keyword">do</span><br>        <span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;co&quot;</span>, i )<br>        <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">yield</span>()<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span> )<br></code></pre></td></tr></table></figure><p>  现在当唤醒这个协同程序时，它就会开始执行，直到第一个<code>yield</code>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>( co )    <span class="hljs-comment">-- co 1</span><br></code></pre></td></tr></table></figure><p>  如果此时检查其状态，会发现协同程序处于挂起状态，因此可以再次恢复其运行：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>( <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">status</span>( co ) )    <span class="hljs-comment">-- suspended</span><br></code></pre></td></tr></table></figure><p>  从协同程序的角度看，所有在它挂起时发生的活动都发生在<code>yield</code>调用中。当恢复协同程序的执行时，对于<code>yield</code>的调用才最终返回。然后协同程序继续它的执行，直到下一个<code>yield</code>调用或执行结束：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>( co )    <span class="hljs-comment">-- co 2</span><br><span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>( co )    <span class="hljs-comment">-- co 3</span><br>...<br><span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>( co )    <span class="hljs-comment">-- co 10</span><br><span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>( co )    <span class="hljs-comment">-- 什么都不打印</span><br></code></pre></td></tr></table></figure><p>  在最后一次调用<code>resume</code>时，协同程序的内容已经执行完毕，并已经返回。因此，这时协同程序处于死亡状态。如果试图再次恢复它的执行，<code>resume</code>将返回<code>false</code>及一条错误消息：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>( co ))    <span class="hljs-comment">-- false cannot resume dead coroutine</span><br></code></pre></td></tr></table></figure><blockquote><p>请注意，<code>resume</code>是在保护模式中运行的。因此，如果在一个协同程序的执行中发生任何错误，Lua是不会显示错误消息的，而是将执行权返回给<code>resume</code>调用。</p></blockquote><p><strong>Lua的协同程序还具有一项有用的机制，就是可以通过一对<code>resume-yield</code>来交换数据。</strong>在第一次调用<code>resume</code>时，并没有对应的<code>yield</code>在等待它，因此所有传递给<code>resume</code>的额外参数都将视为协同程序主函数的参数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">co = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span>( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( a, b, c )</span></span><br>    <span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;co&quot;</span>, a, b, c )<br><span class="hljs-keyword">end</span> )<br><span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>( co, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> )    <span class="hljs-comment">-- co 1 2 3</span><br></code></pre></td></tr></table></figure><p>  在<code>resume</code>调用返回的内容中，第一个值为<code>true</code>则表示没有错误，而后面所有的值都是对应<code>yield</code>传入的参数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">co = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span>( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( a, b )</span></span><br>    <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">yield</span>( a + b, a - b )<br><span class="hljs-keyword">end</span> )<br><br><span class="hljs-built_in">print</span>( <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>( co, <span class="hljs-number">20</span>, <span class="hljs-number">10</span> ) )    <span class="hljs-comment">-- true 30 10</span><br></code></pre></td></tr></table></figure><p>  与此对应的是，<code>yield</code>返回的额外值就是对应<code>resume</code>传入的参数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua">co = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span>( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;co&quot;</span>, <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">yield</span>() )<br><span class="hljs-keyword">end</span> )<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>( co, <span class="hljs-string">&quot;a&quot;</span> ))      <span class="hljs-comment">-- true</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>( co, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> ))  <span class="hljs-comment">-- co 4 5 6  -- true</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>( co, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>))      <span class="hljs-comment">-- false cannot resume dead coroutine</span><br></code></pre></td></tr></table></figure><p>  最后，当一个协同程序结束时，它的主函数所返回的值都将作为对应<code>resume</code>的返回值：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">co = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span>( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>, <span class="hljs-number">7</span><br><span class="hljs-keyword">end</span> )<br><span class="hljs-built_in">print</span>( <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>( co ) )        <span class="hljs-comment">-- true 6 7</span><br></code></pre></td></tr></table></figure><h4 id="元表"><a href="#元表" class="headerlink" title="元表"></a>元表</h4><p>任何表变量都可以作为另一个表变量的元素，任何表变量都可以有自己的元表，当我们子表进行一些特定操作时，会执行元表中的内容</p><p>可以通过元表来修改一个值的行为，使其在面对一个非预定义的操作时执行一个指定的操作。例如，假设a和b都是table，通过元表可以定义如何计算表达式a+b。当Lua试图将两个table相加时，它会先检查两者之一是否有元表，然后检查该元表中是否有一个叫__add的字段。如果Lua找到了该字段，就调用该字段对应的值。这个值也就是所谓的“元方法”</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">meta = &#123;&#125;<br>myTable = &#123;&#125;<br><span class="hljs-comment">--设置元表函数 第一个是字表 第二个是元表</span><br><span class="hljs-built_in">setmetatable</span>(myTable, meta)<br></code></pre></td></tr></table></figure><p>tostring操作</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua">meta2 = &#123;<br>    <span class="hljs-comment">--当字表要被当做字符串使用时，会默认调用元表中的tostring方法</span><br>    <span class="hljs-built_in">__tostring</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(t)</span></span><br>        <span class="hljs-keyword">return</span> t.name<br>    <span class="hljs-keyword">end</span><br>&#125;<br>myTable2 = &#123;<br>    name = <span class="hljs-string">&quot;Heart&quot;</span><br>&#125;<br><span class="hljs-built_in">setmetatable</span>(myTable2, meta2)<br><span class="hljs-built_in">print</span>(myTable2) <span class="hljs-comment">--&gt; Heart</span><br></code></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;***********特定操作_ Call************&quot;</span>)<br>meta3 = &#123;<br>    <span class="hljs-comment">--当字表要被当做字符串使用时，会默认调用元表中的tostring方法</span><br>    <span class="hljs-built_in">__tostring</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(t)</span></span><br>        <span class="hljs-keyword">return</span> t.name<br>    <span class="hljs-keyword">end</span>,<br><br>    <span class="hljs-comment">--当字表当做一个函数使用时，会默认调用__call里的内容</span><br>    <span class="hljs-comment">--当希望传入参数时，默认第一个参数是调用者自己</span><br>    <span class="hljs-built_in">__call</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(t, b)</span></span><br>        <span class="hljs-built_in">print</span>(b)<br>        <span class="hljs-built_in">print</span>(t.name .. <span class="hljs-string">&quot; 在call你&quot;</span>)<br>    <span class="hljs-keyword">end</span><br>&#125;<br>myTable3 = &#123;<br>    name = <span class="hljs-string">&quot;Heart&quot;</span><br>&#125;<br><br><span class="hljs-built_in">setmetatable</span>(myTable3, meta3)<br><span class="hljs-comment">--第一个参数是本身，第二个参数才是传入的值</span><br>myTable3(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;***********特定操作_ 运算符重载************&quot;</span>)<br>meta4 = &#123;<br>    <span class="hljs-comment">--相当于运算符重载，当字表调用+运算符时，会调用该方法</span><br>    <span class="hljs-comment">--运算符+</span><br>    <span class="hljs-built_in">__add</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(t1, t2)</span></span><br>        <span class="hljs-keyword">return</span> t1.age + t2.age<br>    <span class="hljs-keyword">end</span>,<br><br>    <span class="hljs-comment">--运算符-</span><br>    <span class="hljs-built_in">__sub</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(t1, t2)</span></span><br>        <span class="hljs-keyword">return</span> t1.age - t2.age<br>    <span class="hljs-keyword">end</span>,<br>    <span class="hljs-comment">--运算符*</span><br>    <span class="hljs-built_in">__mul</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(t1, t2)</span></span><br>        <span class="hljs-keyword">return</span> t1.age * t2.age<br>    <span class="hljs-keyword">end</span>,<br>    <span class="hljs-comment">--运算符/</span><br>    <span class="hljs-built_in">__div</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(t1, t2)</span></span><br>        <span class="hljs-keyword">return</span> t1.age / t2.age<br>    <span class="hljs-keyword">end</span>,<br>    <span class="hljs-comment">--运算符%</span><br>    <span class="hljs-built_in">__mod</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">end</span>,<br>    <span class="hljs-comment">--运算符^</span><br>    <span class="hljs-built_in">__pow</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">end</span>,<br>    <span class="hljs-comment">--运算符==</span><br>    <span class="hljs-built_in">__eq</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">end</span>,<br>    <span class="hljs-comment">--运算符&lt;</span><br>    <span class="hljs-built_in">__lt</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">end</span>,<br>    <span class="hljs-comment">--运算符&lt;=</span><br>    <span class="hljs-built_in">__le</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(t1, t2)</span></span><br>        <span class="hljs-keyword">return</span> t1.age &lt;= t2.age<br>    <span class="hljs-keyword">end</span>,<br>    <span class="hljs-comment">--运算符 .. 拼接</span><br>    <span class="hljs-built_in">__concat</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(t1, t2)</span></span><br>        <span class="hljs-keyword">return</span> t1.age .. t2.age<br>    <span class="hljs-keyword">end</span><br>&#125;<br>myTable4 = &#123;<br>    age = <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-built_in">setmetatable</span>(myTable4, meta4)<br>myTable5 = &#123;<br>    age = <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-built_in">setmetatable</span>(myTable5, meta4)<br><br><span class="hljs-comment">--如果要用条件运算符，来比较两个对象</span><br><span class="hljs-comment">--这两个对象的元表一定要一致 才能准确调用</span><br><span class="hljs-built_in">print</span>(myTable4 + myTable5) <span class="hljs-comment">--2</span><br><span class="hljs-built_in">print</span>(myTable4 .. myTable5) <span class="hljs-comment">-- 02</span><br><span class="hljs-built_in">print</span>(myTable4 &lt;= myTable5) <span class="hljs-comment">--true</span><br></code></pre></td></tr></table></figure><h5 id="table访问的元方法"><a href="#table访问的元方法" class="headerlink" title="table访问的元方法"></a>table访问的元方法</h5><p>  算术类和关系类元算符的元方法都为各种错误情况定义了行为，它们不会改变语言的常规行为。但是Lua还提供了一种可以改变table行为的方法。有两种可以改变的table行为：查询table及修改table中不存在的字段。</p><h6 id="index元方法"><a href="#index元方法" class="headerlink" title="__index元方法"></a>__index元方法</h6><p>当访问一个table中不存在的字段时，得到的结果为nil。这是对的，但并非完全正确。实际上，这些访问会促使解释器去查找一个叫__index的元方法。如果没有这个元方法，那么访问结果如前述的为nil。否则，就由这个元方法来提供最终结果。</p><p>  下面将介绍一个有关继承的典型示例。假设要创建一些描述窗口的table，每个table中必须描述一些窗口参数，例如位置、大小及主题颜色等。所有这些参数都有默认值，因此希望在创建窗口对象时可以仅指定那些不同于默认值的参数。第一种方法是使用一个构造式，在其中填写那些不存在的字段。第二种方法是让新窗口从一个原型窗口处继承所有不存在的字段。首先，声明一个原型和一个构造函数，构造函数创建新的窗口，并使它们共享同一个元表：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua">Window = &#123;&#125;         <span class="hljs-comment">-- 创建一个名字空间</span><br><span class="hljs-comment">-- 使用默认值来创建一个原型</span><br>Window.prototype = &#123;x=<span class="hljs-number">0</span>, y=<span class="hljs-number">0</span>, width=<span class="hljs-number">100</span>, height=<span class="hljs-number">100</span>&#125;<br>Window.mt = &#123;&#125;         <span class="hljs-comment">-- 创建元表</span><br><span class="hljs-comment">-- 声明构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Window.new</span><span class="hljs-params">(o)</span></span><br>    <span class="hljs-built_in">setmetatable</span>(o, Window.mt)<br>    <span class="hljs-keyword">return</span> o<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>  现在，来定义<code>__index</code>元方法：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">Window.mt.<span class="hljs-built_in">__index</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(table, key)</span></span><br>    <span class="hljs-keyword">return</span> Window.prototype[key]<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>  在这段代码之后，创建一个新窗口，并查询一个它没有的字段：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">w = Window.new&#123;x=<span class="hljs-number">10</span>, y=<span class="hljs-number">20</span>&#125;<br><span class="hljs-built_in">print</span>(w.width)            <span class="hljs-comment">--&gt; 100</span><br></code></pre></td></tr></table></figure><p>  若Lua检测到<code>w</code>中没有某字段，但在其元表中却有一个<code>__index</code>字段，那么Lua就会以<code>w(table)</code>和“<code>width</code>”（不存在的key）来调用这个<code>__index</code>元方法。随后元方法用这个key来索引原型table，并返回结果。</p><p>  在Lua中，将<code>__index</code>元方法用于继承是很普通的方法，因此Lua还提供了一种更便捷的方式来实现此功能。<code>__index</code>元方法不必一定是一个函数，它还可以是一个table。当它是一个函数时，Lua以table和不存在的key作为参数来调用该函数，这就如同上述内容。而当它是一个table时，Lua就以相同的方式来重新访问这个table。因此，前例中<code>__index</code>的声明可以简单地写为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">Window.mt.<span class="hljs-built_in">__index</span> = Window.prototype<br></code></pre></td></tr></table></figure><p>  现在，当Lua查找到元表的<code>__index</code>字段时，发现<code>__index</code>字段的值是一个table，那么Lua就会在Window.prototype中继续查找。也就是说，Lua会在这个table中重复这个访问过程，类似于执行这样的代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">Window.prototype[<span class="hljs-string">&quot;width&quot;</span>]<br></code></pre></td></tr></table></figure><p>  然后由这次访问给出想要的结果。</p><p>  将一个table作为<code>__index</code>元方法是一种快捷的、实现单一继承的方式。虽然将函数作为<code>__index</code>来实现相同功能的开销较大，但函数更加灵活。可以通过函数来实现多重继承、缓存及其他一些功能。</p><p>  如果不想在访问一个table时涉及到它的<code>__index</code>元方法，可以使用函数<code>rawget</code>。调用<code>rawget(t, i)</code>就是对table t进行了一个“原始的(raw)”访问，也就是一次不考虑元表的简单访问。一次原始访问并不会加速代码执行，但有时会用到它。</p><h6 id="newindex元方法"><a href="#newindex元方法" class="headerlink" title="__newindex元方法"></a>__newindex元方法</h6><p>  <strong><code>__newindex</code>元方法与<code>__index</code>类似，不同之处在于前者用于table的更新，而后者用于table的查询</strong>。当对一个table中不存在的索引赋值时，解释器就会查找<code>__newindex</code>元方法。如果有这个元方法，解释器就调用它，而不是执行赋值。如果这个元方法是一个table，解释器就在此table中执行赋值，而不是对原来的table。此外，还有一个原始函数允许绕过元方法：调用<code>rawset(t,k,v)</code>就可以不涉及任何元方法而直接设置table t中与key k相关联的value v。</p><p>  组合使用<code>__index</code>和<code>__newindex</code>元方法就可以实现出Lua中的一些强大功能，例如，只读的table、具有默认值的table和面向对象编程中的继承。</p><h4 id="面对对象编程"><a href="#面对对象编程" class="headerlink" title="面对对象编程"></a>面对对象编程</h4><p>Lua的面对对象编程需要我们自己去实现</p><p> Lua中的<code>table</code>就是一种对象，这句话可以从3个方面来证实。首先，<code>table</code>与对象一样可以拥有状态。其次，<code>table</code>也与对象一样拥有一个独立于其值的标识（一个<code>self</code>）。例如，两个具有相同值的对象（<code>table</code>）是两个不同的对象。最后，<code>table</code>与对象一样具有独立于创建者和创建地的生命周期。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">Account = &#123;balance = <span class="hljs-number">0</span>&#125;<br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Account.withdraw</span><span class="hljs-params">(v)</span></span><br>       Account.balance = Account.balance - v<br>   <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>  上面的代码创建了一个新函数，并将该函数存入<code>Account</code>对象的<code>withdraw</code>字段中。则可进行如下调用：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">Account.withdraw(<span class="hljs-number">100.00</span>)<br></code></pre></td></tr></table></figure><p>但这个函数只能针对特定对对象工作，这个特定对象还必须存储在特定的全局变量中。如果改变了对象的名称，<code>withdraw</code>就再也不能工作了：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">a = Account;Account = <span class="hljs-literal">nil</span><br>a.withdraw(<span class="hljs-number">100.00</span>)        <span class="hljs-comment">-- 错误！❌</span><br></code></pre></td></tr></table></figure><p>这种行为违法了对象的特性，为此Lua提供了一个额外的参数来表示接受者，这个参数是 <code>self</code>或<code>this</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Account.withdraw</span><span class="hljs-params">(self, v)</span></span><br>        <span class="hljs-built_in">self</span>.balance = <span class="hljs-built_in">self</span>.balance - v<br>    <span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--此时当调用该方法时，必须指定其作用的对象：</span><br><br>    a1 = Account; Account = <span class="hljs-literal">nil</span><br>    ...<br>    a1.withdraw(a1, <span class="hljs-number">100.00</span>)        <span class="hljs-comment">-- OK</span><br><br></code></pre></td></tr></table></figure><p>通过对<code>self</code>参数的使用还可以针对多个对象使用同样的方法</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"> a2 = &#123;balance=<span class="hljs-number">0</span>, withdraw=Account.withdraw&#125;<br>    ...<br>    a2.withdraw(a2, <span class="hljs-number">260.00</span>)<br><span class="hljs-comment">--使用self参数是所有面向对象语言的一个核心。大多数面向对象语言都能对程序员隐藏部分self参数，从而使得程序员不必显式地声明这个参数。Lua只需使用冒号，则能隐藏该参数。即可将上例重写为：</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Account:withdraw</span><span class="hljs-params">(v)</span></span><br>        <span class="hljs-built_in">self</span>.balance = <span class="hljs-built_in">self</span>.balance - v<br>    <span class="hljs-keyword">end</span><br> <span class="hljs-comment">--调用时可写为：</span><br><br>    a:withdraw(<span class="hljs-number">100.00</span>)<br></code></pre></td></tr></table></figure><blockquote><p>冒号的作用是在一个方法定义中添加一个额外的隐藏参数，以及在一个方法调用中添加一个额外的实参。冒号只是一种语法便利，并没有引入任何新的东西</p></blockquote><h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><p>要在Lua中模拟类并不困难，例实现一个Object类</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua">Object=&#123;&#125;<br><span class="hljs-comment">--实例化</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Object:new</span><span class="hljs-params">(obj)</span></span><br>    <span class="hljs-keyword">local</span> obj= obj <span class="hljs-keyword">or</span> &#123;&#125; <span class="hljs-comment">--如果用户满意提供table，则创建一个</span><br>    <span class="hljs-built_in">self</span>.<span class="hljs-built_in">__index</span>=<span class="hljs-built_in">self</span><br>    <span class="hljs-comment">--给对象设置元表 以及index</span><br>    <span class="hljs-built_in">setmetatable</span>(obj,<span class="hljs-built_in">self</span>)<br>    <span class="hljs-keyword">return</span> obj<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>当调用new时，self就等于Object  当创建新对象时，obj会将Object作为元表</p><p>ps ：注意<code>self</code>的作用</p><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs lua">Object = &#123; &#125;<br>Object.id=<span class="hljs-number">1</span><br>Object.name=<span class="hljs-string">&quot;Heart&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Object:Test</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">self</span>.name..<span class="hljs-string">&quot;封装测试&quot;</span>) <span class="hljs-comment">--Heart封装测试</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">--冒号 会自动将调用这个函数的对象 作为第一个参数传入的写法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Object:new</span><span class="hljs-params">()</span></span><br>    <span class="hljs-comment">--self 代表传入的默认第一个参数</span><br>    <span class="hljs-comment">--对象就是新的变量 返回一个新的变量</span><br>    <span class="hljs-comment">--返回出去的内容 本质上就是表对象</span><br>    <span class="hljs-keyword">local</span> obj = &#123;&#125;<br>    <span class="hljs-comment">--结合元表知识 index  当找自己的变量 找不到时 就会去元表中找 index指向的内容</span><br>    <span class="hljs-built_in">self</span>.<span class="hljs-built_in">__index</span> = <span class="hljs-built_in">self</span><br>    <span class="hljs-built_in">setmetatable</span>(obj, <span class="hljs-built_in">self</span>)<br>    <span class="hljs-keyword">return</span> obj<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">--local myobj=Object:new()</span><br><span class="hljs-comment">--print(myobj.id)--这样是无法new出来的 我们要结合元表的知识</span><br><span class="hljs-keyword">local</span> myobj = Object:new()<br><span class="hljs-built_in">print</span>(myobj)<br><span class="hljs-built_in">print</span>(myobj.id) <span class="hljs-comment">--1</span><br>myobj:Test()<span class="hljs-comment">--注意调用形式</span><br><span class="hljs-comment">--ps 注意</span><br>myobj.id=<span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(Object.id)<span class="hljs-comment">--还会是1 因为myobj是空表 他的声明一个新的属性为id</span><br></code></pre></td></tr></table></figure><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>由于类也是对象，他们可以从其他类获得方法，这种行为就是一种继承。</p><p>假设有一个基类<code>Account</code>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lua">Account = &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Account:new</span><span class="hljs-params">(o)</span></span><br>    o = o <span class="hljs-keyword">or</span> &#123;&#125;<br>    <span class="hljs-built_in">setmetatable</span>(o, <span class="hljs-built_in">self</span>)<br>    <span class="hljs-built_in">self</span>.<span class="hljs-built_in">__index</span> = <span class="hljs-built_in">self</span><br>    <span class="hljs-keyword">return</span> o<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Account:deposit</span><span class="hljs-params">(v)</span></span><br>    <span class="hljs-built_in">self</span>.balance = <span class="hljs-built_in">self</span>.balance + v<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Account:withdraw</span><span class="hljs-params">(v)</span></span><br>    <span class="hljs-keyword">if</span> v &gt; <span class="hljs-built_in">self</span>.balance <span class="hljs-keyword">then</span> <span class="hljs-built_in">error</span> <span class="hljs-string">&quot;insufficient funds&quot;</span> <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">self</span>.balance = <span class="hljs-built_in">self</span>.balance - v<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>  若想从这个类派生出一个子类<code>SpecialAccount</code>，以使客户能够透支。则先需要创建一个空的类，从基类继承所有的操作：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">SpecialAccount = Account:new()<br></code></pre></td></tr></table></figure><p>  直到现在，<code>SpecialAccount</code>还只是<code>Account</code>的一个实例</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">s = SpecialAccount:new&#123;limit=<span class="hljs-number">1000.00</span>&#125;<br></code></pre></td></tr></table></figure><p>  <code>SpecialAccount</code>从<code>Account</code>继承了<code>new</code>，就像继承其他方法一样。不过这次<code>new</code>在执行时，它的<code>self</code>参数表示为<code>SpecialAccount</code>。因此，s的元表为<code>SpecialAccount</code>，<code>SpecialAccount</code>中字段<code>__index</code>的值也是<code>SpecialAccount</code>。<code>s</code>继承自<code>SpecialAccount</code>，而<code>SpecialAccount</code>又继承自<code>Account</code>。当执行：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">s:deposit(<span class="hljs-number">100.00</span>)<br></code></pre></td></tr></table></figure><p>  Lua在<code>s</code>中找不到<code>deposit</code>字段时，就会查找<code>SpecialAccount</code>。如果仍找不到<code>deposit</code>字段，就查找<code>Account</code>。最终会在那里找到<code>deposit</code>的原始实现。</p><p>  <code>SpecialAccount</code>之所以特殊是因为可以重定义那些从基类继承的方法。编写一个方法的新实现只需：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SpecialAccount:withdraw</span><span class="hljs-params">(v)</span></span><br>    <span class="hljs-keyword">if</span> v - <span class="hljs-built_in">self</span>.balance &gt;= <span class="hljs-built_in">self</span>:getLimit() <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">error</span> <span class="hljs-string">&quot;insufficient funds&quot;</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">self</span>.balane = <span class="hljs-built_in">self</span>.balance - v<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SpecialAccount:getLimit</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>.limit <span class="hljs-keyword">or</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>  现在，当调用<code>s:withdraw(200.00)</code>时，Lua就不会在<code>Account</code>中查找了。因为Lua会在<code>SpecialAccount</code>中先找到<code>withdraw</code>方法。由于<code>s.limit</code>为1000.00，程序会执行取款，并使<code>s</code>变成一个负的余额。</p><p>  Lua中的对象有一个特殊现象，就是无须为指定一种新行为而创建一个新类。如果只有一个对象需要某种特殊的行为，那么可以直接在该对象中实现这个行为。例如，账户<code>s</code>表示一个特殊的客户，这个客户的透支额度总是其余额的10%。那么可以只修改这个对象：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s:getLimit</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>.balance * <span class="hljs-number">0.10</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>  在这段代码后，调用<code>s:withdraw(200.00)</code>还是会执行<code>SpecialAccount</code>的<code>withdraw</code>。但<code>withdraw</code>所调用的<code>self:getLimit</code>则是上面这个定义。</p><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--继承</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Object:SubClass</span><span class="hljs-params">(ClassName)</span></span><br>     <span class="hljs-built_in">_G</span>[ClassName]=&#123;&#125;<br>    <span class="hljs-keyword">local</span> obj=<span class="hljs-built_in">_G</span>[ClassName]<br>    obj.base=<span class="hljs-built_in">self</span><br>    <span class="hljs-comment">--给子类设置元表</span><br>    <span class="hljs-built_in">self</span>.<span class="hljs-built_in">__index</span>=<span class="hljs-built_in">self</span><br>    <span class="hljs-built_in">setmetatable</span>(obj,<span class="hljs-built_in">self</span>)<br><span class="hljs-keyword">end</span><br><br>Object:SubClass(<span class="hljs-string">&quot;GameObject&quot;</span>)<br>GameObject.posx=<span class="hljs-number">0</span>;<br>GameObject.posy=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GameObject:Move</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">self</span>.posx=<span class="hljs-built_in">self</span>.posy+<span class="hljs-number">1</span><br>    <span class="hljs-built_in">self</span>.posy=<span class="hljs-built_in">self</span>.posy+<span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> obj=GameObject:new()<br><span class="hljs-built_in">print</span>(obj.posx)<br>obj:Move()<br><span class="hljs-built_in">print</span>(obj.posx)<br><br><span class="hljs-keyword">local</span> obj2=GameObject:new()<br><span class="hljs-built_in">print</span>(obj2.posx)<br>obj2:Move()<br><span class="hljs-built_in">print</span>(obj2.posx)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;********&quot;</span>)<br><span class="hljs-comment">--多态</span><br>GameObject:SubClass(<span class="hljs-string">&quot;Player&quot;</span>)<br><span class="hljs-comment">--重写方法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Player:Move</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">self</span>.base.Move(<span class="hljs-built_in">self</span>)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">local</span> p1=Player:new()<br><span class="hljs-built_in">print</span>(p1.posx)<br>p1:Move()<br><span class="hljs-built_in">print</span>(p1.posx)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Lua</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lua</tag>
      
      <tag>热更新</tag>
      
      <tag>Xlua</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp委托</title>
    <link href="/2023/03/07/CSharp/CSharp%E5%A7%94%E6%89%98/"/>
    <url>/2023/03/07/CSharp/CSharp%E5%A7%94%E6%89%98/</url>
    
    <content type="html"><![CDATA[<h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>委托： 函数指针的“升级版”；（C&#x2F;C++中的函数指针）<br>委托分类： Action委托、Function委托、自定义委托(delegate)；<br>“一切皆地址”： 程序（本质） &#x3D; 数据 + 算法；（变量（数据） 是以某个地址为起点的一段内存中所存储的值；函数（算法） 是以某个地址为起点的一段内存中所存储的一组机器语言指令）<br>Java 中没有与委托相对应的功能实体</p><p><strong>委托是函数(方法)的容器</strong>，可以理解为表示函数(方法)的变量类型，用来存储、传递函数(方法)。委托的本质是一个类，用来定义函数(方法)的类型(返回值和参数的类型)，不同的函数(方法)必须对应和各自”格式”一致的委托</p><h5 id="值类型与引用类型"><a href="#值类型与引用类型" class="headerlink" title="值类型与引用类型"></a>值类型与引用类型</h5><p>相同点 </p><ul><li>引用类型可以实现接口，值类型当中的结构体也可以实现接口；</li><li>引用类型和值类型都继承自System.Object类。</li></ul><p>区别</p><p>范围方面<br>C#的值类型包括：结构体（数值类型、bool型、用户定义的结构体），枚举，可空类型。<br>C#的引用类型包括：数组，用户定义的类、接口、委托，object，字符串。<br>内存分配方面：<br>数组的元素不管是引用类型还是值类型，都存储在托管堆上。<br>引用类型在栈中存储一个引用，其实际的存储位置位于托管堆。简称引类型部署在托管推上；<br>而值类型总是分配在它声明的地方：作为字段时，跟随其所属的变量（实 例）存储；作为局部变量时，存储在栈上。（栈的内存是自动释放的，堆内存是.NET中会由GC来自动释放）<br>适用场合<br>值类型在内存管理方面具有更好的效率，并且不支持多态，适合用做存储数据的载体；引用类型支持多态，适合用于定义应用程序的行为。<br>引用类型可以派生出新的类型，而值类型不能，因为所有的值类型都是密封（seal）的；<br>引用类型可以包含null值，值类型不能（可空类型功能允许将 null 赋给值类型，如 int? a &#x3D; null; ）；<br>引用类型变量的赋值只复制对对象的引用，而不复制对象本身。而将一个值类型变量赋给另一个值类型变量时，将复制包含的值。</p><h5 id="三种不同的委托类型"><a href="#三种不同的委托类型" class="headerlink" title="三种不同的委托类型"></a>三种不同的委托类型</h5><h6 id="Action-委托：-指向无返回值成员"><a href="#Action-委托：-指向无返回值成员" class="headerlink" title="Action 委托： 指向无返回值成员"></a><strong>Action 委托：</strong> 指向无返回值成员</h6><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 需要引入命名空间 using System;</span><br><span class="hljs-comment">//Action&lt;&gt;-----这是一个可以传最少1个最多16个不同类型参数的无返回值委托</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Combine</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>        &#123;<br>            <span class="hljs-comment">//无返回值委托</span><br>            Action&lt;<span class="hljs-built_in">string</span>&gt; action = <span class="hljs-keyword">new</span> Action&lt;<span class="hljs-built_in">string</span>&gt;(sayHello);<br>            action.Invoke(<span class="hljs-string">&quot;heart&quot;</span>);<br>            <span class="hljs-keyword">var</span> action2 = <span class="hljs-keyword">new</span> Action&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt;(sayHello);<br>            action2(<span class="hljs-string">&quot;Heart&quot;</span>, <span class="hljs-number">3</span>);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;Hello,<span class="hljs-subst">&#123;name&#125;</span>&quot;</span>);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name,<span class="hljs-built_in">int</span> rount</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; rount; i++)<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">$&quot;Hello,<span class="hljs-subst">&#123;name&#125;</span>&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h6 id="Function委托：指向有返回值成员"><a href="#Function委托：指向有返回值成员" class="headerlink" title="Function委托：指向有返回值成员"></a>Function委托：指向有返回值成员</h6><p>（Func&lt;参数1类型，参数2类型，返回值类型&gt;）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//Func&lt;T&gt;-----泛型委托(一个可以根据泛型指定返回值类型的泛型无参委托)</span><br><span class="hljs-comment">//可以传n(1-15)个参数的并且有返回值的委托，系统提供了16种重载</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Combine</span><br>   &#123;<br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>       &#123;<br>           <span class="hljs-comment">//有返回值委托</span><br>           Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; func = <span class="hljs-keyword">new</span> Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt;(Add);<br>           <span class="hljs-built_in">int</span> res= func(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>);<br>           Console.WriteLine(res);<br>       &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span><br>       &#123;<br>           <span class="hljs-keyword">return</span> x + y;<br>       &#125;<br><br>       <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Mul</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> x, <span class="hljs-built_in">double</span> y</span>)</span><br>       &#123;<br>           <span class="hljs-keyword">return</span> x * y;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h6 id="delegate-自定义委托"><a href="#delegate-自定义委托" class="headerlink" title="delegate 自定义委托"></a>delegate 自定义委托</h6><p>【修饰符】 delegate 【返回类型】【名称】（【参数列表】） （例如：public delegate int Add(int x,int y)）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 访问修饰默认不写，则为public，中别的命名空间中也可以使用</span><br><span class="hljs-comment">// private 其他命名空间就不能用了，一般使用public</span><br><span class="hljs-comment">//这里申明了一个可以用来存储无参无返回值函数的容器</span><br><span class="hljs-comment">// 现在这里只是定义了规则，并没有使用</span><br><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Fun</span>()</span>;<br><span class="hljs-comment">// ***注意：(在同一语句块中)委托不存在同名的两个委托，编辑器会报错误的，它不是函数不能重载</span><br><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Fun2</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a</span>)</span>;<span class="hljs-comment">// 表示用来装载或者传递返回值为int 有一个int参数的函数的委托容器规则</span><br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Mydele</span>()</span>;<span class="hljs-comment">//无返回</span><br><br>    <span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Mydele2</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HelloDelegate</span><br>    &#123;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>        &#123;<br>            <span class="hljs-comment">//dele1，这个变量引用着一个Mydele的实例，实例里包裹这M1的方法</span><br>            Mydele dele1 = <span class="hljs-keyword">new</span> Mydele(M1);<br>            dele1 += M1;<span class="hljs-comment">//又包裹了一层M1进去</span><br>            dele1.Invoke();<br><br>            Student stu = <span class="hljs-keyword">new</span> Student();<br>            dele1 += stu.SayHello;<br>            <span class="hljs-comment">//dele1 += new Student().SayHello; 另外一种方法</span><br>            dele1.Invoke();<span class="hljs-comment">//因为又Invoke了一次，所以M1又会执行两次然后是SayHello</span><br>            Console.WriteLine(<span class="hljs-string">&quot;*******************&quot;</span>);<br>            <br>            Mydele2 mydele2 = <span class="hljs-keyword">new</span> Mydele2(M2Add);<br>            Console.WriteLine(mydele2.Invoke(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>));<br>            <br>         <br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">M1</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;M1 执行了&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">M2Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> x + y;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SayHello</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Hello 我是学生&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="委托的一般使用"><a href="#委托的一般使用" class="headerlink" title="委托的一般使用"></a>委托的一般使用</h5><h6 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a><strong>模板方法</strong></h6><h6 id="借用指定的外部方法产生结果（可最大限度重用代码）"><a href="#借用指定的外部方法产生结果（可最大限度重用代码）" class="headerlink" title="借用指定的外部方法产生结果（可最大限度重用代码）"></a>借用指定的外部方法产生结果（可最大限度重用代码）</h6><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Cal</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> x, <span class="hljs-built_in">double</span> y</span>)</span>;<span class="hljs-comment">//委托声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        ProductFactory productFactory = <span class="hljs-keyword">new</span> ProductFactory(); <span class="hljs-comment">//声明产品方法</span><br>        WrapFactory wrapFactory = <span class="hljs-keyword">new</span> WrapFactory();  <span class="hljs-comment">//声明产品封装方法</span><br><br>        Func&lt;Product&gt; func1 = <span class="hljs-keyword">new</span> Func&lt;Product&gt;(productFactory.MakePizza);<span class="hljs-comment">//声明委托方法，获取产品名字信息，并作为产品封装方法的传入参数</span><br>        Func&lt;Product&gt; func2 = <span class="hljs-keyword">new</span> Func&lt;Product&gt;(productFactory.MakeToCar);<br><br>        Box box1 = wrapFactory.WrapProduct(func1); <span class="hljs-comment">//调用产品封装方法，输出含产品名字信息的box类</span><br>        Box box2 = wrapFactory.WrapProduct(func2);<br><br>        System.Console.WriteLine(box1.Product.Name); <span class="hljs-comment">//输出结果</span><br>        System.Console.WriteLine(box2.Product.Name);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Box</span><br>&#123;<br>    <span class="hljs-keyword">public</span> Product Product &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">WrapFactory</span><br>&#123;<br>    <span class="hljs-comment">//传入委托参数，内部使用委托方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Box <span class="hljs-title">WrapProduct</span>(<span class="hljs-params">Func&lt;Product&gt; getProduct</span>)</span><br>    &#123;<br>        Box box = <span class="hljs-keyword">new</span> Box();<br>        Product product = getProduct.Invoke();<span class="hljs-comment">//调用委托方法，即所传入委托参数的成员类型</span><br>        box.Product = product;<br>        <span class="hljs-keyword">return</span> box;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">ProductFactory</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">MakePizza</span>()</span><br>    &#123;<br>        Product product = <span class="hljs-keyword">new</span> Product();<br>        product.Name = <span class="hljs-string">&quot;Pizza&quot;</span>;<br>        <span class="hljs-keyword">return</span> product;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">MakeToCar</span>()</span><br>    &#123;<br>        Product product = <span class="hljs-keyword">new</span> Product();<br>        product.Name = <span class="hljs-string">&quot;MakeToCar&quot;</span>;<br>        <span class="hljs-keyword">return</span> product;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="回调（callback）方法"><a href="#回调（callback）方法" class="headerlink" title="回调（callback）方法"></a><strong>回调（callback）方法</strong></h6><p>调用指定的外部方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public delegate double <span class="hljs-constructor">Cal(<span class="hljs-params">double</span> <span class="hljs-params">x</span>, <span class="hljs-params">double</span> <span class="hljs-params">y</span>)</span>;<span class="hljs-comment">//委托声明</span><br>   <span class="hljs-keyword">class</span> Program<br>   &#123;<br>       static void <span class="hljs-constructor">Main(<span class="hljs-params">string</span>[] <span class="hljs-params">args</span>)</span><br>       &#123;<br>           ProductFactory productFactory = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ProductFactory()</span>; <span class="hljs-comment">//声明产品方法</span><br>           WrapFactory wrapFactory = <span class="hljs-keyword">new</span> <span class="hljs-constructor">WrapFactory()</span>;  <span class="hljs-comment">//声明产品封装方法</span><br><br>           Func&lt;Product&gt; func1 = <span class="hljs-keyword">new</span> Func&lt;Product&gt;(productFactory.MakePizza);<span class="hljs-comment">//声明委托方法，获取产品名字信息，并作为产品封装方法的传入参数</span><br>           Func&lt;Product&gt; func2 = <span class="hljs-keyword">new</span> Func&lt;Product&gt;(productFactory.MakeToCar);<br><br>           Logger logger = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Logger()</span>; <span class="hljs-comment">//声明产品记录方法</span><br>           Action&lt;Product&gt; log = <span class="hljs-keyword">new</span> Action&lt;Product&gt;(logger.Log);<br><br>           Box box1 = wrapFactory.<span class="hljs-constructor">WrapProduct(<span class="hljs-params">func1</span>, <span class="hljs-params">log</span>)</span>; <span class="hljs-comment">//调用产品封装方法，输出含产品名字信息的box类</span><br>           Box box2 = wrapFactory.<span class="hljs-constructor">WrapProduct(<span class="hljs-params">func2</span>, <span class="hljs-params">log</span>)</span>;<br><br>           System.Console.<span class="hljs-constructor">WriteLine(<span class="hljs-params">box1</span>.Product.Name)</span>; <span class="hljs-comment">//输出结果</span><br>           System.Console.<span class="hljs-constructor">WriteLine(<span class="hljs-params">box2</span>.Product.Name)</span>;<br>       &#125;<br>   &#125;<br><br>   <span class="hljs-comment">//定义记录产品信息类</span><br>   <span class="hljs-keyword">class</span> Logger<br>   &#123;<br>       public void <span class="hljs-constructor">Log(Product <span class="hljs-params">product</span>)</span><br>       &#123;<br>           System.Console.<span class="hljs-constructor">WriteLine(<span class="hljs-string">&quot;Product&#x27;&#123;0&#125;&#x27; create at &#123;1&#125; Price is &#123;2&#125;.&quot;</span>, <span class="hljs-params">product</span>.Name, DateTime.UtcNow, <span class="hljs-params">product</span>.Price)</span>; <span class="hljs-comment">//utcNow为不带时区的时间形式</span><br>       &#125;<br>   &#125;<br>   <span class="hljs-keyword">class</span> Product<br>   &#123;<br>       public <span class="hljs-built_in">string</span> Name &#123; get; set; &#125;<br>       public double Price &#123; get; set; &#125;<br>   &#125;<br>   <span class="hljs-keyword">class</span> Box<br>   &#123;<br>       public Product Product &#123; get; set; &#125;<br>   &#125;<br>   <span class="hljs-keyword">class</span> WrapFactory<br>   &#123;<br>       <span class="hljs-comment">//传入委托参数，内部使用委托方法</span><br>       public Box <span class="hljs-constructor">WrapProduct(Func&lt;Product&gt; <span class="hljs-params">getProduct</span>, Action&lt;Product&gt; <span class="hljs-params">logCallBack</span>)</span><br>       &#123;<br>           Box box = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Box()</span>;<br>           Product product = getProduct.<span class="hljs-constructor">Invoke()</span>;<span class="hljs-comment">//调用委托方法，即所传入委托参数的成员类型</span><br>           <span class="hljs-keyword">if</span> (product.Price &gt; <span class="hljs-number">50</span>)<br>           &#123;<br>               logCallBack.<span class="hljs-constructor">Invoke(<span class="hljs-params">product</span>)</span>;<br>           &#125;<br>           box.Product = product;<br>           return box;<br>       &#125;<br>   &#125;<br>   <span class="hljs-keyword">class</span> ProductFactory<br>   &#123;<br>       public Product <span class="hljs-constructor">MakePizza()</span><br>       &#123;<br>           Product product = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Product()</span>;<br>           product.Name = <span class="hljs-string">&quot;Pizza&quot;</span>;<br>           product.Price = <span class="hljs-number">12</span>;<br>           return product;<br>       &#125;<br><br>       public Product <span class="hljs-constructor">MakeToCar()</span><br>       &#123;<br>           Product product = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Product()</span>;<br>           product.Name = <span class="hljs-string">&quot;MakeToCar&quot;</span>;<br>           product.Price = <span class="hljs-number">100</span>;<br>           return product;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h6 id="模板方法和回调方法的本"><a href="#模板方法和回调方法的本" class="headerlink" title="模板方法和回调方法的本"></a><strong>模板方法和回调方法的本</strong></h6><p>用委托类型的参数，封装一个外部方法，然后将此方法传递到方法内部，进行间接调用。</p><p>区别</p><p>模板方法：<br>相当于“填空题”；<br>常位于代码中部；<br>委托有返回值</p><p>回调方法：<br>相当于“流水线”；<br>常位于代码末尾；<br>委托无返回值</p><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><h5 id="什么是匿名函数"><a href="#什么是匿名函数" class="headerlink" title="什么是匿名函数"></a>什么是匿名函数</h5><p>顾名思义,匿名函数就是没有名字的函数;匿名函数的使用主要是配合委托和事件进行使用的;脱离委托和事件是不会使用匿名函数的.</p><h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">delegate</span> (参数列表)&#123;<br>    <span class="hljs-comment">// 函数逻辑</span><br>&#125;;<br><span class="hljs-comment">// 何时使用?</span><br><span class="hljs-comment">// 1.函数中传递委托参数时</span><br><span class="hljs-comment">// 2.委托或者事件赋值时</span><br></code></pre></td></tr></table></figure><h5 id="匿名函数的使用"><a href="#匿名函数的使用" class="headerlink" title="匿名函数的使用"></a>匿名函数的使用</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">// 1.无参无返回</span><br><span class="hljs-comment">// ***注意:我们是无法申明匿名函数的,匿名函数是无法脱离了委托和事件存在的,所以匿名函数申明必须作为委托或者事件的右值赋值给委托或者事件,而无法单独存在.</span><br>Action ac = <span class="hljs-built_in">delegate</span> ()&#123;<br>Console.WriteLine(<span class="hljs-string">&quot;123&quot;</span>);<br>&#125;;<br><span class="hljs-comment">// 执行匿名函数</span><br>ac();<br><br><span class="hljs-comment">//2.有参数</span><br>Action&lt;<span class="hljs-built_in">int</span> ,<span class="hljs-built_in">string</span>&gt; b = <span class="hljs-built_in">delegate</span> (<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">string</span> b)&#123;<br>    Console.WriteLine(a);<br>    Console.WriteLine(b);<br>&#125;;<br><br><span class="hljs-comment">//3.有返回值</span><br>Func&lt;<span class="hljs-built_in">string</span>&gt; func = <span class="hljs-built_in">delegate</span> ()&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;123123&quot;</span>;  <br>&#125;;<br><span class="hljs-comment">// 执行</span><br>Console.WriteLine(func());<br><br><span class="hljs-comment">//4.一般情况会作为函数参数传递或者作为函数返回值</span><br><span class="hljs-comment">// 作为参数传递时</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> Action action;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, Action fun</span>)</span>&#123;<br>       Console.WriteLine(a);<br>        fun();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Action <span class="hljs-title">GetFun</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">delegate</span> ()&#123;&#125;;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span>&#123;<br>        <span class="hljs-comment">// 参数传递</span><br>        Test t = <span class="hljs-keyword">new</span> Test();<br>        t.DoSomething(<span class="hljs-number">100</span>, <span class="hljs-built_in">delegate</span> ()&#123;<br>           Console.WriteLine(<span class="hljs-string">&quot;随着参数传入的匿名函数&quot;</span>); <br>        &#125;);<br>        <br>        <span class="hljs-comment">// 返回值</span><br>        Action ac = t.GetFun();<br>ac();<br><span class="hljs-comment">// 我们也可以直接一步到位</span><br>        <span class="hljs-comment">// 我们先看前一半ac()返回了一个函数名,函数名＋后一半&quot;()&quot;相当于调用这个 函数</span><br>        ac()();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="匿名函数的缺点"><a href="#匿名函数的缺点" class="headerlink" title="匿名函数的缺点"></a>匿名函数的缺点</h5><p>添加到委托或者事件容器后,不记录下来的话,我们无法单独移除,因为我们的匿名函数没有函数名,所以唯一的方法是把委托或者事件容器全部清空才行.</p><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><h5 id="什么是Lambda表达式"><a href="#什么是Lambda表达式" class="headerlink" title="什么是Lambda表达式"></a>什么是Lambda表达式</h5><p>Lambda表达式可以理解为匿名函数的简写形式，它除了写法上的不同外，使用上和功能上完全与匿名函数一模一样，优缺点也是一模一样的，同理，它也是需要配合委托或者事件使用的。</p><h5 id="lambda表达式语法"><a href="#lambda表达式语法" class="headerlink" title="lambda表达式语法"></a>lambda表达式语法</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#">(参数列表)=&gt;&#123;<br>    <span class="hljs-comment">// 函数体</span><br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="lambda表达式的使用"><a href="#lambda表达式的使用" class="headerlink" title="lambda表达式的使用"></a>lambda表达式的使用</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#">Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; func = <span class="hljs-keyword">new</span> Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt;((<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b) =&gt; &#123; <span class="hljs-keyword">return</span> a + b;&#125;);<br>        <span class="hljs-built_in">int</span> res = func(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>);<br>        Console.WriteLine(res);<br>        func = <span class="hljs-keyword">new</span> Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt;((x, y) =&gt; &#123; <span class="hljs-keyword">return</span> x * y; &#125;); <span class="hljs-comment">//不带类型也OK</span><br>        res = func(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br>        Console.WriteLine(res);<br>        func = ((x, y) =&gt; &#123; <span class="hljs-keyword">return</span> x / y; &#125;); <span class="hljs-comment">//最简洁写法</span><br>        res = func(<span class="hljs-number">15</span>, <span class="hljs-number">5</span>);<br>        Console.WriteLine(res);<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>        &#123;<br>            <span class="hljs-comment">//类型可以被推断出来，可以省略</span><br>            DoSomeCals(( a, b) =&gt; &#123; <span class="hljs-keyword">return</span> a * b;&#125;,<span class="hljs-number">100</span>,<span class="hljs-number">200</span>);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoSomeCals</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Func&lt;T, T, T&gt; func, T x, T y</span>)</span><br>        &#123;<br>          T res=  func(x, y);<br>          Console.WriteLine(res);<br>        &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>花里胡哨</tag>
      
      <tag>CSharp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>泛型</title>
    <link href="/2023/03/05/CSharp/%E6%B3%9B%E5%9E%8B/"/>
    <url>/2023/03/05/CSharp/%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h5 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h5><p>为了避免成员膨胀或者类型膨胀，泛型实现了类型参数化，达到代码重用的目的，通过类型参数化来实现同一份代码上的多种类型操作。</p><p>泛型相当于类型占位符，定义类或方法时候使用替代符代表变量类型，当真正使用类或者方法时候再具体指定类型。</p><p>泛型具有正交性 泛型类型 (类&#x2F;接口&#x2F;委托&#x2F; …) 泛型成员 (属性&#x2F;方法&#x2F;字段)等</p><h6 id="泛型基本语法"><a href="#泛型基本语法" class="headerlink" title="泛型基本语法"></a>泛型基本语法</h6><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> 类名&lt;泛型占位字母&gt;<br><span class="hljs-comment">// 举例：下面就是一个泛型类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span>&lt;<span class="hljs-title">T</span>&gt;&#123;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-keyword">value</span>;<br>&#125;<br><span class="hljs-comment">// 当我们要用这个类的时候，我们需要在申明跟初始化的时候去告诉我们的编译器它的泛型是什么类型</span><br><span class="hljs-comment">// 举例：下面就是一个泛型类的使用</span><br><span class="hljs-comment">// 我们把泛型指定为了int类型，这时候我们Test里面的成员value就是一个int类型的字段了</span><br>Test&lt;<span class="hljs-built_in">int</span>&gt; test = <span class="hljs-keyword">new</span> Test&lt;<span class="hljs-built_in">int</span>&gt;();<br><br><span class="hljs-comment">// 我们把泛型指定为了string类型，这时候我们Test里面的成员value就是一个string类型的字段了</span><br>Test&lt;<span class="hljs-built_in">string</span>&gt; test = <span class="hljs-keyword">new</span> Test&lt;<span class="hljs-built_in">string</span>&gt;();<br><span class="hljs-comment">// ***总结：我们可以很明显的看到了，我们声明的泛型类可以满足我们的不同需求，一份代码可以多次重用，这是泛型类最大的特点</span><br><br><span class="hljs-keyword">interface</span> 接口名&lt;泛型占位字母&gt;<br><span class="hljs-comment">// 举例：下面就是一个泛型接口的使用</span><br><span class="hljs-title">interface</span> <span class="hljs-title">TestInterface</span>&lt;<span class="hljs-title">T</span>&gt;&#123;<br>    T <span class="hljs-keyword">value</span>&#123;<br>        <span class="hljs-keyword">get</span>;<br>        <span class="hljs-keyword">set</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 我们可以看到，当我们继承了某个泛型接口的时候，这时候我们是需要指定这个泛型的具体类型的</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span>:<span class="hljs-title">TestInterface</span>&lt;<span class="hljs-title">int</span>&gt;&#123;<br>    <br>&#125;<br><span class="hljs-comment">// *注意：泛型接口一样可以拥有多个泛型占位字母</span><br><br><span class="hljs-comment">// 泛型函数</span><br><span class="hljs-comment">// 基本语法：函数名&lt;泛型占位字母&gt;(参数列表)</span><br><span class="hljs-comment">// 举例：下面就是一个有一个参数的泛型函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Func</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T t1</span>)</span>&#123;<br>    <br>&#125;<br><span class="hljs-comment">// ***注意：泛型占位字母可以有多个，用逗号分开</span><br><span class="hljs-comment">// 举例：下面这个泛型方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Func2</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt;(<span class="hljs-params">K k1, V v1</span>)</span>&#123;<br>    <br>&#125;<br><span class="hljs-comment">// 类和接口也是一样的</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span>&lt;<span class="hljs-title">T1</span>, <span class="hljs-title">T2</span>, <span class="hljs-title">K</span>, <span class="hljs-title">M</span> <span class="hljs-title">LL</span>, <span class="hljs-title">Key</span> <span class="hljs-title">Value</span>&gt;&#123;<br>    <span class="hljs-keyword">public</span> T1 <span class="hljs-keyword">value</span>;<br>    <span class="hljs-keyword">public</span> T2 <span class="hljs-keyword">value</span>;<br>    <span class="hljs-keyword">public</span> K <span class="hljs-keyword">value</span>;<br>    <span class="hljs-keyword">public</span> MM <span class="hljs-keyword">value</span>;<br>    <span class="hljs-keyword">public</span> LL <span class="hljs-keyword">value</span>;<br>    <span class="hljs-keyword">public</span> Key <span class="hljs-keyword">value</span>;<br>    <span class="hljs-keyword">public</span> Value <span class="hljs-keyword">value</span>;<br>&#125;<br><br><span class="hljs-comment">// *注意：泛型占位字母/泛型占位符不单单只是“T”，还可以是任意的字母，只要是写在尖括号“&lt;&gt;”里面的字母，都算是泛型占位符</span><br></code></pre></td></tr></table></figure><p>泛型对于成员膨胀和类型膨胀具有良好的作用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//类型膨胀</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HelloGeneric</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>        &#123;<br>            Apple apple = <span class="hljs-keyword">new</span> Apple()&#123;Color = <span class="hljs-string">&quot;Red&quot;</span>&#125;;<br>            AppleBox appleBox = <span class="hljs-keyword">new</span> AppleBox() &#123;Cargo = apple&#125;;<br>            Console.WriteLine(appleBox.Cargo.Color);<br><br>            Book book = <span class="hljs-keyword">new</span> Book() &#123;Name = <span class="hljs-string">&quot;天空之城&quot;</span>&#125;;<br>            BookBox bookBox = <span class="hljs-keyword">new</span> BookBox() &#123;Cargo = book&#125;;<br>            Console.WriteLine(bookBox.Cargo.Name);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Color &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Book</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">AppleBox</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> Apple Cargo &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">BookBox</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> Book Cargo &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    &#125;<br><br><span class="hljs-comment">//成员膨胀</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HelloGeneric</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>        &#123;<br>            Apple apple = <span class="hljs-keyword">new</span> Apple()&#123;Color = <span class="hljs-string">&quot;Red&quot;</span>&#125;;<br>            Book book = <span class="hljs-keyword">new</span> Book() &#123;Name = <span class="hljs-string">&quot;天空之城&quot;</span>&#125;;<br>            Box box1 = <span class="hljs-keyword">new</span> Box() &#123;Apple = apple&#125;;<br>            Box box2 = <span class="hljs-keyword">new</span> Box() &#123;Book = book&#125;;<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Color &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Book</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Box</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> Apple Apple &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> Book Book &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这个例子就产生了类型膨胀，因为如果我们还想声明一本书或者苹果的颜色。有一种做法，是再声明一个盒子只装书。这显然会随着商品种类增多造成类型膨胀。或者是在盒子类里再多一个书的属性，这显然会造成成员膨胀。而如果使用接口，又感觉划不来。这时候，我们可以考虑使用泛型。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>       &#123;<br>           Apple apple = <span class="hljs-keyword">new</span> Apple()&#123;Color = <span class="hljs-string">&quot;Red&quot;</span>&#125;;<br>           Book book = <span class="hljs-keyword">new</span> Book() &#123;Name = <span class="hljs-string">&quot;天空之城&quot;</span>&#125;;<br>           Box&lt;Apple&gt; box1 = <span class="hljs-keyword">new</span> Box&lt;Apple&gt;() &#123;Cargo = apple&#125;;<br>           Box&lt;Book&gt; box2 = <span class="hljs-keyword">new</span> Box&lt;Book&gt;() &#123;Cargo = book&#125;;<br>           Console.WriteLine(box1.Cargo.Color);<br>           Console.WriteLine(box2.Cargo.Name);<br>       &#125;<br>   &#125;<br>   <span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span><br>   &#123;<br>       <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Color &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>   &#125;<br>   <span class="hljs-keyword">class</span> <span class="hljs-title">Book</span><br>   &#123;<br>       <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">class</span> <span class="hljs-title">Box</span>&lt;<span class="hljs-title">TCargo</span>&gt;<br>   &#123;<br>       <span class="hljs-keyword">public</span> TCargo Cargo &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>使用泛型之后，我们就避免了成员膨胀和类型膨胀</p><h6 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h6><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//若类继承泛型接口，则该类为泛型类</span><br><span class="hljs-comment">//若类继承泛型特化接口，则该类不是泛型类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InterfaceGeneric</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>        &#123;<br>            Student&lt;<span class="hljs-built_in">int</span>&gt; stu = <span class="hljs-keyword">new</span> Student&lt;<span class="hljs-built_in">int</span>&gt;();<br>            stu.id = <span class="hljs-number">101</span>;<br>            stu.Name = <span class="hljs-string">&quot;Heart&quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title">IUnique</span>&lt;<span class="hljs-title">Tid</span>&gt;<br>    &#123;<br>        Tid id &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>&lt;<span class="hljs-title">Tid</span>&gt;:<span class="hljs-title">IUnique</span>&lt;<span class="hljs-title">Tid</span>&gt;<br>    &#123;<br>        <span class="hljs-keyword">public</span> Tid id &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    &#125;<br><br>ps list 动态数组<br></code></pre></td></tr></table></figure><h6 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h6><p>普通类中的泛型方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span>&#123;<br>    <span class="hljs-comment">// 下面是普通类中泛型方法的申明</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TestFun</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T <span class="hljs-keyword">value</span></span>)</span>&#123;<br>        Console.WriteLine(<span class="hljs-keyword">value</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 你也可以使用我们的无参泛型方法</span><br>    <span class="hljs-comment">// ***注意：泛型方法也是方法，所以它是支持函数重载的。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TestFunc</span>&lt;<span class="hljs-title">T</span>&gt;()</span>&#123;<br>        <span class="hljs-comment">// 泛型方法的内部去处理一些逻辑</span><br>        <span class="hljs-comment">// 例如得到我们类型的默认值</span><br>        T t = <span class="hljs-literal">default</span>(T);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 我们还可以利用泛型做一些特殊的返回值</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">TestFunc</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">default</span>(T);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 同理泛型方法也是可以有多个泛型占位符的</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Func3</span>&lt;<span class="hljs-title">T1</span>, <span class="hljs-title">T2</span>, <span class="hljs-title">T3</span>&gt;(<span class="hljs-params">T1 t1, T2 t2, T3 t3</span>)</span>&#123;<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 接下来看如何使用我们申明的泛型方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span>&#123;<br>        <span class="hljs-comment">// 第一步，先申明跟实例化我们的类</span><br>        Test2 test2 = <span class="hljs-keyword">new</span> Test2();<br>        <span class="hljs-comment">// 第二部，使用我们的泛型方法，先把泛型占位符指定为具体的类型，然后再填写函数参数</span><br>        test2.TestFun&lt;<span class="hljs-built_in">string</span>&gt;(“<span class="hljs-number">123</span>”);<br>       <br>        <span class="hljs-comment">// ***注意:当我们有多个泛型方法的时候，我们是可以省略尖括号“&lt;&gt;”的方式，以直接传参数的方式，让编辑器自己去根据我们的参数类型确认调用哪个泛型方法，例如我们的函数重载一样。</span><br>        <span class="hljs-comment">// 举例子：我们的类中有一个是泛型方法但是参数是string类型的TestFunc&lt;T&gt;(string value)，还有一个是TestFunc&lt;T&gt;(T t1)</span><br>        <span class="hljs-comment">// 我们直接调用方法，并且传入一个字符串，这时候编辑器会默认调用我们的TestFunc&lt;T&gt;(string value)方法</span><br>        <span class="hljs-comment">// 我可以运行后，把鼠标放在下面这个语句上，然后按F12定位到它调用的函数，这样也可以找到我们调用了哪个泛型函数</span><br>        test2.TestFunc(<span class="hljs-string">&quot;123&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>泛型类中的泛型方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">// ***注意：class Test&#123;&#125;和class Test&lt;T&gt;虽然看似是同名类，但是他们是不一样的类，你可以把&lt;T&gt;也看作类名的一部分来看。</span><br><span class="hljs-comment">// class Test&#123;&#125;是普通类，class Test&lt;T&gt;&#123;&#125;是泛型类，功能是也是不同的，所以是不一样的两个类，互不相关。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">T</span>&gt;&#123;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-keyword">value</span>;<br>    <br>    <span class="hljs-comment">// ***注意：这个不叫泛型方法，因为T是泛型类申明的时候就指定，在使用这个函数的时候，我们就不能再去动态的变化了</span><br>    <span class="hljs-comment">// 那么什么是泛型方法？简单的说就是函数名后面带着一对尖括号“&lt;&gt;”的我们就可以当作是泛型方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TestFun</span>(<span class="hljs-params">T t</span>)</span>&#123;<br>    <br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params">stringp[] args</span>)</span>&#123;<br>        <span class="hljs-comment">// 泛型类，我们再申明和实例化的时候就需要指定我们的具体类型了</span><br>        Test&lt;<span class="hljs-built_in">int</span>&gt; test = <span class="hljs-keyword">new</span> Test&lt;<span class="hljs-built_in">int</span>&gt;();<br>        <span class="hljs-comment">// 调用泛型类中的方法的时候就不需要去指定了，直接调用。</span><br>        test.TestFun();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="泛型对类型方法的参数判断"><a href="#泛型对类型方法的参数判断" class="headerlink" title="泛型对类型方法的参数判断"></a>泛型对类型方法的参数判断</h6><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//泛型方法调用时类型参数的自动推断 </span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">int</span>[] s1 = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br>            <span class="hljs-built_in">int</span>[] s2 = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> &#125;;<br>            <span class="hljs-built_in">double</span>[] s3 = &#123; <span class="hljs-number">1.1</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">3.3</span>, <span class="hljs-number">4.4</span>, <span class="hljs-number">5.5</span> &#125;;<br>            <span class="hljs-built_in">double</span>[] s4 = &#123; <span class="hljs-number">1.1</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">3.3</span>, <span class="hljs-number">4.4</span>, <span class="hljs-number">5.5</span> ,<span class="hljs-number">6.6</span>&#125;;<br>            <span class="hljs-keyword">var</span> result = Zip(s1, s2);<br>            Console.WriteLine(<span class="hljs-built_in">string</span>.Join(<span class="hljs-string">&quot;,&quot;</span>,result));<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> T[] <span class="hljs-title">Zip</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T[] a, T[] b</span>)</span><br>        &#123;<br>            T[] zipped = <span class="hljs-keyword">new</span> T[a.Length + b.Length];<br>            <span class="hljs-built_in">int</span> ai = <span class="hljs-number">0</span>, bi = <span class="hljs-number">0</span>, zi = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">do</span><br>            &#123;<br>                <span class="hljs-keyword">if</span> (ai &lt; a.Length) zipped[zi++] = a[ai++];<br>                <span class="hljs-keyword">if</span> (bi &lt; b.Length) zipped[zi++] = b[bi++];<br>            &#125;<br>            <span class="hljs-keyword">while</span> (ai &lt; a.Length || bi &lt; b.Length);<br><br>            <span class="hljs-keyword">return</span> zipped;<br>        &#125;<br></code></pre></td></tr></table></figure><p>泛型委托</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c#"> <span class="hljs-comment">//Action&lt;T&gt;泛型委托--只能引用无返回值的方法</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>        &#123;<br>            Action&lt;<span class="hljs-built_in">string</span>&gt; a1 = Say;<br>            a1(<span class="hljs-string">&quot;Heart&quot;</span>);<br>            Action&lt;<span class="hljs-built_in">int</span>&gt; a2 = Mul;<br>            a2.Invoke(<span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Say</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> str</span>)</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;Hello,<span class="hljs-subst">&#123;str&#125;</span>&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Mul</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span><br>        &#123;<br>            Console.WriteLine(x * <span class="hljs-number">100</span>);<br>        &#125;<br>        <br> <span class="hljs-comment">//Func&lt;T&gt;泛型委托--引用有返回值的方法     </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>        &#123;<br>          <span class="hljs-comment">//两个int的参数值 一个int 的返回值</span><br>            Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; f1 = Add;<br>            Console.WriteLine( f1(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<br>            <br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a,<span class="hljs-built_in">int</span> b</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> a + b;<br>        &#125;<br><span class="hljs-comment">//匿名方法 lamba表达式</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>        &#123;<br>          <span class="hljs-comment">//两个int的参数值 一个int 的返回值</span><br>            Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; f1 = ( a, b)=&gt;&#123;retuen a+b&#125;;<br>            Console.WriteLine( f1(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<br>            <br>        &#125;<br></code></pre></td></tr></table></figure><p>总结</p><p>1.申明泛型时，它只是一个类型的占位符</p><p>2.泛型真正起作用的时候，是在使用它的时候</p><p>3.泛型占位字母可以有n个用逗号分开</p><p>4.泛型占位字母一般是大写字母</p><p>5.不确定泛型类型时获取默认值可以使用default(占位字母)</p><p>6.看到&lt;&gt;的字母那肯定是泛型</p><p><strong>作用</strong></p><p>让不同类型对象的相同逻辑处理就可以选择泛型</p><p>使用泛型可以一定程度上避免装箱拆箱</p><p>举例：优化我们的ArrayList</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">// 我们知道，ArrayList是一个object类型的数组组成，所以它是存在装箱拆箱的问题了，但是如果我们自己利用泛型重新一个ArrayList就可以达到我们优化的效果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">T</span>&gt;&#123;<br>    <span class="hljs-keyword">private</span> T[] array;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">T <span class="hljs-keyword">value</span></span>)</span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Remove</span>(<span class="hljs-params">T <span class="hljs-keyword">value</span></span>)</span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="泛型的约束"><a href="#泛型的约束" class="headerlink" title="泛型的约束"></a>泛型的约束</h5><p><strong>关键字 where</strong></p><p>泛型约束一共有6种</p><p>1.值类型where 泛型字母：struct</p><p>2.引用类型where 泛型字母：class</p><p>3.存在无参公共构造函数 where 泛型字母：new()</p><p>4.某个类本身或者其派生类 where 泛型字母：类名</p><p>5.某个接口的派生类型     where 泛型字母：接口名</p><p>6.另一个泛型类型本身或者派生类型  where 泛型字母：另一个泛型字母</p><p>基本语法：where 泛型字母：约束的类型</p><h6 id="各种泛型的约束讲解"><a href="#各种泛型的约束讲解" class="headerlink" title="各种泛型的约束讲解"></a>各种泛型的约束讲解</h6><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">// 1.值类型约束</span><br><span class="hljs-comment">// 这样就代表了T一定是一个结构体，因为结构体是值类型(这里肯定会有疑问，那如果不是结构体呢？我传入int、float这类值类型还可以吗？下面的使用案例会有解释)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span>:<span class="hljs-title">struct</span>&#123;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-keyword">value</span>;<br>    <span class="hljs-comment">// 这样代表泛型方法的泛型字母K也是一个值类型类型</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> TestFunc&lt;K&gt; <span class="hljs-keyword">where</span> K:<span class="hljs-keyword">struct</span>&#123;<br>        <br>&#125;<br>&#125;<br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span>&#123;<br>        <span class="hljs-comment">// 使用案例</span><br>        <span class="hljs-comment">// 大家会发现只要是值类型的都可以，那为什么上面我会说是T一定是一个结构体呢？我们可以把光标点一下int或者float然后按F12进入看看int和float的实现源码</span><br>        <span class="hljs-comment">// 当我们对int按下F12进去的时候，我们进入了</span><br>        <span class="hljs-comment">// public readonly struct Int32 : IComparable, IComparable&lt;Int32&gt;, IConvertible, IEquatable&lt;Int32&gt;, IFormattable&#123;.....&#125;</span><br>        <span class="hljs-comment">// 说明int真正的名字是int32，int只是int32的别名，它前面struct表示了int32是一个结构体，说明int类型本身就是一个结构体，同理的，也可以对float进行同样的操作，float的真正名字是Single,float是别名，它也是一个结构体类型。</span><br>        <span class="hljs-comment">// 为了避免产生疑问，我们之前学的结构体，算是自定义结构体的统称，其实只要是是值类型的实现，它的本身就是一个结构体。</span><br>        Test&lt;<span class="hljs-built_in">int</span>&gt; test = <span class="hljs-keyword">new</span> Test&lt;<span class="hljs-built_in">int</span>&gt;();<br>        Test&lt;<span class="hljs-built_in">float</span>&gt; test2 = <span class="hljs-keyword">new</span> Test&lt;&gt;(<span class="hljs-built_in">float</span>);<br>        test.TestFunc&lt;<span class="hljs-built_in">int</span>&gt;();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">// 2.引用类型约束</span><br><span class="hljs-comment">// 泛型必须是引用类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span>:<span class="hljs-keyword">class</span>&#123;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-keyword">value</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TestFun</span>&lt;<span class="hljs-title">K</span>&gt;(<span class="hljs-params">K k</span>) <span class="hljs-keyword">where</span> K:<span class="hljs-keyword">class</span></span>&#123;<br>        <br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-comment">// 使用案例</span><br>            Test2&lt;Random&gt; test = <span class="hljs-keyword">new</span> Test2&lt;Random&gt;();<br>            test.TestFun&lt;<span class="hljs-built_in">object</span>&gt;();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">// 3.公共无参构造约束</span><br><span class="hljs-comment">// 这个表示我们的泛型指定类型必须一个具有“公共”“无参”构造函数，两个条件缺一不可</span><br><span class="hljs-comment">// ***注意：结构体也满足此条件，如果有疑问可以接着往下看</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span>:<span class="hljs-title">new</span>()&#123;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-keyword">value</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TestFun</span>&lt;<span class="hljs-title">K</span>&gt;() <span class="hljs-keyword">where</span> K:<span class="hljs-keyword">new</span>()</span>&#123;<br>        <br>&#125;<br>&#125;<br><span class="hljs-comment">// 为了方便测试，我们再写一个用于测试的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Test4</span>&#123;<br>  <span class="hljs-comment">// 当我们没有写任何构造函数的时候，会默认调用自带的公共无参构造函数</span><br>  <span class="hljs-comment">// 一定不能是私有类型或者保护类型！必须是public类型</span><br>  <span class="hljs-comment">// ***注意：当我们自己写了一个构造函数的时候，会顶掉我们的默认构造函数；如果我们写了一个无参的构造函数，其实意义不大就跟默认的公共构造函数的作用是一样的。但是一定记住，只要写了我们自己的构造函数之后，该类就会失去其原有的默认的公共无参构造函数。</span><br>&#125;<br><span class="hljs-comment">// 使用案例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-comment">// 因为我们Test4里面自带了默认的公共无参构造函数，所以下面这条语句没问题</span><br>            <span class="hljs-comment">// ***注意：当是我们不可以传入一个抽象类，因为抽象类是无法被实例化创建的。</span><br>            Test3&lt;Test4&gt; test = <span class="hljs-keyword">new</span> Test3&lt;Test4&gt;();<br>            <br>            <br>            <span class="hljs-comment">// ***注意：我们学过结构体也明白，结构体也是可以写构造函数的</span><br>            <span class="hljs-comment">// 我们是可以写入一个结构体类型的，因为结构体也具有无参构造函数</span><br>            Test3&lt;<span class="hljs-built_in">int</span>&gt; test3 = <span class="hljs-keyword">new</span> Test3&lt;&gt;(<span class="hljs-built_in">int</span>);<br>            <br>            <span class="hljs-comment">// ***注意：再提醒一下，结构体和类不一样，类中我们是可以写显式的无参构造函数的，但是在结构体中，我们是无法在其中写一个不带参数的无参公共构造函数的，这是因为编译器不允许的(为什么不被允许，可以自行Google，因为解释起来麻烦，具体的为什么在Unity中结构体无法作为等式的左值进行赋值修改，例如:this.transform.position.x = 10f，为什么不被允许，也是跟结构体和编辑器有关，可以自行Google。)，其次，注意一点，如果我们一定想在结构体中写构造函数的化，我们是必须实现其全部成员的带参构造函数，也就是说，我们的必须对其所有成员变量进行初始化。说到这里，再提醒一点，结构中声明的字段是不允许被初始化的(自行Google).</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">// 4.某个类本身或者其派生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span>:<span class="hljs-title">Test1</span>&#123;<br>    <br>&#125;<br><span class="hljs-comment">// where T:类名约束的内容是该类型必须是该类名本身或者其派生类</span><br><span class="hljs-comment">// 下面约束的就是该类型必须是Test1本身这个类或者其子类Test2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span>:<span class="hljs-title">Test1</span>&#123;<br>    <br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-comment">// 使用案例</span><br>Test&lt;Test1&gt; test1 = <span class="hljs-keyword">new</span> Test&lt;Test1&gt;();<br>        Test&lt;Test2&gt; test2 = <span class="hljs-keyword">new</span> Test&lt;&gt;(Test2);<br>        <span class="hljs-comment">// 注意传入的必须是这个类或者其子类，如果是这个类的父类是不允许的，会报错的，例如我们传入万物之父Object类，编辑器是会报错误的。</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">// 5.接口约束</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title">IFly</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fly</span>()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title">IJump</span>:<span class="hljs-title">IFly</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span>:<span class="hljs-title">IFly</span>&#123;<br>    <span class="hljs-comment">// 这一行不需要管，因为我们继承了接口就需要实现接口的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Fly</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 这一行不需要管，这里是抛出没有逻辑内容错处</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 接口约束，是指定类型是某个接口的派生类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span>:<span class="hljs-title">IFly</span>&#123;<br>    <br>&#125;<br><span class="hljs-comment">// 使用案例            </span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-comment">// 只要是接口本身或者其派生接口或者是继承至接口的普通类都可以传入</span><br>            Test&lt;Test2&gt; test = <span class="hljs-keyword">new</span> test&lt;Test2&gt;();<br>            Test&lt;IFly&gt; test2 = <span class="hljs-keyword">new</span> Test4&lt;IFly&gt;();<br>            Test&lt;IJump&gt; test3 = <span class="hljs-keyword">new</span> Test4&lt;IJump&gt;();<br>        <br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">// 6.另一个泛型约束</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> : <span class="hljs-title">Test1</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">U</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span>:<span class="hljs-title">U</span>&#123;<br>  <br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-comment">// 这里有点绕，我们拆开来看</span><br>            <span class="hljs-comment">// 我们把U先替换成Test1，这时候原本的class Test&lt;T, Test1&gt;where T : Test1&#123;&#125;是不是变成了，我们对类名的约束，也就是说，这时候剩下的泛型占位字母T要么是这个Test1类，要么是其子类</span><br>            Test&lt;Test2, Test1&gt; test = <span class="hljs-keyword">new</span> Test&lt;Test2, Test1&gt;();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h6 id="约束的组合使用"><a href="#约束的组合使用" class="headerlink" title="约束的组合使用"></a>约束的组合使用</h6><p>举个例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">// 这里相当于我们约束了泛型占位字母T的类型必须是引用类型且拥有公共无参的构造函数</span><br><span class="hljs-comment">// ***注意：这里的class和new()两个约束条件是能倒过来，先写new()再写class的，因为，我们是现先有了类，才能有构造函数的</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span>:<span class="hljs-keyword">class</span>, <span class="hljs-title">new</span>()&#123;<br>    <br>&#125;<br><span class="hljs-comment">// 给个建议：泛型约束的组合使用根据排列组合可以拥有很多种组合方式，这里不一一的列举，我们可以在编辑器是自行尝试，只要是编辑器不报错误都算是一种约束的组合。</span><br></code></pre></td></tr></table></figure><h6 id="多个泛型有约束"><a href="#多个泛型有约束" class="headerlink" title="多个泛型有约束"></a>多个泛型有约束</h6><p>举个例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">// 注意：多个泛型的约束是一个空格隔开，几个泛型字母就写几个where关键字，不要乱加逗号、冒号</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">K</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span>:<span class="hljs-keyword">class</span>, <span class="hljs-title">new</span>() <span class="hljs-keyword">where</span> <span class="hljs-title">K</span>:<span class="hljs-title">struct</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>泛型约束：让类型有一定限制</p><p>泛型约束的分类：class、struct、new()、类名、接口名、另一个泛型字母</p><p>注意：</p><p>1.可以组合使用</p><p>2.多个泛型约束用where连接即可</p>]]></content>
    
    
    <categories>
      
      <category>CSharp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射与特性</title>
    <link href="/2023/03/04/CSharp/%E5%8F%8D%E5%B0%84%E4%B8%8E%E7%89%B9%E6%80%A7/"/>
    <url>/2023/03/04/CSharp/%E5%8F%8D%E5%B0%84%E4%B8%8E%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><h6 id="程序集"><a href="#程序集" class="headerlink" title="程序集"></a>程序集</h6><p>程序集是经由编译器编译得到的，供进一步编译执行的之间产物。在Windows系统中，它一般表现为后缀为.<strong>dl</strong>l(库文件)或者.<strong>exe</strong>(可执行文件)的格式。</p><p>简单理解：<strong>程序集</strong>就是我们写的一个<strong>代码集合</strong>，我们现在写的所有代码最终都会被编译器翻译为一个程序集供给他人使用，比如一个代码库文件(dll)或者一个可执行文件(exe)。</p><h6 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h6><p>元数据就是用来描述数据的数据。这个概念不仅仅用于程序，在别的领域也有元数据。</p><p>简单理解：程序中的类，类中的函数，变量等等信息就是程序的元数据，有关程序以及类型的数据被称为元数据，它们保存在程序集中。</p><h6 id="反射-1"><a href="#反射-1" class="headerlink" title="反射"></a>反射</h6><p>而程序在运行过程中可以查看其他程序集或者自身的元数据。一个<strong>正在运行</strong>的程序<strong>查看本身或者其他程序的元数据</strong>的行为就叫反射。</p><p>简单理解：在程序运行时候，通过反射可以得到其他程序集或者自己程序集代码的各种信息，例如：类、函数、变量、对象等等，实例化它们，执行它们，操作它们。</p><p>反射常常与接口、依赖反转原则一起使用。反射事实上是.Net框架的内容，不是C#语言的内容。同时，单元测试、依赖注入、泛型编程，都基于反射机制。</p><p>给我一个对象，我能在不知道它是什么静态类型，且不使用new操作符的情况下，再创建出一个与它同类型的新对象，并且能够访问其方法。</p><p>简单为</p><ul><li>程序运行时得到所有元数据，包括元数据的特效</li><li>程序运行时，实例化对象，操作对象</li><li>程序运行时创建新对象，用这些对象执行任务</li></ul><p>使用new操作符，即是创造了一个紧耦合，直接地将所在类与new后的静态类型紧耦合在了一起。而使用反射，直接避免紧耦合的发生，降低了耦合度。</p><p>另一方面，在具体的工程中，在编写程序阶段，因为用户的请求很多变，你很难预测用户需求，不可能写成百上千的if-else语句使用静态的类型枚举出所有可能结果。这就体现了反射的动态效果。反射是在编写程序阶段，不确定具体逻辑的时候存在的。程序需要以不变应万变的能力，这个能力就是反射。</p><p>语法相关</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-number">1.</span>Type<br>使用type的成员获取有关类型声明的信息，有关类型的成员（构造函数 方法 字段 属性 类的事件）<br><span class="hljs-number">2.</span>GetType<br>   Object的GetType()可以获取对象的Type  通过类和结构体的名字也可以获取类型 <br>   ps 类名或者结构体名字必须包含命名空间<br>   例 Type type3 = Type.GetType(<span class="hljs-string">&quot;System.Int32&quot;</span>);<br>   <span class="hljs-keyword">typeof</span>()关键字传入类名也可以得到对象的Type <br>   ps：每个类都是唯一的，地址也是唯一的，所以每个Type指向的地址都是同一个地址<br><span class="hljs-number">3.</span>type.Assembly<br>得到类的程序集信息<br><span class="hljs-number">4.</span> GetMembers<br>获取类中的所有公共公开的成员  <br>ps 命名空间 <span class="hljs-keyword">using</span> System.Reflection<br><span class="hljs-number">5.</span>GetConstructors();<br>    获取类的公共构造函数 Type t =tperof（类）<br>    ConstructorInfo[] ctors = t.GetConstructors();<br><span class="hljs-number">6.</span>GetFields<br>    获取类的公共成员变量<br><span class="hljs-number">7.</span>通过Type类中的GetMethod方法得到类中的方法，MethodInfo是方法的反射信息<br><br>其他<br>    获取枚举：GetEnumName,GetEnumNames<br>    获取事件：GetEvent,GetEvents<br>    获取接口：GetInterface,GetInterfaces<br>    获取属性：GetProperty,GetPropertys<br></code></pre></td></tr></table></figure><p>我们回到接口Tank的例子 通过反射，我们没有动任何的静态类型，完全从内存里读取类型的描述和方法的描述调用</p><img src="/2023/03/04/CSharp/%E5%8F%8D%E5%B0%84%E4%B8%8E%E7%89%B9%E6%80%A7/image-20230305193729561.png" class="" title="image-20230305193729561"><p>但是一般不会直接使用反射，而是会使用封装好了的反射。而封装好了的反射最重要的功能就是依赖注入。</p><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>依赖注入框架包Microsoft.Extensions.DependencyInjection  </p><p>依赖注入是依赖反射原则DIP的一个应用；<br>不用静态创建类的实例，只关注用了哪种接口和哪种类就可以获取类的成员</p><p>依赖注入最重要的是<strong>容器container</strong>，即sevice provider。其中装着很多类型和对应的接口，要实例的时候就向他要就行。</p><img src="/2023/03/04/CSharp/%E5%8F%8D%E5%B0%84%E4%B8%8E%E7%89%B9%E6%80%A7/image-20230305202421288.png" class="" title="image-20230305202421288"><p>这样做的好处是什么呢？比如说程序有一个地方要改，不要heavytank了，全部变成lighttank。这时候如果用new操作符，就得改多处，而且还不能用一键替换，因为你不知道哪里要改哪里不用改。如果使用这样的封装反射，就只用改第二行就行。</p><p>但是依赖注入的强大不止于此</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> serviceCollection = <span class="hljs-keyword">new</span> ServiceCollection();<span class="hljs-comment">//容器</span><br>        serviceCollection.AddScoped(<span class="hljs-keyword">typeof</span>(ITank), <span class="hljs-keyword">typeof</span>(HeavyTank));<br>        serviceCollection.AddScoped(<span class="hljs-keyword">typeof</span>(IVehicle), <span class="hljs-keyword">typeof</span>(Car));<br>        serviceCollection.AddScoped&lt;Driver&gt;();<br>        <span class="hljs-comment">//typeof拿到动态类型描述;第一个参数是接口类型，第二个是实现接口类型的类型。</span><br>        <span class="hljs-keyword">var</span> serviceProvider = serviceCollection.BuildServiceProvider();<br>        <span class="hljs-comment">//-----------------一次性的注册-------------------------------</span><br>        <span class="hljs-keyword">var</span> driver = serviceProvider.GetService&lt;Driver&gt;();<br>        driver.Drive();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Driver</span><br>&#123;<br>    <span class="hljs-keyword">private</span> IVehicle _vehicle;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Driver</span>(<span class="hljs-params">IVehicle vehicle</span>)</span><br>    &#123;<br>        _vehicle = vehicle;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Drive</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;I am driving a &#123;0&#125;.&quot;</span>,_vehicle.GetType().Name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Driver这个类本来要求产生实例时需要构造传入一个IVehicle，现在没传。容器会自动帮你在它已有的类型里面找到一个IVehicle接口的类，然后帮你自动创造一个实例传进去。比如这里就传进去了一个Car。</p><h4 id="Assembly"><a href="#Assembly" class="headerlink" title="Assembly"></a>Assembly</h4><p>程序集类，主要用于加载其他程序集，加载后才能用Type来使用其他程序集中的信息，如果想要使用不是自己程序集中的内容，需要先加载程序集，比如：dll文件（库文件）。简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或者类。</p><p>三种加载程序集的函数：</p><p>1.一般用来加载在同一文件下的其他程序集：Assembly asembly2 &#x3D; Assembly.LoadFrom(“包含程序集清单的文件的名称或者路径”);</p><p>2.一般用来加载不在同一文件下的其他程序集：</p><p>Assembly asembly &#x3D; Assembly.LoadFrom(“包含程序集清单的文件的名称或者路径”);</p><p>Assembly asembly3 &#x3D; Assembly.LoadFile(“要加载的文件的完全限定路径”);</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">// 1.先加载一个指定程序集</span><br><span class="hljs-comment">// 需要引用命名空间 System.Reflection;</span><br>Assembly asembly = Assembly.LoadFrom(<span class="hljs-string">@&quot;xxx\xxx\xxx\xxx\xxx.dll&quot;</span>);<br>Type[] types = asembly.GetTypes();<span class="hljs-comment">// 获取我们程序集中的所有类型</span><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; types.Length; i++)&#123;<br>    Console.WriteLine(types[i]); <span class="hljs-comment">// 打印我们反射中存储的所有的类型</span><br>&#125;<br><br><span class="hljs-comment">// 2.再加载程序集中的一个类对象，之后才能使用反射</span><br>Type icon = asembly.GetType(<span class="hljs-string">&quot;XXXX.类对象名字&quot;</span>);<br>MemberInfo[] members = icon.GetMembers();<span class="hljs-comment">// 得到我们icon中存储的所有成员</span><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i&lt; members.Length; i++)&#123;<br>    Console.WriteLine(members[i]);<br>&#125;<br><br><span class="hljs-comment">// 3.类库(dll库文件)工程创建</span><br>解决方案资源管理器-&gt;随便一个项目右键-&gt;添加-&gt;新建项目-&gt;选择类库(C<span class="hljs-meta"># .Net FrameWork)</span><br><br>作用：我们的类库文件一般是运行不了的，一般是用于给我们纯写逻辑代码和算法代码供给他人所用的，它内部不需要Main()方法的，我们一般写好之后，在解决方案资源管理器-&gt;点击项目名-&gt;右键-&gt;生成，然后我们就可以在我们的项目的文件夹下面找到我们的项目文件夹-&gt;bin-&gt;Debug就可以看到外面的两个文件一个是.dll，还有一个是.pdb。然后我们就可以用我们反射的知识去引用我们的dll文件。<br><br></code></pre></td></tr></table></figure><p>用于快速实例化对象的类，用于将Type对象快捷实例化为对象，先得到Type，然后快速实例化出一个对象。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C#">Type testType = <span class="hljs-keyword">typeof</span>(Test);<br><span class="hljs-comment">// 1.无参构造</span><br>Test testObj = Activator.CreateInstance(testType) <span class="hljs-keyword">as</span> Test;<br>Console.WriteLine(testObj.str);<br><span class="hljs-comment">// 2.有参数构造</span><br><span class="hljs-comment">// 得到一个参数的构造函数的实例</span><br><span class="hljs-comment">// 参数1 反射， 参数2 我们的构造函数参数列表</span><br>testObj = Activator.CreateInstance(testType, <span class="hljs-number">99</span>) <span class="hljs-keyword">as</span> Test;<br>Console.WriteLine(testObj.j);<br><span class="hljs-comment">// 我们再试试获取两个参数构造函数的实例</span><br>testObj = Activator.CreateInstance(testType, <span class="hljs-number">55</span>, <span class="hljs-string">&quot;111222&quot;</span>) <span class="hljs-keyword">as</span> Test;<br>Console.WriteLine(testObj.j);<br><span class="hljs-comment">// 注意：我们不能传入我们没有实现的构造函数，如果我们传入了我们没有实现的构造函数，运行后会直接报错。</span><br></code></pre></td></tr></table></figure><h4 id="反射总结"><a href="#反射总结" class="headerlink" title="反射总结"></a>反射总结</h4><p>反射：在程序运行时，通过反射可以得到其他程序集或者自己的程序集代码的各种信息，类、函数、变量、对象等等，实例化它们，执行它们，操作它们。</p><p>关键类：Type、Assembly、Activator。</p><p>为什么学习反射？Unity引擎的基本工作机制就是建立在反射的基础上的，学习反射是为了之后学习Unity引擎的基本工作原理做铺垫。</p><h4 id="3-特性"><a href="#3-特性" class="headerlink" title="3.特性"></a>3.特性</h4><h5 id="3-1特性是什么？"><a href="#3-1特性是什么？" class="headerlink" title="3.1特性是什么？"></a>3.1特性是什么？</h5><p>特性是一种允许我们向程序的程序集添加元数据的语言结构，它是用于保存程序结构信息的某种特殊类型的类。</p><p>特性提供功能强大的方法以将声明信息与C#代码（类型、方法、属性等）相关联。</p><p>特性与程序实体关联后，即可在运行时使用反射查询特性信息。</p><p>特性的目的是告诉编译器把程序结构的某组元数据嵌入程序集中，它可以放置在几乎所有的声明中（类、变量、函数等等申明）。</p><p>简单理解：特性本质是一个类，我们可以利用特性类为元数据添加额外信息，比如一个类、成员变量、成员方法等等为他们添加更多的额外信息，之后可以通过反射来获取得到这些额外信息。</p><h5 id="3-2自定义特性"><a href="#3-2自定义特性" class="headerlink" title="3.2自定义特性"></a>3.2自定义特性</h5><p>在上面我们讲解了特性的本质就是一个类，那么我们只需要先去申明一个类，然后让这个类基础至特性基类Attribute就可以了。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCustomAttribute</span> : <span class="hljs-title">Attribute</span>&#123;<br>    <span class="hljs-comment">// 这个类的内容其实就是让你最后变成一个元数据的，方便外部利用反射引用的。</span><br><span class="hljs-comment">// 特性中的成员</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> info;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyCustomAttribute</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> info</span>)</span>&#123;<br>        <span class="hljs-keyword">this</span>.info = info;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TestFun</span>()</span>&#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;特性的方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-3特性的使用"><a href="#3-3特性的使用" class="headerlink" title="3.3特性的使用"></a>3.3特性的使用</h5><p>基本语法：[特性名（参数列表）]，本质上就是在调用特性类的构造函数。</p><p>写在哪里?类、函数、变量上一行，表示他们具有该特性信息。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">// 我们使用我们上一个知识点申明的特性</span><br><span class="hljs-comment">// 注意：系统会默认帮我们省略了类名后面的Attribute</span><br><span class="hljs-comment">// 参数列表里面根据我们的构造函数的参数列表传入参数</span><br>[<span class="hljs-meta">MyCustom(<span class="hljs-string">&quot;这是我自己写的一个用于计算的类&quot;</span>)</span>]<br><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&#123;<br>    [<span class="hljs-meta">MyCustom(<span class="hljs-string">&quot;这是一个成员变量&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span>;<br>    [<span class="hljs-meta">MyCustom(<span class="hljs-string">&quot;这是一个用于计算加法的函数&quot;</span>)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TestFun</span>(<span class="hljs-params">[MyCustom(<span class="hljs-string">&quot;函数参数&quot;</span><span class="hljs-built_in">int</span> a</span>)])</span>&#123;<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 特性的作用就是添加额外的信息，当我们通过反射得到这些成员的时候，我们可以获取到特性的信息来知道成员的用法。</span><br><span class="hljs-comment">// 举例：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span>&#123;<br>        <span class="hljs-comment">// 特性的使用</span><br>        MyClass mc = <span class="hljs-keyword">new</span> MyClass();<br>        <span class="hljs-comment">// 得到Type的三种方法</span><br>        <span class="hljs-comment">// 1.Type t = mc.GetType();</span><br>        <span class="hljs-comment">// 2.t = typeof(MyClass);</span><br>        <span class="hljs-comment">// 3.t = Type.GetType(命名空间名字.MyClass)</span><br>        Type t = mc.GetType();<br>        <br>        <span class="hljs-comment">// 判断是否使用了某个特性</span><br>        <span class="hljs-comment">// 参数一：特性的类型</span><br>        <span class="hljs-comment">// 参数二：代表是否搜索继承链（属性和事件忽略此参数）</span><br>        <span class="hljs-comment">// 注意这个方法只是判断类是否使用了特性，类里面的成员是该方法无法判断</span><br>        <span class="hljs-keyword">if</span>(t.IsDefined(<span class="hljs-keyword">typeof</span>(MyCustomAtrribute)), <span class="hljs-literal">false</span>)&#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;该类型应用了MyCustom特性&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 获取Type元数据中的所有特性</span><br>        <span class="hljs-built_in">object</span>[] array = t.GetCustomAttribute(<span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; array.Length; i++)&#123;<br><span class="hljs-keyword">if</span>(array[i] <span class="hljs-keyword">is</span> MyCustomAttribute)&#123;<br>Console.WriteLine((array[i] <span class="hljs-keyword">as</span> MyCustomAttribute).info);<br>                <span class="hljs-comment">// 因为特性的本质就是一个类，所以我们甚至可以调用其中的方法</span><br>                (array[i] <span class="hljs-keyword">as</span> MyCustomAttribute).TestFun();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-4限制自定义特性的使用范围"><a href="#3-4限制自定义特性的使用范围" class="headerlink" title="3.4限制自定义特性的使用范围"></a>3.4限制自定义特性的使用范围</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">// 通过为特性类加特性限制其使用范围</span><br>[<span class="hljs-meta">AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = true, Inherited = true)</span>]<br><span class="hljs-comment">// 参数一：AttributeTargets-----特性能够用在哪些地方</span><br><span class="hljs-comment">// 参数二：AllowMultiple-----是否允许多个特性实例用在同一个目标上</span><br><span class="hljs-comment">// 参数三：Inherited-----特性是否能被派生类和重写成员继承</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyCustom2Attribute</span> : <span class="hljs-title">Attribute</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-5系统自带特性——过时特性"><a href="#3-5系统自带特性——过时特性" class="headerlink" title="3.5系统自带特性——过时特性"></a>3.5系统自带特性——过时特性</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">// 过时特性-----Obsolete，用于提示用户使用的方法等成员已经过时，建议使用新方法，一般加在函数前的特性</span><br>Class TestClass&#123;<br>    <span class="hljs-comment">// 参数一：调用过时方法时提升的内容</span><br>    <span class="hljs-comment">// 参数二：true-使用该方法会报错(编译之前就会报错)，false-使用该方法自己报警告</span><br>    [<span class="hljs-meta">Obsolete(<span class="hljs-string">&quot;OldSpeak方法已经过时了，请使用Speak方法&quot;</span>), false</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OldSpeak</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> str</span>)</span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-6系统自带特性——调用者信息特性"><a href="#3-6系统自带特性——调用者信息特性" class="headerlink" title="3.6系统自带特性——调用者信息特性"></a>3.6系统自带特性——调用者信息特性</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">// 哪个文件调用?</span><br>CallerFilePath特性<br><span class="hljs-comment">// 哪一行调用？</span><br>CallerLineNumber特性<br><span class="hljs-comment">// 哪一个函数调用？</span><br>CallerMemberName特性<br><br><span class="hljs-comment">// 需要引用命名空间 using System.Runtime.CompilerServices;</span><br><span class="hljs-comment">// 一般作为函数参数的特性</span><br><span class="hljs-comment">// 举例：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&#123;<br>    <span class="hljs-comment">// 注意：我们的调用者信息特性后面是需要有一个默认值的，不然会报错误</span><br>    <span class="hljs-comment">// 特性的默认值也可以让用户在调用函数的时候，指定传入，一般如果没有在调用函数的时候传值，系统会帮我们传入默认值：该文件的路径、该语句的行数、哪个函数在调用该函数。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TestFun</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> str, [CallerFilePath]<span class="hljs-built_in">string</span> fileName = <span class="hljs-string">&quot;&quot;</span>, [CallerLineNumber]<span class="hljs-built_in">int</span> line = <span class="hljs-number">0</span>, [CallerMemberName]<span class="hljs-built_in">string</span> target = <span class="hljs-string">&quot;&quot;</span></span>)</span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-7系统自带特性——条件编译特性"><a href="#3-7系统自带特性——条件编译特性" class="headerlink" title="3.7系统自带特性——条件编译特性"></a>3.7系统自带特性——条件编译特性</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">// 条件编译特性-----Conditional </span><br><span class="hljs-comment">// 它会和预处理指令 #define配合使用，使用之前需要引用命名空间 using System.Diagnostics;</span><br><span class="hljs-comment">// 主要可以用在一些调式代码上，有时想执行有时不想执行的代码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;<br>    <span class="hljs-comment">// 注意：一旦我们加了条件编译特性，那么下面这个静态方法Fun()就需要我们预先定义了#define Fun才可以使用，或者说Main()里面的Fun();才会被执行</span><br>    [<span class="hljs-meta">Conditional(<span class="hljs-string">&quot;Fun&quot;</span>)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> Static <span class="hljs-title">Fun</span>()</span>&#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Fun&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">static</span> <span class="hljs-title">Main</span>()</span>&#123;<br>        Fun();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-8系统自带特性——外部Dll包函数特性"><a href="#3-8系统自带特性——外部Dll包函数特性" class="headerlink" title="3.8系统自带特性——外部Dll包函数特性"></a>3.8系统自带特性——外部Dll包函数特性</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">// DllImport</span><br><span class="hljs-comment">// 用来标记非.Net(C#)的函数，表明该函数在一个外部的DLL中定义。</span><br><span class="hljs-comment">// 一般用来调用C或者C++的Dll包写好的方法，需要引用命名空间 using System.Runtime.InteropServices;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">static</span> <span class="hljs-title">Main</span>()</span>&#123;<br>        [<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;Test.dll&quot;</span>)</span>]<br>        <span class="hljs-comment">// 这句代码是把我们Test.dll包中与下面这个函数一定是存在着一模一样的函数，把C\C++中这个一模一样的函数映射到这个函数中</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="特性总结"><a href="#特性总结" class="headerlink" title="特性总结"></a>特性总结</h5><p>特性是用于为元数据再添加更多的额外信息（变量、方法等等），我们可以通过反射获取这些额外的数据来进行一些特殊的处理。</p><p>自定义特性—继承Attribute类</p><p>系统自带特性：过时特性</p><p>反射和特性的学习是为了之后Unity引擎学习的，因为Unity引擎中很多地方都用到了特性来进行一些特殊处理。</p>]]></content>
    
    
    <categories>
      
      <category>CSharp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>反射</tag>
      
      <tag>特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Interface，Abstract</title>
    <link href="/2023/03/03/CSharp/Interface%EF%BC%8CAbstract/"/>
    <url>/2023/03/03/CSharp/Interface%EF%BC%8CAbstract/</url>
    
    <content type="html"><![CDATA[<h4 id="多态和VOB"><a href="#多态和VOB" class="headerlink" title="多态和VOB"></a>多态和VOB</h4><p>让继承同一父类的子类们在执行相同方法时候有不同的表现(状态)，主要目的是同一父类的对象执行相同行为(方法)有不同的表现，主要的解决的问题是让同一对象具有唯一行为的特征。</p><p>V- virtual (虚函数)  O - override (重写)  B -base (父类)</p><img src="/2023/03/03/CSharp/Interface%EF%BC%8CAbstract/VOB.png" class="" title="VOB"><h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><p>抽象类 被关键字 abstract 修饰的类</p><ol><li>具体类 -&gt; 抽象类 -&gt;接口 越来越抽象，内部所实现的东西越来越少</li><li>抽象类是未完全实现逻辑的类,(可以有字段和非public成员，代表了具体逻辑)</li><li>为复用而生 专门做基类使用，具有解耦功能 封装确定的，开放不确定的，推迟到合适的子类中实现</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Ball</span> <br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Stop</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Stop&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//解决方法        </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> type</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(type==<span class="hljs-string">&quot;Basketball&quot;</span>)<br>        Console.WriteLine(<span class="hljs-string">&quot;Basket ball running&quot;</span>);<br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type==<span class="hljs-string">&quot;Football&quot;</span>)<br>        Console.WriteLine(<span class="hljs-string">&quot;Basket ball running&quot;</span>);<br>    &#125;<br>    <br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Basketball</span> : <span class="hljs-title">Ball</span><br>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Basket ball running&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Football</span> : <span class="hljs-title">Ball</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Football ball running&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这种情况下，然后想用多态的话，只能调用到Stop方法，调用不到Run，因为在基类没有Run方法，可以用上面解决方法解决，但这种写法违反了开闭原则，让新功能的添加不方便。所以我们使用虚方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>()</span><br> &#123;<span class="hljs-comment">//子类重写记得override</span><br>     Console.WriteLine(<span class="hljs-string">&quot;running&quot;</span>);<br> &#125;<br>同时也可以去掉方法体变纯虚方法<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>()</span>;<br></code></pre></td></tr></table></figure><p>同时类也就变成了抽象类，在这种情况下，<strong>新建一个类派生于抽象类的时候，就必须实现抽象方法</strong></p><p>抽象类，专为做基类而生，不能为基类创造实例，在这种情况下，我们就需要一个纯的抽象类</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ballBase</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Stop</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是一个特别抽象到抽象到具体的一个情况，同时呢这个在实际上就是一个接口</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//具体类-&gt;抽象类-&gt;接口 内部实现的东西越来越少 抽象类是未完全实现逻辑的类 为复用而生</span><br><span class="hljs-comment">//接口是完全未实现逻辑的类</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title">IBall</span><br>&#123;<br>    <span class="hljs-comment">//接口成员都是隐式Public 纯虚类 只有成员</span><br>    <span class="hljs-comment">//接口本身就包含了纯抽象的含义，在实现过程中override也要去掉</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Stop</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h4><ul><li>接口是未完全实现逻辑的类(纯虚类，只有函数成员，全部是隐式Public) 为解耦 </li><li>接口是行为的抽象规范；它也是一种自定义类型。</li><li>都不能实例化，只能用来声明变量，引用具体类的实例 类可以继承多个接口，必须实现所有接口成员</li><li>自底向上(重构)，自顶而下(设计)</li><li>接口可以被显示实现，主要用于实现不同接口中的同名函数的不同表现</li><li>实现的接口方法可以加virtual关键字之后子类再去重写</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InterfaceEngine</span><br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> engine = <span class="hljs-keyword">new</span> Engine();<br>        <span class="hljs-keyword">var</span> car = <span class="hljs-keyword">new</span> Car(engine);<br>        car.Run(<span class="hljs-number">3</span>);<br>        Console.WriteLine(car.Speed);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Engine</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> RPM &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Work</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> gas</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.RPM = <span class="hljs-number">1000</span> * gas;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Engine _engine;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span>(<span class="hljs-params">Engine engine</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>._engine = engine;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Speed &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> gas</span>)</span><br>    &#123;<br>        _engine.Work(gas);<br>        <span class="hljs-keyword">this</span>.Speed = _engine.RPM / <span class="hljs-number">100</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子我们会发现，代码之间紧耦合，car依赖的engine类如果出现修改的话，car也会跟着出现问题，这不是我们希望看到的。解决这个问题的办法就是引入接口，降低代码之间的耦合度。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InterfacePhone</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> user = <span class="hljs-keyword">new</span> PhoneUser(<span class="hljs-keyword">new</span> NokiaPhone());<br>        user.UserPhone();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">PhoneUser</span><br>&#123;<br>    <span class="hljs-keyword">private</span> IPhone _phone;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PhoneUser</span>(<span class="hljs-params">IPhone phone</span>)</span><br>    &#123;<br>        _phone = phone;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UserPhone</span>()</span><br>    &#123;<br>        _phone.Dail();<br>        _phone.PickUp();<br>        _phone.Send();<br>        _phone.Receive();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title">IPhone</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dail</span>()</span>;<span class="hljs-comment">//拨号</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PickUp</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Send</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Receive</span>()</span>;<span class="hljs-comment">//接收</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">NokiaPhone</span>:<span class="hljs-title">IPhone</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dail</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Nokia 拨号中&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PickUp</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Nokia 诺基亚&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Send</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Nokia 消息发送中&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Receive</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Nokia 接收&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">VivoPhone</span>:<span class="hljs-title">IPhone</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dail</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Vivo 拨号中&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PickUp</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Vivo 诺基亚&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Send</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Vivo 消息发送中&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Receive</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Vivo 接收&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在接口的写法下，我们如果想更换使用类，只需要更换实例就可以依旧实现相同的功能。</p><p><strong>在代码中，如果有可以替换的存在，就一定会有接口的存在</strong></p><p>PS：当类实现一个接口的时候，类与接口之间的关系也是”紧耦合”</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InterfaceSupply</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> fan = <span class="hljs-keyword">new</span> DeskFan(<span class="hljs-keyword">new</span> PowerSupply());<br>        Console.WriteLine(fan.Work());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//电源</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">PowerSupply</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetPower</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">150</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">DeskFan</span><br>&#123;<br>    <span class="hljs-keyword">private</span> PowerSupply _powerSupply;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DeskFan</span>(<span class="hljs-params">PowerSupply powerSupply</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>._powerSupply = powerSupply;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">Work</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> power = _powerSupply.GetPower();<br>        <span class="hljs-keyword">if</span> (power &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;不能工作，没电&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (power &lt; <span class="hljs-number">100</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;电不够&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (power &lt; <span class="hljs-number">200</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;可以工作&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;警告，电流太大&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，电源的值是固定的，那么如果在另外的电器的电源需要的值更大，那么很可能就会影响到电扇的使用。代码耦合我们可以使用接口来解耦</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InterfaceSupply</span><br>   &#123;<br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>       &#123;<br>           <span class="hljs-keyword">var</span> fan = <span class="hljs-keyword">new</span> DeskFan(<span class="hljs-keyword">new</span> PowerSupply());<br>           <span class="hljs-keyword">var</span> fan2 = <span class="hljs-keyword">new</span> DeskFan(<span class="hljs-keyword">new</span> PowerSupply());<br>           Console.WriteLine(fan.Work());<br>           Console.WriteLine(fan2.Work());<br>       &#125;<br>   &#125;<br>   <span class="hljs-keyword">interface</span> <span class="hljs-title">IPowerSupply</span><br>   &#123;<br>       <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">GetPower</span>()</span>;<br>   &#125;<br>   <br>   <span class="hljs-comment">//电源1</span><br>   <span class="hljs-keyword">class</span> <span class="hljs-title">PowerSupply</span>: <span class="hljs-title">IPowerSupply</span><br>   &#123;<br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetPower</span>()</span><br>       &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">150</span>;<br>       &#125;<br>   &#125;<br>   <span class="hljs-comment">//电源2</span><br>   <span class="hljs-keyword">class</span> <span class="hljs-title">PowerSupply2</span>: <span class="hljs-title">IPowerSupply</span><br>   &#123;<br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetPower</span>()</span><br>       &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">260</span>;<br>       &#125;<br>   &#125;<br>   <span class="hljs-keyword">class</span> <span class="hljs-title">DeskFan</span><br>   &#123;<br>       <span class="hljs-keyword">private</span> IPowerSupply _powerSupply;<br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DeskFan</span>(<span class="hljs-params">IPowerSupply powerSupply</span>)</span><br>       &#123;<br>           <span class="hljs-keyword">this</span>._powerSupply = powerSupply;<br>       &#125;<br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">Work</span>()</span><br>       &#123;<br>           <span class="hljs-built_in">int</span> power = _powerSupply.GetPower();<br>           <span class="hljs-keyword">if</span> (power &lt;= <span class="hljs-number">0</span>)<br>           &#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;不能工作，没电&quot;</span>;<br>           &#125;<br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (power &lt; <span class="hljs-number">100</span>)<br>           &#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;电不够&quot;</span>;<br>           &#125;<br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (power &lt; <span class="hljs-number">200</span>)<br>           &#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;可以工作&quot;</span>;<br>           &#125;<br>           <span class="hljs-keyword">else</span><br>           &#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;警告，电流太大&quot;</span>;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h5 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h5><p>抽象类和抽象方法：abstract修饰的类和方法，抽象类不能实例化，抽象方法只能在抽象类中申明，是个纯虚方法，必须在子类中实现</p><p>接口：interface自定义类型，是行为的抽象，不包含成员变量，仅包含方法、属性、索引器、事件、成员都不能实现，建议不写访问修饰符，默认public。</p><p><strong>相同点</strong></p><ul><li>都可以被继承</li><li>都不能被直接实例化</li><li>都可以包含方法申明</li><li>子类必须实现未实现的方法</li><li>都遵循里氏替换原则</li></ul><p><strong>不同点</strong></p><ul><li><p>抽象类中可以有构造函数；接口不行</p></li><li><p>抽象类只能被单一继承；接口可以被继承多个</p></li><li><p>抽象类中可以有成员变量；接口不能</p></li><li><p>抽象类中可以申明成员方法，虚方法，抽象方法，静态方法；接口中只能申明没有实现的抽象方法</p></li><li><p>抽象类方法可以使用访问修饰符；接口中建议不写，默认public</p></li></ul><h5 id="如何选择抽象类和接口"><a href="#如何选择抽象类和接口" class="headerlink" title="如何选择抽象类和接口"></a>如何选择抽象类和接口</h5><p>表示对象的用抽象类，表示拓展的用接口，不同对象拥有的共同行为，我们往往可以使用接口来实现。</p><p>举个例子：</p><p>动物是一类对象，我们自然会选择抽象类；而飞翔是一个行为，我们自然会选择接口。</p><h5 id="密封方法"><a href="#密封方法" class="headerlink" title="密封方法"></a>密封方法</h5><p>概念：用密封关键字sealed修饰的重写函数</p><p>作用：让虚方法或者抽象方法之后不能再被重写</p><p>特点：和override一起出现</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>  &#123;<br>      <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> name;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Eat</span>()</span>;<br><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span><br>      &#123;<br>          Console.WriteLine(<span class="hljs-string">&quot;吃&quot;</span>);<br>      &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> : <span class="hljs-title">Animal</span><br>  &#123;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Eat</span>()</span><br>      &#123;<br>      &#125;<br><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span><br>      &#123;<br>      &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">class</span> <span class="hljs-title">WhitePerson</span> : <span class="hljs-title">Peron</span><br>  &#123;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Eat</span>()</span><br>      &#123;<br>      &#125;<br><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span><br>      &#123;<br>      &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> : <span class="hljs-title">WhitePerson</span><br>  &#123;<br>      <span class="hljs-comment">// 我们会发现无法实现Eat()的方法了，因为父类把Eat()方法用sealed修饰了</span><br>  &#125;<br></code></pre></td></tr></table></figure><h5 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h5><p>我们都知道，接口是一种对供需方均做出了约束的协议。对于供方，“不会少给”很容易做到，因为接口要求供方必须实现其里面的所有方法，否则不能实例化。但对于需方来说，“不会多要”这一点则是软性的。</p><p>需求方应该<strong>全部</strong>用到<strong>提供的接口</strong>里的东西，接口中不能存在一些完全没被用过的方法，即接口不能太大。如果接口太大，可以将其拆分成多个小接口。</p><h6 id="第一种违反接口隔离原则"><a href="#第一种违反接口隔离原则" class="headerlink" title="第一种违反接口隔离原则"></a>第一种违反接口隔离原则</h6><p>将过多的功能包含在接口里，传进来的接口太大，有些方法用不到，故应该分为小接口</p><p> 每个小接口都描述单一的功能，把本质不同的功能隔离开，用接口封装起来</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Interface_isolationTank</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>        &#123;<br>            Driver d = <span class="hljs-keyword">new</span> Driver(<span class="hljs-keyword">new</span> Car());<br>            d.Drive();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Driver</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> IVehicle _vehicle;<br>        <span class="hljs-keyword">private</span> ITank _tank;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Driver</span>(<span class="hljs-params">IVehicle vehicle</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">this</span>._vehicle = vehicle;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Driver</span>(<span class="hljs-params">ITank tank</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">this</span>._tank = tank;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Drive</span>()</span><br>        &#123;<br>            _vehicle.Run();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title">IVehicle</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>()</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title">ITank</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fire</span>()</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>()</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> : <span class="hljs-title">IVehicle</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Car is Running&quot;</span>);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">LightTank</span> :<span class="hljs-title">ITank</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Fire</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;小坦克开火&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;小坦克走&quot;</span>);<br>        &#125;<br>    &#125;<br>   <br>   <br></code></pre></td></tr></table></figure><p>在这个例子中，我们只想把坦克作为代步工具，因而，ITank这个接口里的Fire方法完全用不到。</p><p>而事实上，我们确实可以把坦克这个事物在这个场景的意义下拆分为两方面，一方面是用于行走的轮子，一方面是用于攻击的火炮。因而，我们可以选择把ITank这个接口拆分为两个小接口，让tank全部都接上那两个小接口；</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-keyword">class</span> <span class="hljs-title">Interface_isolationTank</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        IVehicle tank = <span class="hljs-keyword">new</span> HeavyTank();<br>        tank.Run();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title">IVehicle</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>()</span>;<br>&#125;<br> <br> <br><span class="hljs-keyword">interface</span> <span class="hljs-title">IWeapon</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fire</span>()</span>;<br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title">HeavyTank</span> : <span class="hljs-title">IWeapon</span>,<span class="hljs-title">IVehicle</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Fire</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Boom!!!&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;A heavytank is running......&quot;</span>); <br>    &#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure><p>但是请注意，这个也不能使用得太过火了，因为它可能会让只有一个方法的小接口越来越多，颗粒度增加。因而，<strong>应该把类的和接口大小都控制在一个范围内</strong>。</p><h6 id="第二种违反接口隔离原则的"><a href="#第二种违反接口隔离原则的" class="headerlink" title="第二种违反接口隔离原则的"></a>第二种违反接口隔离原则的</h6><p>是一个大接口由两个设计很好的小接口合并，传的时候却传了大接口，这就导致本来会用到的被隔绝在了门外。</p><p>例如平常用到的IEnumerable接口，来源于一个更大的接口ICollection</p><p>我们需要创建一个只接上IEnumerable的接口，而没有接上ICollection接口的类。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InterfaceIsolation</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>        &#123;<br>            <span class="hljs-built_in">int</span>[] nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>            ArrayList nums2 = <span class="hljs-keyword">new</span> ArrayList &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>            Console.WriteLine(Sum(nums));<br>            Console.WriteLine(Sum(nums2));<br>            <span class="hljs-keyword">var</span> nums3 = <span class="hljs-keyword">new</span> ReadOnlyCollection(nums);<br>            Console.WriteLine(Sum(nums3));<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Sum</span>(<span class="hljs-params">IEnumerable nums</span>)</span> <br>        &#123;<br>            <span class="hljs-built_in">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> v <span class="hljs-keyword">in</span> nums)<br>            &#123;<br>                sum += (<span class="hljs-built_in">int</span>) v;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> sum;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//只实现了IEnumerable</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">ReadOnlyCollection</span> : <span class="hljs-title">IEnumerable</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[] _array;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReadOnlyCollection</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">this</span>._array = array;<br>        &#125;<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator <span class="hljs-title">GetEnumerator</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Enumerator(<span class="hljs-keyword">this</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//为了不污染名称空间，成员类</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title">Enumerator</span> : <span class="hljs-title">IEnumerator</span><br>        &#123;<br>            <span class="hljs-keyword">private</span> ReadOnlyCollection _collection;<br><br>            <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> _head;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Enumerator</span>(<span class="hljs-params">ReadOnlyCollection collection</span>)</span><br>            &#123;<br>                <span class="hljs-keyword">this</span>._collection = collection;<br>                _head = <span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">MoveNext</span>()</span><br>            &#123;<br>                <span class="hljs-keyword">if</span> (++_head &lt; _collection._array.Length)<br>                &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Reset</span>()</span><br>            &#123;<br>                _head = <span class="hljs-number">-1</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">object</span> Current<br>            &#123;<br>                <span class="hljs-keyword">get</span><br>                &#123;<span class="hljs-comment">//装箱</span><br>                    <span class="hljs-built_in">object</span> o = _collection._array[_head];<br>                    <span class="hljs-keyword">return</span> o;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>因为传入的是ICollection，把Sum需求者的接口改为ICollection，立马报错，此时你已经把这个IEnumerable拒之门外了。</p><p>我们知道，这个功能只需要可迭代就行了。传IEnumerable明显比传ICollection合适。</p><img src="/2023/03/03/CSharp/Interface%EF%BC%8CAbstract/image-20230305164940871.png" class="" title="image-20230305164940871"><p>这就更加符合我们的接口隔离原则，调用者绝不多要，传进来的接口不应该有用不着的功能</p><h6 id="第三个接口隔离的例子"><a href="#第三个接口隔离的例子" class="headerlink" title="第三个接口隔离的例子"></a>第三个接口隔离的例子</h6><p>我们将展现C#语言特有的功能，即<strong>显式接口实现</strong>。</p><p>一个大接口可被拆分成若干个小接口。有没有一个办法，可以让只需要使用这个小接口时，接口的方法才能被看到呢？这个办法就是显式接口实现。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InterfaceIsolation3</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">var</span> wk = <span class="hljs-keyword">new</span> WarmKiller();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title">IGentleman</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Love</span>()</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title">IKiller</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Kill</span>()</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">WarmKiller</span>:<span class="hljs-title">IGentleman</span>,<span class="hljs-title">IKiller</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Love</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;I Love You&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Kill</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;I will kill the enemy.&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们可以看见，在接口的影响下，我们可以看到Kill的方法，对于一个杀手来说，是不应该把Kill的功能暴露出来的</p><img src="/2023/03/03/CSharp/Interface%EF%BC%8CAbstract/image-20230305165740447.png" class="" title="image-20230305165740447"><p>在这种情况下，就应该用到接口的显示实现</p><img src="/2023/03/03/CSharp/Interface%EF%BC%8CAbstract/image-20230305171621173.png" class="" title="image-20230305171621173"><img src="/2023/03/03/CSharp/Interface%EF%BC%8CAbstract/image-20230305171722005.png" class="" title="image-20230305171722005"><p>这个情况下，Kill就被隐藏起来了，只有在用IKiller情况下才能看到Kill</p><img src="/2023/03/03/CSharp/Interface%EF%BC%8CAbstract/image-20230305171843123.png" class="" title="image-20230305171843123"><p>接口隔离原则为接口单一原则提供了判断标准。如果调用者只是用了接口的部分功能(a,b,c 三个方法。系统只用到了a,b),那么说明这个接口不够单一</p><p>接口功能也要单一(如果a方法除了负责加还负责减乘除取余等等,功能不够单一)</p><p>调用者依赖其所需要的，而不依赖其所不需要的</p>]]></content>
    
    
    <categories>
      
      <category>CSharp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSharp</tag>
      
      <tag>编程语言</tag>
      
      <tag>面对对象编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp事件</title>
    <link href="/2023/02/28/CSharp/CSharp%E4%BA%8B%E4%BB%B6/"/>
    <url>/2023/02/28/CSharp/CSharp%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>事件(Event)</p><ol><li>角色， 使对象或类具备通知能力的成员</li><li>事件的功能&#x3D;通知+可选的通知参数</li><li>使用， 用于对象或类间的动作调节与信息传递</li><li>EventHandler委托的参数一般有两个 一个是object类型，名字是sender实际上就是事件的拥有者，事件的soure</li><li>第二个是EventArgs类的派生类 参数为e</li><li>事件的本质是委托字段的一个包装器 对委托字段的访问起限制作用</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">注意 <br>事件处理器是方法成员<br>挂接事件处理器的时候，可以使用委托实例 也可以直接使用方法名<br>事件处理器对事件的订阅不是随意的，匹配与否由声明事件时所使用的委托实例来检测<br>事件可以同步也可以异步<br>事件不管是表层约束还是底层实现来讲，都是依赖于委托类型<br></code></pre></td></tr></table></figure><h4 id="事件模型有五个组成部分"><a href="#事件模型有五个组成部分" class="headerlink" title="事件模型有五个组成部分"></a>事件模型有五个组成部分</h4><ol><li>事件的拥有者 event soure，对象</li><li>事件的成员 event 成员</li><li>事件的响应器 event subscriber，对象</li><li>事件的处理器 event Handler， 成员 —本质上是一个回调方法</li><li>事件订阅 —— 把事件处理器与事件关联在一起，本质上是一种以委托类型为基础的约定</li></ol><h4 id="1-较为简单的事件模型"><a href="#1-较为简单的事件模型" class="headerlink" title="1.较为简单的事件模型"></a>1.较为简单的事件模型</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> <span class="hljs-title">Test.Event</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Event_Handler</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>        &#123;<br>            Timer _timer = <span class="hljs-keyword">new</span> Timer(); <span class="hljs-comment">//事件的拥有者</span><br>            _timer.Interval = <span class="hljs-number">1000</span>;<br>            Boy boy = <span class="hljs-keyword">new</span> Boy();<span class="hljs-comment">//响应者</span><br>            Girl girl = <span class="hljs-keyword">new</span> Girl();<br>            _timer.Elapsed += boy.Action;<span class="hljs-comment">// +=订阅者   Elapsed 事件</span><br>            _timer.Elapsed += girl.Action;<br>            _timer.Start();<br>            Console.ReadLine();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Boy</span><br>    &#123;<br>        <span class="hljs-comment">//事件的处理器</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Action</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, ElapsedEventArgs e</span>)</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Jump&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Girl</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Action</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, ElapsedEventArgs e</span>)</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Sing&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-两个对象之间的事件处理器"><a href="#2-两个对象之间的事件处理器" class="headerlink" title="2.两个对象之间的事件处理器"></a>2.两个对象之间的事件处理器</h4><p>事件响应者（事件处理器）—&gt;（订阅）事件的拥有者(事件)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Windows.Forms;<br><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Test.Event</span><br>&#123;<br>    <span class="hljs-comment">//两个对象之间的事件处理器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Eventone</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>        &#123;<br>            Form form = <span class="hljs-keyword">new</span> Form();<span class="hljs-comment">//拥有者 form</span><br>            Controller c = <span class="hljs-keyword">new</span> Controller(form);<span class="hljs-comment">//响应者 c</span><br>            form.ShowDialog();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Controller</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> Form Form;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Controller</span>(<span class="hljs-params">Form form</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (form!=<span class="hljs-literal">null</span>)<br>            &#123;<br>                <span class="hljs-keyword">this</span>.Form = form;<br>                <span class="hljs-keyword">this</span>.Form.Click += <span class="hljs-keyword">this</span>.FormClicked;<span class="hljs-comment">//事件 和 订阅</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//处理器</span><br>        <span class="hljs-comment">//不能拿影响Elapsed事件的事件处理器去响应Click事件</span><br>        <span class="hljs-comment">//因为遵循的约束不同，所以不通用</span><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FormClicked</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">this</span>.Form.Text = DateTime.Now.ToString();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-事件的拥有者同时也是事件的响应者"><a href="#3-事件的拥有者同时也是事件的响应者" class="headerlink" title="3.事件的拥有者同时也是事件的响应者"></a>3.事件的拥有者同时也是事件的响应者</h4><p>对象xx（事件处理器—&gt; 事件）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EventTow</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>    &#123;<br>        MyForm myForm = <span class="hljs-keyword">new</span> MyForm(); <span class="hljs-comment">//拥有者</span><br>        myForm.Click += myForm.MyFormClicked; <span class="hljs-comment">//事件  响应者是myForm自己 +=订阅</span><br>        myForm.ShowDialog();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//派生: 在原有类的功能的基础上 ，扩展新的功能 </span><br><span class="hljs-keyword">class</span> <span class="hljs-title">MyForm</span>:<span class="hljs-title">Form</span><br>&#123;<br>    <span class="hljs-comment">//处理器</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyFormClicked</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.Text = DateTime.Now.ToString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4.事件的拥有者是事件响应的字段成员</p><img src="/2023/02/28/CSharp/CSharp%E4%BA%8B%E4%BB%B6/sj3.png" class=""><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Test.Event</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Event</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>        &#123;<br>            myForm form = <span class="hljs-keyword">new</span> myForm(); <span class="hljs-comment">//响应</span><br>            form.ShowDialog();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">myForm</span> :<span class="hljs-title">Form</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> TextBox _textBox;<br>        <span class="hljs-keyword">private</span> Button _button; <span class="hljs-comment">//事件拥有者</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">myForm</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">this</span>._textBox = <span class="hljs-keyword">new</span> TextBox();<br>            <span class="hljs-keyword">this</span>._button = <span class="hljs-keyword">new</span> Button();<br>            <span class="hljs-keyword">this</span>.Controls.Add(_textBox);<br>            <span class="hljs-keyword">this</span>.Controls.Add(_button);<br>            <span class="hljs-keyword">this</span>._button.Click += <span class="hljs-keyword">this</span>.BottomClicked; <span class="hljs-comment">//事件 订阅</span><br>            <span class="hljs-keyword">this</span>._button.Text = <span class="hljs-string">&quot;点我&quot;</span>;<br>            <span class="hljs-keyword">this</span>._button.Top = <span class="hljs-number">100</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BottomClicked</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">this</span>._textBox.Text = <span class="hljs-string">&quot;Hello Heart&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><pre><code class="c#">//一个吃饭的事件模拟，多复习namespace Test.Event&#123;    //委托 委托可引用的方法返回值类型  名字+EventHandler后缀 （引用方法的参数列表 1，对象，2 事件信息）    //public delegate void OrderEventHandler(Customer customer, OrderEventArgs e);    public class Event_Eat    &#123;        public static void Test()        &#123;            Customer c = new Customer();            Waiter w = new Waiter();            c.Order += w.Action;            c.Action();            c.PlayBill();        &#125;    &#125;    //传递事件的消息 信息    public class OrderEventArgs : EventArgs    &#123;        public string DishName &#123; get; set; &#125;        public string Size &#123; get; set; &#125;    &#125;    public class Customer    &#123;        //声明事件        /*private OrderEventHandler OrderEventHandler;        public event OrderEventHandler Order        &#123;            //Value是一个重要的关键字            add &#123; this.OrderEventHandler += value; &#125;            remove &#123; this.OrderEventHandler -= value; &#125;        &#125;*/        //简化声明        //public event OrderEventHandler Order;        //两种事件        public event EventHandler Order;        public double Bill &#123; get; set; &#125; //账单        public void PlayBill()        &#123;            Console.WriteLine(&quot;我支付了&#123;0&#125;&quot;, this.Bill);        &#125;        void WalkIn()        &#123;            Console.WriteLine(&quot;走进餐厅&quot;);        &#125;        public void SitDown()        &#123;            Console.WriteLine(&quot;坐下&quot;);        &#125;        public void Think()        &#123;            for (int i = 0; i &lt; 5; i++)            &#123;                Console.WriteLine(&quot;让我想想&quot;);                Thread.Sleep(1000);            &#125;            /*简化声明用这里Order替换             if (this.OrderEventHandler!=null)             &#123;                 OrderEventArgs e = new OrderEventArgs();                 e.DishName = &quot;宫爆鸡丁&quot;;                 e.Size = &quot;large&quot;;                 this.OrderEventHandler.Invoke(this,e);//触发时间的地方             &#125;                         if (this.Order!=null)             &#123;                 OrderEventArgs e = new OrderEventArgs();                 e.DishName = &quot;宫爆鸡丁&quot;;                 e.Size = &quot;large&quot;;                 this.Order.Invoke(this,e);//触发时间的地方             &#125;*/            this.OnOrder(&quot;酸菜鱼&quot;, &quot;大份&quot;);        &#125;        // protected 用来修饰触发事件的方法 不建议为public        //事件的命名尽量用动词       //触发事件        protected void OnOrder(string DishName, string Size)        &#123;            if (this.Order != null)            &#123;                OrderEventArgs e = new OrderEventArgs();                e.DishName = DishName;                e.Size = Size;                this.Order.Invoke(this, e); //触发时间的地方            &#125;        &#125;        //事件触发        public void Action()        &#123;            Console.ReadLine();            this.WalkIn();            this.SitDown();            this.Think();        &#125;    &#125;    public class Waiter    &#123;        /*public void Action(Customer customer, OrderEventArgs e)        &#123;            Console.WriteLine(&quot;上的菜是&#123;0&#125;&quot;, e.DishName);            double price = 10;            switch (e.Size)            &#123;                case &quot;smaill&quot;:                    price = price * 0.5;                    break;                case &quot;large&quot;:                    price = price * 1.5;                    break;                default:                    break;            &#125;            customer.Bill += price;        &#125;*/        public void Action(object sender, EventArgs e)        &#123;            Customer c = sender as Customer;            OrderEventArgs orderEventArgs = e as OrderEventArgs;            Console.WriteLine(&quot;上的菜是&#123;0&#125;&quot;, orderEventArgs.DishName);            double price = 10;            switch (orderEventArgs.Size)            &#123;                case &quot;小份&quot;:                    price = price * 0.5;                    break;                case &quot;大份&quot;:                    price = price * 1.5;                    break;                default:                    break;            &#125;            c.Bill += price;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>CSharp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>花里胡哨</tag>
      
      <tag>CSharp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LcTest2</title>
    <link href="/2022/12/06/Algo/LcTest2/"/>
    <url>/2022/12/06/Algo/LcTest2/</url>
    
    <content type="html"><![CDATA[<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="28-找出字符串中第一个匹配项的下标"><a href="#28-找出字符串中第一个匹配项的下标" class="headerlink" title="28 找出字符串中第一个匹配项的下标"></a>28 找出字符串中第一个匹配项的下标</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">StrStr</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> haystack, <span class="hljs-built_in">string</span> needle</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> h = haystack.Length;<br>    <span class="hljs-built_in">int</span> n = needle.Length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;= h - n; i++)<br>    &#123;<br>        <span class="hljs-built_in">int</span> initI = i; <span class="hljs-comment">//记住第一次相等的元素</span><br>        <span class="hljs-built_in">bool</span> match = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++, i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (haystack[i] != needle[j]) <span class="hljs-comment">//如果位置不相等就把match设为false，相等的话，指针移动</span><br>            &#123;<br>                match = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (match) <span class="hljs-comment">//等字符串遍历完，如果match是true，说明找到了，就把上面记住的位置返回出去，就是第一次相等的位置</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> initI;<br>        &#125;<br><br>        i = initI;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459 重复的子字符串"></a>459 重复的子字符串</h4><img src="/2022/12/06/Algo/LcTest2/image-20221208141513155.png" class="" title="image-20221208141513155"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#"> <span class="hljs-comment">//len最大为l的一半长度，l一定是len的倍数</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">RepeatedSubstringPattern</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span><br> &#123;<br>     <span class="hljs-built_in">int</span> l = s.Length;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> len = <span class="hljs-number">1</span>; len * <span class="hljs-number">2</span> &lt;= l; len++)<br>     &#123;<br>         <span class="hljs-keyword">if</span> (l % len == <span class="hljs-number">0</span>)<br>         &#123;<br>             <span class="hljs-built_in">bool</span> match = <span class="hljs-literal">true</span>;<br>             <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>             <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = len; j &lt; l; j++,i++)<br>             &#123;<br>                 <span class="hljs-keyword">if</span> (s[i] != s[j])<br>                 &#123;<span class="hljs-comment">//如果两个字符不相等就把len+1继续遍历，</span><br>                     <span class="hljs-comment">//相等的话match是true的就返回true</span><br>                     match = <span class="hljs-literal">false</span>;<br>                     <span class="hljs-keyword">break</span>;<br>                 &#125;<br>             &#125;<br>             <span class="hljs-keyword">if</span> (match) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">RepeatedSubstringPattern2</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span><br>&#123;<br>    <span class="hljs-comment">//由重复字符串组成的字符串，选择重复子字符串后会得到本身</span><br>    <span class="hljs-comment">//拼接两个字符，在组成的字符上面判断有没有s ps去掉头部和尾部的元素</span><br>    <span class="hljs-keyword">return</span> (s + s).IndexOf(s, <span class="hljs-number">1</span>) != s.Length;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="345-反转字符串中的元音字母"><a href="#345-反转字符串中的元音字母" class="headerlink" title="345. 反转字符串中的元音字母"></a>345. 反转字符串中的元音字母</h4><img src="/2022/12/06/Algo/LcTest2/image-20221208152741999.png" class="" title="image-20221208152741999"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ReverseVowels</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> n = s.Length;<br>    <span class="hljs-built_in">char</span>[] chars = s.ToCharArray();<br><br>    <span class="hljs-comment">//两个指针，一个从头，一个尾部开始</span><br>    <span class="hljs-built_in">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-comment">//如果左边的指针小于右边的，并且字符串里的元素 没有元音字母就移动指针，有就交换</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; !isVowel(chars[left])) left++;<br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; !isVowel(chars[right])) right--;<br>        <br>        <span class="hljs-built_in">char</span> temp = chars[left];<br>        chars[left] = chars[right];<br>        chars[right] = temp;<br><br>        left++;<br>        right--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(chars);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">isVowel</span>(<span class="hljs-params"><span class="hljs-built_in">char</span> c</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> c == <span class="hljs-string">&#x27;a&#x27;</span> || c == <span class="hljs-string">&#x27;e&#x27;</span> || c == <span class="hljs-string">&#x27;i&#x27;</span> || c == <span class="hljs-string">&#x27;o&#x27;</span> || c == <span class="hljs-string">&#x27;u&#x27;</span> || c == <span class="hljs-string">&#x27;A&#x27;</span> || c == <span class="hljs-string">&#x27;E&#x27;</span> || c == <span class="hljs-string">&#x27;I&#x27;</span> ||<br>           c == <span class="hljs-string">&#x27;O&#x27;</span> || c == <span class="hljs-string">&#x27;U&#x27;</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="1119-删去字符串中的元音"><a href="#1119-删去字符串中的元音" class="headerlink" title="1119 删去字符串中的元音"></a>1119 删去字符串中的元音</h4><img src="/2022/12/06/Algo/LcTest2/image-20221209142243670.png" class="" title="image-20221209142243670"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">RemoveStringVowels</span>(<span class="hljs-params">String s</span>)</span><br>   &#123;<br>       <span class="hljs-comment">//设置一个结果集</span><br>       StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();<br>       <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">in</span> s.ToCharArray() )<br>       &#123;<span class="hljs-comment">//遍历字符床不是元音字母的字符就添加到结果集里</span><br>           <span class="hljs-keyword">if</span> (!isVowel(<span class="hljs-keyword">value</span>)) res.Append(<span class="hljs-keyword">value</span>);<br>       &#125;<br>       <span class="hljs-keyword">return</span> res.ToString();<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">isVowel</span>(<span class="hljs-params"><span class="hljs-built_in">char</span> c</span>)</span><br>   &#123;<br>       <span class="hljs-keyword">return</span> c == <span class="hljs-string">&#x27;a&#x27;</span> || c == <span class="hljs-string">&#x27;e&#x27;</span> || c == <span class="hljs-string">&#x27;i&#x27;</span> || c == <span class="hljs-string">&#x27;o&#x27;</span> || c == <span class="hljs-string">&#x27;u&#x27;</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="541翻转字符串II"><a href="#541翻转字符串II" class="headerlink" title="541翻转字符串II"></a>541翻转字符串II</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ReverseStr</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s, <span class="hljs-built_in">int</span> k</span>)</span><br>&#123;<br>    <span class="hljs-built_in">char</span>[] chars = s.ToCharArray();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> start = <span class="hljs-number">0</span>; start &lt; s.Length; start += <span class="hljs-number">2</span> * k)<br>    &#123;<span class="hljs-comment">//每次遍历跳2K个字符</span><br>        <span class="hljs-built_in">int</span> left = start;<br>        <span class="hljs-comment">//左指针从头，右指针从k的位置上</span><br>        <span class="hljs-comment">//PS:主要是判断后面 k个字符是否超过数组的长度，如果超过，就将后面的所有字符反转</span><br>        <span class="hljs-built_in">int</span> right = Math.Min(left + k - <span class="hljs-number">1</span>, s.Length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span> (left&lt;right)<br>        &#123;<br>            <span class="hljs-built_in">char</span> temp = chars[left];<br>            chars[left] = chars[right];<br>            chars[right] = temp;<br>            left++;<br>            right--;<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(chars);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="557反转字符串中的单词-III"><a href="#557反转字符串中的单词-III" class="headerlink" title="557反转字符串中的单词 III"></a>557反转字符串中的单词 III</h4><img src="/2022/12/06/Algo/LcTest2/image-20221209150855255.png" class="" title="image-20221209150855255"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ReverseWords</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span><br>&#123;<br>    <span class="hljs-built_in">char</span>[] chars = s.ToCharArray();<br>    <span class="hljs-built_in">int</span> n = s.Length;<br><br>    <span class="hljs-built_in">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (left&lt;n)<br>    &#123;<span class="hljs-comment">//不等于空就说明字符的开始</span><br>        <span class="hljs-keyword">if</span> (chars[left]!=<span class="hljs-string">&#x27; &#x27;</span>)<br>        &#123;<br>            <span class="hljs-built_in">int</span> right = left;<br>            <span class="hljs-comment">//如果right前面的元素不是空格就再找到，是空格就说明找到字符的尾部了，翻转字符</span><br>            <span class="hljs-keyword">while</span> (right + <span class="hljs-number">1</span> &lt; n &amp;&amp; chars[right + <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27; &#x27;</span>) right++;<br>            ReverseWord(chars, left, right);<br>            <span class="hljs-comment">//反转完就把left设置到right+1的位置，重复过程</span><br>            left = right + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            left++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(chars);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReverseWord</span>(<span class="hljs-params"><span class="hljs-built_in">char</span>[] chars, <span class="hljs-built_in">int</span> start, <span class="hljs-built_in">int</span> end</span>)</span><br>&#123;<br>    <span class="hljs-built_in">char</span> temp;<br>    <span class="hljs-keyword">while</span> (start&lt;end)<br>    &#123;<br>        temp = chars[start];<br>        chars[start] = chars[end];<br>        chars[end] = temp;<br>        start++;<br>        end--;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58 最后一个单词的长度"></a>58 最后一个单词的长度</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">LengthOfLastWord</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (end &lt; s.Length)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (s[start] == <span class="hljs-string">&#x27; &#x27;</span>)<br>        &#123;<br>            start++;<br>            end++;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (end &lt; s.Length &amp;&amp; s[end] != <span class="hljs-string">&#x27; &#x27;</span>) end++;<br>        result = end - start;<br>        <span class="hljs-keyword">while</span> (end &lt; s.Length &amp;&amp; s[end] == <span class="hljs-string">&#x27; &#x27;</span>) end++;<br>        <span class="hljs-keyword">if</span> (end &lt; s.Length &amp;&amp; s[end] != <span class="hljs-string">&#x27; &#x27;</span>)<br>        &#123;<br>            start = end;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a>8. 字符串转换整数 (atoi)</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MyAtoi</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span><br>&#123;<br>    <span class="hljs-built_in">char</span>[] chars = s.ToCharArray();<br><br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//丢弃前面空格</span><br>    <span class="hljs-keyword">while</span> (i &lt; s.Length &amp;&amp; chars[i] == <span class="hljs-string">&#x27; &#x27;</span>) i++;<br>    <span class="hljs-keyword">if</span> (i == s.Length) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//检查+和—是否存在</span><br>    <span class="hljs-built_in">int</span> sign = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (chars[i] == <span class="hljs-string">&#x27;-&#x27;</span> || chars[i] == <span class="hljs-string">&#x27;+&#x27;</span>)<br>    &#123;<br>        sign = chars[i] == <span class="hljs-string">&#x27;-&#x27;</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;<br>        i++;<br>    &#125;<br><br>    <span class="hljs-comment">//结果检查，防止溢出</span><br>    <span class="hljs-built_in">int</span> b = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; chars.Length &amp;&amp; chars[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; chars[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)<br>    &#123;<br>        <span class="hljs-comment">//检查  2147483648  -2147483648 最大值</span><br>        <span class="hljs-keyword">if</span> (b &gt; Int32.MaxValue / <span class="hljs-number">10</span> || (b == Int32.MaxValue / <span class="hljs-number">10</span> &amp;&amp; chars[i] - <span class="hljs-string">&#x27;0&#x27;</span> &gt; <span class="hljs-number">7</span>))<br>        &#123;<br>            <span class="hljs-keyword">if</span> (sign &gt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> Int32.MaxValue;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> Int32.MinValue;<br>        &#125;<br><br>        b = b * <span class="hljs-number">10</span> + (chars[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        i++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sign * b;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a>165. 比较版本号</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">CompareVersion</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> version1, <span class="hljs-built_in">string</span> version2</span>)</span><br>&#123;<br>    <span class="hljs-built_in">string</span>[] v1 = version1.Split(<span class="hljs-string">&quot;.&quot;</span>);<br>    <span class="hljs-built_in">string</span>[] v2 = version2.Split(<span class="hljs-string">&quot;.&quot;</span>);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; v1.Length||i&lt;v2.Length; ++i)<br>    &#123;<br>        <span class="hljs-built_in">int</span> x = <span class="hljs-number">0</span>; <span class="hljs-built_in">int</span> y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (i&lt;v1.Length)<br>        &#123;<br>            x = <span class="hljs-built_in">int</span>.Parse(v1[i]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i&lt;v2.Length)<br>        &#123;<br>            y = <span class="hljs-built_in">int</span>.Parse(v2[i]);<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (x&gt;y)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (x&lt;y)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12 整数转罗马数字"></a>12 整数转罗马数字</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">IntToRoman</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> num</span>)</span><br>&#123;<br>    <span class="hljs-comment">//将所有的情况都作成数组</span><br>    <span class="hljs-built_in">int</span>[] nums = &#123;<span class="hljs-number">1000</span>, <span class="hljs-number">900</span>, <span class="hljs-number">500</span>, <span class="hljs-number">400</span>, <span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">50</span>, <span class="hljs-number">40</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;;<br>    String[] romans = &#123;<span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;CM&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;CD&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;XC&quot;</span>, <span class="hljs-string">&quot;L&quot;</span>, <span class="hljs-string">&quot;XL&quot;</span>, <span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;IX&quot;</span>, <span class="hljs-string">&quot;V&quot;</span>, <span class="hljs-string">&quot;IV&quot;</span>, <span class="hljs-string">&quot;I&quot;</span>&#125;;<br>    StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-built_in">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (index &lt; <span class="hljs-number">13</span>)<br>    &#123;<br>        <span class="hljs-comment">//里面的元素值小于num的值，指针移动</span><br>        <span class="hljs-keyword">while</span> (nums[index] &lt;= num)<br>        &#123;<br>            <span class="hljs-comment">//结果集压入一个I，然后num值减1，然后拼接进三个I ps，按位算</span><br>            res.Append(romans[index]);<br>            <br>            num -= nums[index];<br>        &#125;<br>        index++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res.ToString();<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13 罗马数字转整数"></a>13 罗马数字转整数</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">RomanToInt</span>(<span class="hljs-params">String s</span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> pre = getValue(s[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; s.Length; i++) &#123;<br>        <span class="hljs-built_in">int</span> curr = getValue(s[i]);<br>        <span class="hljs-keyword">if</span> (pre &lt; curr) &#123;<br>            sum -= pre;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sum += pre;<br>        &#125;<br>        pre = curr;<br>    &#125;<br>    sum += pre;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getValue</span>(<span class="hljs-params"><span class="hljs-built_in">char</span> ch</span>)</span> &#123;<br>    <span class="hljs-keyword">switch</span>(ch) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;I&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;V&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;X&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;L&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">50</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;C&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">500</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;M&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1000</span>;<br>        <span class="hljs-literal">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode 字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LcTest1</title>
    <link href="/2022/11/27/Algo/LcTest1/"/>
    <url>/2022/11/27/Algo/LcTest1/</url>
    
    <content type="html"><![CDATA[<h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><h4 id="941-有效的山脉数组"><a href="#941-有效的山脉数组" class="headerlink" title="941 有效的山脉数组"></a>941 有效的山脉数组</h4><img src="/2022/11/27/Algo/LcTest1/image-20221127155032773.png" class="" title="image-20221127155032773"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">ValidMountainArray</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] arr</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//两个指针，一个开头一个结尾</span><br>        <span class="hljs-built_in">int</span> r = arr.Length ;<br>        <span class="hljs-built_in">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//找到最高点 </span><br>        <span class="hljs-keyword">while</span> (l &lt; r - <span class="hljs-number">1</span> &amp;&amp; arr[l] &lt; arr[l + <span class="hljs-number">1</span>]) l++;<br>        <span class="hljs-comment">//限制边界，最高点不能是第一个和最后一个元素</span><br>        <span class="hljs-keyword">if</span> (l == <span class="hljs-number">0</span> || l == r - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//从最高点往后递减扫描</span><br>        <span class="hljs-keyword">while</span> (l &lt; r - <span class="hljs-number">1</span> &amp;&amp; arr[l] &gt; arr[l + <span class="hljs-number">1</span>]) l++;<br>        <span class="hljs-comment">//如果i指向数组最后一个元素，则返回true，否则返回false</span><br>        <span class="hljs-keyword">return</span> l == r - <span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a>189. 轮转数组</h4><h5 id="1-使用额外数组"><a href="#1-使用额外数组" class="headerlink" title="1.使用额外数组"></a>1.使用额外数组</h5><p>(i+k)%n 得到数组元素旋转后的位置 i为元素下标 n为数组长度</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Rotate</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> k</span>)</span><br>   &#123;<br>       <span class="hljs-built_in">int</span> n = nums.Length;<br>       k = k % n;<br>       <span class="hljs-built_in">int</span>[] newarr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[n];<br>       <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.Length; i++)<br>       &#123;<br>           <span class="hljs-built_in">int</span> index = (i + k) % n;<br>           newarr[index] = nums[i];<br>       &#125;<br><br>       <span class="hljs-comment">// Array.Copy(newarr, 0, nums, 0, n);</span><br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>       &#123;<br>           nums[i] = newarr[i];<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h5 id="2-环装替代"><a href="#2-环装替代" class="headerlink" title="2.环装替代"></a>2.环装替代</h5><img src="/2022/11/27/Algo/LcTest1/image-20221127154515034.png" class="" title="image-20221127154515034"><p>将curr上的元素记在prev上 next指向的上旋转后的元素的位置  next和prev交换，计算完一环后 start++</p><p>一直到curr等于start结束</p><img src="/2022/11/27/Algo/LcTest1/image-20221127163118340.png" class="" title="image-20221127163118340"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Rotate2</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> k</span>)</span><br>   &#123;<br>       <span class="hljs-built_in">int</span> n = nums.Length;<br>       k = k % n;<br>       <span class="hljs-comment">//记住替换了多少个</span><br>       <span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> start = <span class="hljs-number">0</span>; count &lt; n; start++)<br>       &#123;<span class="hljs-comment">//标记每一次环的起始点</span><br>           <span class="hljs-built_in">int</span> curr = start;<br>           <span class="hljs-built_in">int</span> prev = nums[start];<br>           <span class="hljs-keyword">do</span><br>           &#123;<br>               <span class="hljs-built_in">int</span> next = (curr + k) % n;<br>               <span class="hljs-built_in">int</span> tmp = nums[next];<br>               nums[next] = prev;<br>               prev = tmp;<br>               curr = next;<br>               count++;<br>           &#125; <span class="hljs-keyword">while</span> (start != curr);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h5 id="3-数组翻转"><a href="#3-数组翻转" class="headerlink" title="3.数组翻转"></a>3.数组翻转</h5><img src="/2022/11/27/Algo/LcTest1/image-20221127165250905.png" class="" title="image-20221127165250905"> <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Rotate</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> k</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> n = nums.Length;<br>        k = k % n;<br>        Reverse(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>        Reverse(nums, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);<br>        Reverse(nums, k, n - <span class="hljs-number">1</span>);<br>    &#125;<br>        <span class="hljs-comment">//对撞指针</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Reverse</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> start, <span class="hljs-built_in">int</span> end</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">while</span> (start&lt;end)<br>        &#123;<br>            <span class="hljs-built_in">int</span> tmp = arr[start];<br>            arr[start] = arr[end];<br>            arr[end] = tmp;<br>            start++;<br>            end--;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="665-非递减数列"><a href="#665-非递减数列" class="headerlink" title="665 非递减数列"></a>665 非递减数列</h4><img src="/2022/11/27/Algo/LcTest1/image-20221127194314697.png" class="" title="image-20221127194314697"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">CheckPossibility</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] nums</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.Length; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt; nums[i - <span class="hljs-number">1</span>])<br>            &#123;<br>                <span class="hljs-comment">//只能改一次元素的值，记录一下，多了就是false</span><br>                count++;<br>                <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">//防止数组越界！！！！</span><br>                <span class="hljs-keyword">if</span> (i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt; nums[i - <span class="hljs-number">2</span>])<br>                &#123;<br>                    nums[i] = nums[i - <span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    nums[i - <span class="hljs-number">1</span>] = nums[i];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="228-汇总区间"><a href="#228-汇总区间" class="headerlink" title="228.汇总区间"></a>228.汇总区间</h4><img src="/2022/11/27/Algo/LcTest1/image-20221127203945943.png" class="" title="image-20221127203945943"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> IList&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">SummaryRanges</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] nums</span>)</span><br>    &#123;<br>        List&lt;<span class="hljs-built_in">string</span>&gt; res = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt;();<br>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; nums.Length)<br>        &#123;<br>            <span class="hljs-built_in">int</span> low = i;<br>            i++;<br>            <span class="hljs-comment">//找到非连续的点</span><br>            <span class="hljs-keyword">while</span> (i &lt; nums.Length &amp;&amp; nums[i] - nums[i - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) i++;<br>            <span class="hljs-comment">//上面i++了就要剪掉1，从0开始</span><br>            <span class="hljs-built_in">int</span> end = i - <span class="hljs-number">1</span>;<br>            StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(nums[low].ToString());<br>            <span class="hljs-keyword">if</span> (low &lt; end)<br>            &#123;<br>                sb.Append(<span class="hljs-string">&quot;-&gt;&quot;</span>);<br>                sb.Append(nums[end]);<br>            &#125;<br><br>            res.Add(sb.ToString());<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="163-缺失的区间"><a href="#163-缺失的区间" class="headerlink" title="163 缺失的区间"></a>163 缺失的区间</h4><img src="/2022/11/27/Algo/LcTest1/image-20221127205030460.png" class="" title="image-20221127205030460"><img src="/2022/11/27/Algo/LcTest1/image-20221127210700348.png" class="" title="image-20221127210700348"><h4 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31 下一个排列"></a>31 下一个排列</h4><p>​先找到靠右的较小数 和靠右的比较小数大的较大数 ，将两个数交换，随后翻转剩下的</p><img src="/2022/11/27/Algo/LcTest1/image-20221128150804704.png" class="" title="image-20221128150804704"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">NextPermutation</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] nums</span>)</span><br>   &#123;<br>       <span class="hljs-built_in">int</span> i = nums.Length - <span class="hljs-number">2</span>;<br><br>       <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="hljs-number">1</span>]) i--;<br><br>       <span class="hljs-keyword">if</span> (i&gt;=<span class="hljs-number">0</span>)<br>       &#123;<br>           <span class="hljs-built_in">int</span> j = nums.Length - <span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) j--;<br>           <br>           Swap(nums,i,j);<br>       &#125;<br>       Reverse(nums,i + <span class="hljs-number">1</span>);<br>   &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[]arr,<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> j</span>)</span><br>   &#123;<br>       <span class="hljs-built_in">int</span> temp = arr[i];<br>       arr[i] = arr[j];<br>       arr[j] = temp;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Reverse</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> start</span>)</span><br>   &#123;<br>       <span class="hljs-built_in">int</span> left = start;<br>       <span class="hljs-built_in">int</span> right = arr.Length - <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">while</span> (left&lt;right)<br>       &#123;<br>           Swap(arr,left,right);<br>           left++;<br>           right--;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135 分发糖果"></a>135 分发糖果</h4><h5 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h5><img src="/2022/11/27/Algo/LcTest1/image-20221128191708667.png" class="" title="image-20221128191708667"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Candy</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] ratings</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> n = ratings.Length;<br>    <span class="hljs-built_in">int</span>[] candies = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[n];<br>    Array.Fill(candies, <span class="hljs-number">1</span>); <span class="hljs-comment">//默认糖果全是1;</span><br><br>    <span class="hljs-built_in">bool</span> hasChange = <span class="hljs-literal">true</span>; <span class="hljs-comment">//控制孩子糖果的变化，没有变化就不循环了</span><br>    <span class="hljs-keyword">while</span> (hasChange)<br>    &#123;<br>        hasChange = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-comment">//不是最后一个孩子，评大于右边的且糖果小于等于右边的，糖果等于右边的+1</span><br>            <span class="hljs-keyword">if</span> (i != n - <span class="hljs-number">1</span> &amp;&amp; ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>] &amp;&amp; candies[i] &lt;= candies[i + <span class="hljs-number">1</span>])<br>            &#123;<br>                candies[i] = candies[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                hasChange = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <br>            <span class="hljs-comment">//如果评分大于左边的，糖果小于等于左边的，等于左边的+1</span><br>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>] &amp;&amp; candies[i] &lt;= candies[i - <span class="hljs-number">1</span>])<br>            &#123;<br>                candies[i] = candies[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                hasChange = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>   <br>    <span class="hljs-built_in">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> candy <span class="hljs-keyword">in</span> candies)<br>    &#123;<br>        sum += candy;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="两个数组，两次遍历"><a href="#两个数组，两次遍历" class="headerlink" title="两个数组，两次遍历"></a>两个数组，两次遍历</h5><img src="/2022/11/27/Algo/LcTest1/image-20221128200636480.png" class="" title="image-20221128200636480"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Candy</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] ratings</span>)</span> &#123;<br>       <span class="hljs-comment">//两个数组，一个从左往右，一个从右往左，然后取最大值</span><br>       <span class="hljs-built_in">int</span> n = ratings.Length;<br>       <span class="hljs-built_in">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[n];<br>       Array.Fill(left, <span class="hljs-number">1</span>);<br>       <span class="hljs-built_in">int</span>[] right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[n];<br>       Array.Fill(right, <span class="hljs-number">1</span>);<br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>       &#123;<br>           <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>])<br>           &#123;<br>               left[i] = left[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-built_in">int</span> sum = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>       &#123;<br>           <span class="hljs-keyword">if</span> (i != n - <span class="hljs-number">1</span> &amp;&amp; ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>])<br>           &#123;<br>               right[i] = right[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>           &#125;<br>       <br>           sum += Math.Max(left[i], right[i]);<br>          <br>       &#125;<br>       <span class="hljs-keyword">return</span> sum;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="605-种花问题"><a href="#605-种花问题" class="headerlink" title="605 种花问题"></a>605 种花问题</h4><img src="/2022/11/27/Algo/LcTest1/image-20221129110838063.png" class="" title="image-20221129110838063"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">CanPlaceFlowers</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] flowerbed, <span class="hljs-built_in">int</span> n</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//当花坛遍历完，花种完了，停止循环</span><br>    <span class="hljs-keyword">while</span> (i &lt; flowerbed.Length &amp;&amp; n &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (flowerbed[i] == <span class="hljs-number">1</span>)<br>        &#123;<br>            i += <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( i==flowerbed.Length<span class="hljs-number">-1</span> ||flowerbed[i + <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)<span class="hljs-comment">//flowerbed[i] == 0 上面if说明前面是0 flowerbed[i + 1]才能种！！</span><br>        &#123;<br>            <span class="hljs-comment">//i没有种花，且是最后一个花坛 i和i+1的位置都没有种花， 那么i位置一定能种花</span><br>            n--;<br>            <span class="hljs-comment">//然后得到i+2的位置才能继续种</span><br>            i += <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//i没有种花，i+1种花，那么得到i+3才能种</span><br>            i += <span class="hljs-number">3</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n &lt;= <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860 柠檬水找零"></a>860 柠檬水找零</h4><img src="/2022/11/27/Algo/LcTest1/image-20221129113256266.png" class="" title="image-20221129113256266"><img src="/2022/11/27/Algo/LcTest1/image-20221129114152950.png" class="" title="image-20221129114152950"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">LemonadeChange</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] bills</span>)</span><br>&#123;<br>    <span class="hljs-comment">//记住5有几张，10有几张</span><br>    <span class="hljs-built_in">int</span> five = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> ten = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> bill <span class="hljs-keyword">in</span> bills)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">5</span>)<br>        &#123;<br>            five++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">10</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (five == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//没有5就没法找就返回false</span><br>            <span class="hljs-comment">//能找开就减去一张五，加张十</span><br>            five--;<br>            ten++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<span class="hljs-comment">//如果给的是20，就看有没有10和5，有就找</span><br>            <span class="hljs-keyword">if</span> (ten &gt; <span class="hljs-number">0</span> &amp;&amp; five &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                ten--;<br>                five--;<br>            &#125;<span class="hljs-comment">//或者用三种5找</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (five &gt;= <span class="hljs-number">3</span>)<br>            &#123;<br>                five -= <span class="hljs-number">3</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><span class="hljs-comment">//都没有就找不开</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><h4 id="867-转置矩阵"><a href="#867-转置矩阵" class="headerlink" title="867 转置矩阵"></a>867 转置矩阵</h4><img src="/2022/11/27/Algo/LcTest1/image-20221130141246171.png" class="" title="image-20221130141246171"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>[][] Transpose(<span class="hljs-built_in">int</span>[][] matrix)<br>    &#123;<br>        <span class="hljs-comment">//获取矩阵的行与列数</span><br>        <span class="hljs-built_in">int</span> m = matrix.Length;<br>        <span class="hljs-built_in">int</span> n = matrix[<span class="hljs-number">0</span>].Length;<br>        <span class="hljs-built_in">int</span>[][] transposed = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[n][];<span class="hljs-comment">//存储转置后的矩阵行列数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            transposed[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[m];<br>        &#125;<br>        <span class="hljs-comment">//调换一下</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            &#123;<br>                <span class="hljs-comment">//交换行列索引</span><br>                transposed[j][i] = matrix[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> transposed;<br>    &#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="48选择图像"><a href="#48选择图像" class="headerlink" title="48选择图像"></a>48选择图像</h4><h5 id="原地翻转写法"><a href="#原地翻转写法" class="headerlink" title="原地翻转写法"></a>原地翻转写法</h5><img src="/2022/11/27/Algo/LcTest1/image-20221201110539777.png" class="" title="image-20221201110539777"><img src="/2022/11/27/Algo/LcTest1/image-20221201112400121.png" class="" title="image-20221201112400121"><p>第四个值的推演为 data【n-row-1】【row】&#x3D;&gt;data【row】【n-(n-col-1)-1】&#x3D;&gt;data【row】【col】</p><p>所以7的值为【0,0】</p><img src="/2022/11/27/Algo/LcTest1/image-20221201114534692.png" class="" title="image-20221201114534692"><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><h5 id="使用额外数组写法"><a href="#使用额外数组写法" class="headerlink" title="使用额外数组写法"></a>使用额外数组写法</h5><img src="/2022/11/27/Algo/LcTest1/image-20221201105353590.png" class="" title="image-20221201105353590"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>   <span class="hljs-comment"><span class="hljs-doctag">///</span> 使用额外数组的写法</span><br>   <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Rotate1</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[][] matrix</span>)</span><br>   &#123;<br>       <span class="hljs-built_in">int</span> n = matrix.Length;<br>       <span class="hljs-built_in">int</span>[,] newMatrix = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[n, n];<br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> row = <span class="hljs-number">0</span>; row &lt; n; row++)<br>       &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++)<br>           &#123;<br>               newMatrix[col, n - row - <span class="hljs-number">1</span>] = matrix[row][col];<br>               <br>           &#125;<br>       &#125;<br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> row = <span class="hljs-number">0</span>; row &lt; n; row++)<br>       &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++)<br>           &#123;<br>               matrix[row][col] = newMatrix[row, col];<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h5 id="翻转代替选择"><a href="#翻转代替选择" class="headerlink" title="翻转代替选择 !"></a>翻转代替选择 !</h5><img src="/2022/11/27/Algo/LcTest1/image-20221201115203551.png" class="" title="image-20221201115203551"><p>PS:这里索引写错了 <img src="/2022/11/27/Algo/LcTest1/0060E29C.png" class="" title="img"></p><img src="/2022/11/27/Algo/LcTest1/image-20221201115402931.png" class="" title="image-20221201115402931"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Rotate</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[][] matrix</span>)</span> &#123;<br>       <span class="hljs-built_in">int</span> n = matrix.Length;<br>       <span class="hljs-comment">// 水平翻转</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; ++i) &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>               <span class="hljs-built_in">int</span> temp = matrix[i][j];<br>               matrix[i][j] = matrix[n - i - <span class="hljs-number">1</span>][j];<br>               matrix[n - i - <span class="hljs-number">1</span>][j] = temp;<br>           &#125;<br>       &#125;<br>       <span class="hljs-comment">// 主对角线翻转</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>               <span class="hljs-built_in">int</span> temp = matrix[i][j];<br>               matrix[i][j] = matrix[j][i];<br>               matrix[j][i] = temp;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36 有效的数独"></a>36 有效的数独</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsValidSudoku</span>(<span class="hljs-params"><span class="hljs-built_in">char</span>[][] board</span>)</span><br>&#123;<br>    <span class="hljs-comment">//行列 宫格数字出现的情况</span><br>    <span class="hljs-built_in">bool</span>[][] rowUsed = <span class="hljs-keyword">new</span> <span class="hljs-built_in">bool</span>[<span class="hljs-number">9</span>][];<br>    <span class="hljs-built_in">bool</span>[][] colUsed = <span class="hljs-keyword">new</span> <span class="hljs-built_in">bool</span>[<span class="hljs-number">9</span>][];<br>    <span class="hljs-built_in">bool</span>[][] boxUsed = <span class="hljs-keyword">new</span> <span class="hljs-built_in">bool</span>[<span class="hljs-number">9</span>][];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)<br>    &#123;<br>        rowUsed[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">bool</span>[<span class="hljs-number">10</span>];<br>        colUsed[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">bool</span>[<span class="hljs-number">10</span>];<br>        boxUsed[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">bool</span>[<span class="hljs-number">10</span>];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> row = <span class="hljs-number">0</span>; row &lt; board.Length; row++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> col = <span class="hljs-number">0</span>; col &lt; board[<span class="hljs-number">0</span>].Length; col++)<br>        &#123;<br>            <span class="hljs-comment">//没有点的地方是数字</span><br>            <span class="hljs-keyword">if</span> (board[row][col] != <span class="hljs-string">&#x27;.&#x27;</span>)<br>            &#123;<br>                <span class="hljs-comment">//将数字转化为索引</span><br>                <span class="hljs-built_in">int</span> num= board[row][col] - <span class="hljs-string">&#x27;1&#x27;</span>;<br>                <span class="hljs-comment">//判断行列上是否出现了这个数字出现了就是false</span><br>                <span class="hljs-keyword">if</span> (rowUsed[row][num]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">else</span> rowUsed[row][num] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span> (colUsed[col][num]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">else</span> colUsed[col][num] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">//转换为九宫格 判断在宫格里有没有出现这个数字</span><br>                <span class="hljs-built_in">int</span> boxIndex = row / <span class="hljs-number">3</span> + (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>                <span class="hljs-keyword">if</span> (boxUsed[boxIndex][num]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">else</span> boxUsed[boxIndex][num] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73 矩阵置零"></a>73 矩阵置零</h4><img src="/2022/11/27/Algo/LcTest1/image-20221202143434712.png" class="" title="image-20221202143434712"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetZeroes</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[][] matrix</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> m = matrix.Length;<br>    <span class="hljs-built_in">int</span> n = matrix[<span class="hljs-number">0</span>].Length;<br><br>    <span class="hljs-comment">//记录行列是否要设置为0</span><br>    <span class="hljs-built_in">bool</span>[] rows = <span class="hljs-keyword">new</span> <span class="hljs-built_in">bool</span>[m];<br>    <span class="hljs-built_in">bool</span>[] cols = <span class="hljs-keyword">new</span> <span class="hljs-built_in">bool</span>[n];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> row = <span class="hljs-number">0</span>; row &lt; m; row++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (matrix[row][col]==<span class="hljs-number">0</span>)<br>            &#123;<br>                rows[row] = <span class="hljs-literal">true</span>;<br>                cols[col] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125; <br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> row = <span class="hljs-number">0</span>; row &lt; m; row++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (rows[row]||cols[col])<br>            &#123;<br>                matrix[row][col] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54 螺旋矩阵"></a>54 螺旋矩阵</h4><img src="/2022/11/27/Algo/LcTest1/image-20221202144544080.png" class="" title="image-20221202144544080"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> IList&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">SpiralOrder</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[][] matrix</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//用2x2的数组表示方向，往右，往下，往左，往上</span><br>        <span class="hljs-built_in">int</span>[][] dirs =<br>        &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>            <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>            <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;,<br>            <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;<br>        &#125;;<br><br>        <span class="hljs-built_in">int</span> m = matrix.Length;<br>        <span class="hljs-built_in">int</span> n = matrix[<span class="hljs-number">0</span>].Length;<br>        <span class="hljs-built_in">int</span> row = <span class="hljs-number">0</span>, col = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> di = <span class="hljs-number">0</span>; <span class="hljs-comment">//第几行</span><br>        List&lt;<span class="hljs-built_in">int</span>&gt; res = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;(); <span class="hljs-comment">//结果集</span><br>        <span class="hljs-built_in">bool</span>[][] see = <span class="hljs-keyword">new</span> <span class="hljs-built_in">bool</span>[m][];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>        &#123;<br>            see[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">bool</span>[n];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; m * n; i++)<br>        &#123;<br>            res.Add(matrix[row][col]);<br>            see[row][col] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//访问过的元素设置为true</span><br>            <span class="hljs-comment">//往右</span><br>            <span class="hljs-built_in">int</span> nextrow = row + dirs[di][<span class="hljs-number">0</span>];<br>            <span class="hljs-built_in">int</span> nextcol = col + dirs[di][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nextrow &lt; <span class="hljs-number">0</span> || nextrow &gt;= m <br>                || nextcol &lt; <span class="hljs-number">0</span> || nextcol &gt;= n||see[nextrow][nextcol])<br>            &#123;<br>                <span class="hljs-comment">//改变方向</span><br>                di = (di + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>            &#125;<br>            row = row + dirs[di][<span class="hljs-number">0</span>];<br>            col = col + dirs[di][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><p>按层模拟的解法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 按层模拟</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> IList&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">SpiralOrder</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[][] matrix</span>)</span><br>&#123;<br>    List&lt;<span class="hljs-built_in">int</span>&gt; res = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br>    <span class="hljs-built_in">int</span> startRow = <span class="hljs-number">0</span>, endRow = matrix.Length - <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">int</span> startCol = <span class="hljs-number">0</span>, endCol = matrix[<span class="hljs-number">0</span>].Length - <span class="hljs-number">1</span>;<br><br><br>    <span class="hljs-keyword">while</span> (startRow &lt;= endRow &amp;&amp; startCol &lt;= endCol)<br>    &#123;<br>        <span class="hljs-comment">//top行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> col = startCol; col &lt;= endCol; col++) res.Add(matrix[startRow][col]);<br>        <span class="hljs-comment">//right行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> row = startRow + <span class="hljs-number">1</span>; row &lt;= endRow; row++) res.Add(matrix[row][endCol]);<br>        <span class="hljs-keyword">if</span> (startRow &lt; endRow &amp;&amp; startCol &lt; endCol)<br>        &#123;<br>            <span class="hljs-comment">//bottom行</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> col = endCol - <span class="hljs-number">1</span>; col &gt; startCol; col--) res.Add(matrix[endRow][col]);<br>            <span class="hljs-comment">//left行</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> row = endRow; row &gt; startRow; row--) res.Add(matrix[row][startCol]);<br>        &#125;<br><br>        startRow++;<br>        endRow--;<br>        startCol++;<br>        endCol--;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59 螺旋矩阵II"></a>59 螺旋矩阵II</h4><img src="/2022/11/27/Algo/LcTest1/image-20221202170718013.png" class="" title="image-20221202170718013"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//与54思路差不多</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span>[][] GenerateMatrix(<span class="hljs-built_in">int</span> n)<br>&#123;<br>    <span class="hljs-comment">//用2x2的数组表示方向，往右，往下，往左，往上</span><br>    <span class="hljs-built_in">int</span>[][] dirs =<br>    &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>        <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>        <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;,<br>        <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;<br>    &#125;;<br><br>    <span class="hljs-built_in">int</span> row = <span class="hljs-number">0</span>, col = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> di = <span class="hljs-number">0</span>; <span class="hljs-comment">//第几行</span><br>    <span class="hljs-built_in">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[n][]; <span class="hljs-comment">//结果集</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        res[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[n];<br>    &#125;<br>    <span class="hljs-built_in">bool</span>[][] see = <span class="hljs-keyword">new</span> <span class="hljs-built_in">bool</span>[n][];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        see[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">bool</span>[n];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n * n; i++)<br>    &#123;<br>        res[row][col] = i + <span class="hljs-number">1</span>;<span class="hljs-comment">//输入进矩阵的值是1到n的平方，i是0到n-1；</span><br>        see[row][col] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//访问过的元素设置为true</span><br>        <span class="hljs-comment">//往右</span><br>        <span class="hljs-built_in">int</span> nextrow = row + dirs[di][<span class="hljs-number">0</span>];<br>        <span class="hljs-built_in">int</span> nextcol = col + dirs[di][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (nextrow &lt; <span class="hljs-number">0</span> || nextrow &gt;= n || nextcol &lt; <span class="hljs-number">0</span> || nextcol &gt;= n || see[nextrow][nextcol])<br>        &#123;<br>            <span class="hljs-comment">//改变方向</span><br>            di = (di + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>        &#125;<br><br>        row = row + dirs[di][<span class="hljs-number">0</span>];<br>        col = col + dirs[di][<span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="498-对角线遍历"><a href="#498-对角线遍历" class="headerlink" title="498 对角线遍历"></a>498 对角线遍历</h4><img src="/2022/11/27/Algo/LcTest1/image-20221205192222088.png" class="" title="image-20221205192222088"><p>越界情况上图  </p><p>补充 遇到三乘三的矩阵的话，应该是先执行 col &gt;&#x3D;n 的逻辑再执行 row&lt;0， 四乘四的先执行 row&gt;&#x3D;m再执行col&lt;0</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span>[] <span class="hljs-title">FindDiagonalOrder</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[][] mat</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (mat.Length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> Array.Empty&lt;<span class="hljs-built_in">int</span>&gt;();<br><br>    <span class="hljs-built_in">int</span> m = mat.Length;<br>    <span class="hljs-built_in">int</span> n = mat[<span class="hljs-number">0</span>].Length;<br>    <span class="hljs-built_in">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[m * n];<br>    <span class="hljs-built_in">int</span> row = <span class="hljs-number">0</span>,<br>        col = <span class="hljs-number">0</span>, <span class="hljs-comment">//从第一个元素开始遍历</span><br>        di = <span class="hljs-number">0</span>; <span class="hljs-comment">//当前的方向</span><br>    <span class="hljs-built_in">int</span>[][] dirs = &#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;, <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;&#125;; <span class="hljs-comment">//两个方向 斜上和斜下</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; m * n; i++)<br>    &#123;<br>        result[i] = mat[row][col];<br>        row = row + dirs[di][<span class="hljs-number">0</span>];<br>        col = col + dirs[di][<span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">//越界情况 四种</span><br>        <span class="hljs-keyword">if</span> (col &gt;= n)&#123; col = n - <span class="hljs-number">1</span>; row += <span class="hljs-number">2</span>; di = <span class="hljs-number">1</span> - di; &#125; <span class="hljs-comment">//如果是1就换成0 如果是0就换成1 就两个方向</span><br>        <span class="hljs-keyword">if</span> (row &gt;= m) &#123; row = m - <span class="hljs-number">1</span>; col += <span class="hljs-number">2</span>; di = <span class="hljs-number">1</span> - di; &#125;<br>        <span class="hljs-keyword">if</span> (col &lt; <span class="hljs-number">0</span>) &#123; col = <span class="hljs-number">0</span>; di = <span class="hljs-number">1</span> - di; &#125;<br>        <span class="hljs-keyword">if</span> (row &lt; <span class="hljs-number">0</span>) &#123; row = <span class="hljs-number">0</span>; di = <span class="hljs-number">1</span> - di; &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118 杨辉三角"></a>118 杨辉三角</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IList&lt;IList&lt;<span class="hljs-built_in">int</span>&gt;&gt; Generate(<span class="hljs-built_in">int</span> numRows)<br>&#123;<br>    IList&lt;IList&lt;<span class="hljs-built_in">int</span>&gt;&gt; rows = <span class="hljs-keyword">new</span> List&lt;IList&lt;<span class="hljs-built_in">int</span>&gt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> row = <span class="hljs-number">0</span>; row &lt; numRows; row++)<br>    &#123;<br>        List&lt;<span class="hljs-built_in">int</span>&gt; OneRows = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> col = <span class="hljs-number">0</span>; col &lt;= row; col++)<br>        &#123;<br>            <span class="hljs-comment">//头尾部分</span><br>            <span class="hljs-keyword">if</span> (col == <span class="hljs-number">0</span> || col == row)<br>            &#123;<br>                OneRows.Add(<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">//上一行的两个加起来</span><br>                OneRows.Add(rows[row - <span class="hljs-number">1</span>][col - <span class="hljs-number">1</span>] + rows[row<span class="hljs-number">-1</span>][col]);<br>            &#125;<br>        &#125;<br><br>        rows.Add(OneRows);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> rows;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="119-杨辉三角II"><a href="#119-杨辉三角II" class="headerlink" title="119 杨辉三角II"></a>119 杨辉三角II</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IList&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">GetRow</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> rowIndex</span>)</span><br>&#123;<br>    IList&lt;IList&lt;<span class="hljs-built_in">int</span>&gt;&gt; result = <span class="hljs-keyword">new</span> List&lt;IList&lt;<span class="hljs-built_in">int</span>&gt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> row = <span class="hljs-number">0</span>; row &lt;= rowIndex; row++)<br>    &#123;<br>        <span class="hljs-keyword">var</span> list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;(row + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> col = <span class="hljs-number">0</span>; col &lt; row + <span class="hljs-number">1</span>; col++)<br>        &#123;<br>            <span class="hljs-built_in">int</span> element;<br>            <span class="hljs-comment">//头尾部分</span><br>            <span class="hljs-keyword">if</span> (row == <span class="hljs-number">0</span> || col == <span class="hljs-number">0</span> || col == row)<br>            &#123;<br>                element = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">//上一行的两个加起来</span><br>                element = result[row - <span class="hljs-number">1</span>][col - <span class="hljs-number">1</span>] + result[row - <span class="hljs-number">1</span>][col];<br>            &#125;<br><br>            list.Add(element);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (rowIndex == <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br><br>        result.Add(list);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result.Last();<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode 数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ET-多进程分布式架构</title>
    <link href="/2022/01/05/Framework/ET-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/"/>
    <url>/2022/01/05/Framework/ET-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h3 id="游戏服务器架构"><a href="#游戏服务器架构" class="headerlink" title="游戏服务器架构"></a>游戏服务器架构</h3><p><strong>第一代游戏服务器架构</strong></p><img src="/2022/01/05/Framework/ET-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/image-20221129152425095.png" class="" title="image-20221129152425095"><p>使用单台物理机，单个游戏服务器程序进程 单线程无阻塞Socket来服务所有的玩家，，每隔一秒与玩家进行更新同步数据</p><p>处理的速度是非常非常低的，且因为当时没有数据库，数据是存在本地的，要对本地数据进行IO读写</p><p><strong>第二代游戏服务器架构</strong></p><img src="/2022/01/05/Framework/ET-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/image-20221129152445122.png" class="" title="image-20221129152445122"><p>采用分区分服模式，同时引入数据库软件存储游戏数据，用于存储游戏数据，多个游戏服务器进程同时运行，每个游戏服务器都是独立的</p><p><strong>第三代游戏服务器架构 (三层架构)</strong></p><img src="/2022/01/05/Framework/ET-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/image-20221129152457290.png" class="" title="image-20221129152457290"><p>发展处让玩家统一连接的网关服务器，而数据库存储的任务则交由数据库代理服务器进程处理，游戏服务器进程专心处理游戏功能业务逻辑</p><p>玩家发出的请求交给Gate网关 网关转发给服务器进程。 因为之前玩家是直接连接游戏服务器进程，那么服务器进程就要管理大量的Socket连接 还要对不同的Socket进程进行IO读写，效率慢，所以我们将与网络连接的功能单独提取出来交给Gate网关进行处理</p><p><strong>第三代游戏服务器架构 (无缝地图)</strong></p><img src="/2022/01/05/Framework/ET-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/image-20221129152511480.png" class="" title="image-20221129152511480"><p>玩家可以在不同的地图之间 进行无缝地图传送 大型MMORPG的标准配置</p>]]></content>
    
    
    <categories>
      
      <category>Framework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Socket</tag>
      
      <tag>GameFramework</tag>
      
      <tag>Unity</tag>
      
      <tag>ET</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ET-前后端通讯</title>
    <link href="/2022/01/05/Framework/ET-%E5%89%8D%E5%90%8E%E7%AB%AF%E9%80%9A%E8%AE%AF/"/>
    <url>/2022/01/05/Framework/ET-%E5%89%8D%E5%90%8E%E7%AB%AF%E9%80%9A%E8%AE%AF/</url>
    
    <content type="html"><![CDATA[<p>UILoginComponentSystem</p><p>我们从Demo的<strong>UILoginComponentSystem</strong>类中开始看起 它继承自<strong>AwakeSystem</strong>的<strong>UILoginComponent</strong>组件的生命周期辅助类，</p><p>Awake方法注册了Demo Init的登录点击事件，实际上就是注册<strong>UILoginComponent</strong>的扩展方法OnLogin 而OnLogin调用了静态的辅助类<strong>LoginHelper</strong>里的Login方法，Login方法呢就是真正编写客户端向服务端发起登录请求的逻辑方法。</p><p>客户端是如何和服务端发起通讯的？</p><p><strong>LoginHelper</strong>里的Login方法的第二个参数address，所传入的是ConstValue的常量LoginAddress所定义的IP地址和端口</p><p>使用Socket接口。</p><p>ET的Socket是如何调用的</p><p><strong>LoginHelper</strong>里的Login方法里的zoneScene调用了NetKcpComponent组件的的Create方法，传入address参数，将IP地址进行转换，而Create方法的主要作用是创建了Session，Session是会话，而我们会拿到GetOrCreate的Get创建了一个<strong>Channel</strong>的类，而在TChannel的这个类中，Socket被正式创建出来了，而在创建Socket的时候使用的是一个session的ID，这个Id对Channel进行了对应和关联。这样就能实现一个映射表的关系，有这个映射表的关系，就能通过session来对Socket来写入数据，Socket就可以负责将网络消息数据进入到传输层，网络互联层 接口层，最终发到游戏服务器上去</p><p>C2R_LoginHandler类 消息处理类</p><p>消息传输流程 BY狐狸菌</p><h2 id="结构模型"><a href="#结构模型" class="headerlink" title="结构模型"></a>结构模型</h2><ul><li>NetworkComponent【NetOuterComponent、NetInnerComponent】<ul><li>Session</li><li>AService【KService、TService、WService】<ul><li>Socket</li><li>PacketParser</li><li>CircularBuffer</li><li>AChannel【KChannel、TChannel、WChannel】</li></ul></li><li>IMessagePacker【MongoPacker、ProtobufPacker】</li><li>IMessageDispatcher【InnerMessageDispatcher、OuterMessageDispatcher（服务端）、OuterMessageDispatcher（客户端）】</li></ul></li><li>OpcodeTypeComponent</li><li>MessageDispatcherComponent<ul><li>IMHandler【AMHandler、AMRpcHandler】</li></ul></li></ul><p>服务器独占</p><ul><li>MailboxDispatcherComponent<ul><li>IMailboxHandler【MailboxGateSessionHandler、MailboxMessageDispatcherHandler】</li></ul></li><li>ActorMessageDispatcherComponent<ul><li>IMActorHandler【AMActorHandler、AMActorRpcHandler、AMActorLocationHandler、AMActorLocationRpcHandler】</li></ul></li><li>LocationProxyComponent</li><li>LocationComponent</li><li>ActorMessageSenderComponent<ul><li>ActorMessageSender</li></ul></li><li>ActorLocationSenderComponent<ul><li>ActorLocationSender</li></ul></li></ul><h2 id="客户端建立Session"><a href="#客户端建立Session" class="headerlink" title="客户端建立Session"></a>客户端建立Session</h2><ol><li><p>添加<code>NetOuterComponent</code></p><p>因为<code>NetOuterComponent外网组件</code>继承自<code>NetworkComponent网络组件</code>，所以在<code>Init</code>类中为<code>Scene</code>添加<code>NetOuterComponent</code>也就等于添加了<code>NetworkComponent</code>，同时<code>NetOuterComponent</code>还指定了网络组件以什么协议沟通；</p><ul><li><p>考虑到服务端Hotfix与Model分离规则，所以<code>NetOuterComponent</code>的事件驱动与组件不在一个类中。</p></li><li><p>在</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">NetOuterComponent</span><br></code></pre></td></tr></table></figure><p>的</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Awake</span><br></code></pre></td></tr></table></figure><p>事件中创建了</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">TService、ProtobufPacker、OuterMessageDispatcher<br></code></pre></td></tr></table></figure><p>，并保存引用到自身</p><ul><li>TService：TCPService，继承自<code>AService</code></li><li>ProtobufPacker：Protobuf打包器，继承自<code>IMessagePacker</code>,主要用于调用<code>ProtobufHelper</code>对消息进行打包处理</li><li>OuterMessageDispatcher：外部消息分发组件，继承自<code>IMessageDispatcher</code>，主要用于调用<code>MessageDispatcherComponent</code>对外部消息进行分发处理</li></ul></li></ul></li><li><p>创建<code>Model.Session</code></p><p>通过外网组件间接调用网络组件的<code>Create</code>方法，先通过<code>TService</code>的<code>ConnectChannel</code>方法传入远端IP地址创建了一个<code>TChannel</code>,然后将<code>TChannel</code>作物初始化参数创建了一个<code>Model.Session</code>，并调用<code>Session</code>的<code>Start</code>方法启动Session。</p><ul><li><p>TChannel：TCP通道，继承自：<code>AChannel</code>，在构造函数中创建了<code>Socket、PacketParser</code>，并设置了各种流处理相关属性</p><ul><li>Socket：套接字</li><li>PacketParser：包解析器</li><li>CircularBuffer：缓冲区</li></ul></li><li><p>Session</p><p>在其Awake方法中，将<code>NetworkComponent.Remove</code>自身方法作为委托传入了<code>TChannel</code>的<code>ErrorCallback</code>中，还将自身的<code>OnRead</code>方法作为委托传入了<code>TChannel</code>的<code>ReadCallback</code>中</p><p>Session的<code>Start</code>方法调用了<code>TChannel</code>的<code>Start</code>方法</p><ol><li><p>建立远程链接</p></li><li><p>开始循环异步接收消息</p><p>注意，到这里Model.Session已经创建完成，并且开始接收消息，以下是收到消息后的处理</p><ul><li>当一条消息读取完毕后，先调用<code>PacketParser</code>包解析器，进行解包</li><li>再通过委托调用<code>Session</code>的<code>OnRead</code>方法对消息进行分发处理</li></ul></li></ol></li></ul></li><li><p>创建<code>Hotfix.Session</code></p><p>将上一步生成的<code>Model.Session</code>作为初始化参数，创建一个<code>Hotfix.Session</code>，该类的<code>Dispose</code>方法会自动调用<code>Model.Session</code>的<code>Dispose</code></p><p>在该类的<code>Awake</code>事件中，会给<code>Model.Session</code>添加<code>SessionCallbackComponent热更层Session回调组件</code>；该组件持有两个委托</p><ul><li><code>MessageCallback</code>用于<code>Model.Session</code>通过委托调用<code>Hotfix.Session</code>的<code>Run</code>方法</li><li><code>DisposeCallback</code>用于<code>Model.Session</code>通过委托调用<code>Hotfix.Session</code>的<code>Dispose</code>方法</li></ul></li></ol><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><ol><li>Hotfix.Session<ul><li>发送消息<ul><li>发送普通消息，调用<code>Hotfix.Session</code>的<code>Send</code>方法</li><li>发送请求消息，调用<code>Hotfix.Session</code>的<code>Call</code>方法，创建一个异步完成的委托回调，用于消息答复时触发ETTask返回</li></ul></li><li>通过<code>OpcodeTypeComponent</code>对应的消息码</li><li>调用<code>Model.Session</code>的<code>Send</code>方法</li></ul></li><li>Model.Session<ul><li>通过<code>NetOuterComponent</code>类的<code>ProtobufPacker</code>序列化消息</li><li>写入操作码</li><li>调用<code>TChannel</code>的<code>Send</code>方法</li></ul></li><li>Tchannel<ul><li>将消息写入缓冲区<code>CircularBuffer</code></li><li>通过<code>TService</code>的<code>MarkNeedStartSend</code>方法将自生标记为待发送</li><li><code>TService</code>的<code>Update</code>事件将调用<code>Tchannel</code>的<code>StartSend</code>方法发送消息</li><li><code>StartSend</code>调用<code>SendAsync</code>向远端发送一条消息</li></ul></li></ol><h2 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h2><p><code>TChannel</code>的<code>Start</code>方法将开启循环接收消息。下面演示接收到一条消息后的处理流程</p><ol><li><p>TChannel</p><ul><li>当一条消息读取完毕后，先调用<code>PacketParser</code>包解析器，进行解包</li><li>通过委托调用<code>Session</code>的<code>OnRead</code>方法对消息进行分发处理</li></ul></li><li><p>Session</p><ul><li><p>获取操作码</p></li><li><p>通过<code>OpcodeHelper.IsClientHotfixMessage</code>检测是否是热更层消息</p><p>如果是热更层消息，则通过<code>SessionCallbackComponent</code>委托调用热更层Session处理消息，后续hotfix和Model处理流程是一样的</p></li><li><p>通过<code>OpcodeTypeComponent操作码-类型组件</code>获取操作码对应的消息类实例</p></li><li><p>通过<code>NetOuterComponent</code>类的<code>ProtobufPacker</code>反序列化数据</p></li><li><p>检测消息是否是响应消息</p><ul><li>不是响应消息，直接通过<code>NetOuterComponent</code>类的<code>OuterMessageDispatcher</code>调用<code>MessageDispatcherComponent</code>处理消息</li><li>是响应消息，通过消息的RpcId查找请求队列中对应的请求，并激活完成事件</li></ul></li></ul></li></ol><h2 id="服务端Actor模型建立"><a href="#服务端Actor模型建立" class="headerlink" title="服务端Actor模型建立"></a>服务端Actor模型建立</h2><ul><li><p>登录服务器</p><ol><li>添加<code>NetInnerComponent、NetOuterComponent</code>内网组件和外网组件来为当前服务器建立基本网络收发配置</li><li>分配服务器网关地址，在登录验证通过后，通过<code>RealmGateAddressComponent</code>随机网关地址组件获取<code>内网</code>网关地址</li><li>通过向<code>NetInnerComponent.Get</code>方法传入获取到的网关地址，创建一个与网关服务器链接的内网Session</li><li>通过Session在<code>网关服务器</code>上创建一个登录Key，然后将Key和客户端地址保存到<code>GateSessionKeyComponent</code>网关登录Key组件中，注意：该Key会在20秒后自动销毁</li></ol></li><li><p>网关服务器</p><ol><li><p>客户端通过从登录服务器获取的<code>外网</code>网关地址，建立一个链接网关的Session</p></li><li><p>通过<code>GateSessionKeyComponent</code>验证网关登录Key和Value是否匹配，不匹配返回登录失败</p></li><li><p>将Value作为初始参数创建一个<code>Plyaer</code></p></li><li><p>为当前链接客户端的<code>Session</code>添加<code>SessionPlayerComponent</code>Session绑定Player组件，并绑定Player</p><p>该类在Session销毁时，自身的Destroy事件会被调用。这里的Destroy还没写完</p></li><li><p>同时为当前<code>Session</code>添加邮箱组件，并设置类型为网关邮箱（网关邮箱收到的信息会直接转发给链接当前Session的客户端）</p><p>挂上这个组件表示该Entity是一个Actor,接收的消息将会队列处理</p><blockquote><p>到这一步，算是为对象建立Actor模型完成</p></blockquote></li><li><p>进入Map服务器</p><p>通过<code>StartConfigComponent</code>初始配置管理组件获取一个map服务器<code>内网</code>地址，并根据地址使用<code>NetInnerComponent.Get</code>方法创建一个链接Map服务器的内网Session</p><p>通过Session发送在Map服务器上创建Unit的请求，并传入当前网关服务链接客户端的Session的唯一Id</p></li></ol></li><li><p>Map服务器</p><ol><li><p>创建Unit</p></li><li><p>为Unit添加<code>UnitGateComponent</code>Unit网关组件，并将传入的网关Session的唯一Id绑定到组件中</p></li><li><p>为Unit添加<code>MailBoxComponent</code>邮箱组件</p></li><li><p>调用<code>MailBoxComponent</code>邮箱组件的<code>AddLocation</code>方法</p><p>调用<code>LocationProxyComponent</code>位置代理组件的<code>Add</code>方法</p><p>创建一获取地址服务器的<code>内网</code>地址创建一个链接地址服务器的内网Session</p><p>通过内网Session将Unit的Id和唯一Id发动到Location服务器</p></li></ol></li><li><p>Location服务器</p><ol><li><p>接收到Map服务器发送的<code>ObjectAddRequest</code>请求后，在<code>LocationComponent</code>位置组件中保存传送过来的Unit的Id与InstanceId</p><blockquote><p>到这一步，算是为对象建立了LocationActor模型完成，其实Actor模型和LocationActor模型代码上步骤分支主要在于添加邮箱组件时分配的邮箱类型和有没有调用<code>AddLocation</code>方法</p></blockquote></li></ol></li></ul><h2 id="发送Actor消息"><a href="#发送Actor消息" class="headerlink" title="发送Actor消息"></a>发送Actor消息</h2><p>参考服务端<code>MessageHelper</code>（客户端ActorLocation消息参考<code>OperaComponent</code>，服务端参考<code>SessionPlayerComponentSystem</code>）</p><ol><li><p>获取Unit的<code>UnitGateComponent</code>Unit网关组件，并得到组件中网关Session对象的唯一Id</p></li><li><p>通过网关Session的唯一Id提取网关服务器设备Id</p></li><li><p>通过<code>ActorMessageSenderComponent</code>Actor消息发送器管理组件创建一个<code>ActorMessageSender</code>Actor消息发送器，并通过上一步获取的网关服务器设备Id查找到对应的网关服务器的<code>内网地址</code>，赋值到Actor消息发送器中。</p></li><li><p>调用Actor消息发送器的<code>Send</code>方法</p><p>使用<code>NetInnerComponent</code>内网组件和网关服务器地址，创建一个链接网关服务器的内网Session，然后使用该Session发送消息。</p><blockquote><p>由于创建Session时使用的时内网地址，所以会有网关服务器的内网组件接收Session传来的消息，由于内网组件使用的消息分发器和外网组件不同，所以在解析消息的时候Actor消息和普通消息相比会有更多步骤</p></blockquote></li></ol><h2 id="接收Actor消息"><a href="#接收Actor消息" class="headerlink" title="接收Actor消息"></a>接收Actor消息</h2><p>和普通消息前期收取规则是一样的，产生差异在于Session调用消息分发器分发消息时。</p><ul><li><p><code>InnerMessageDispatcher</code>内网消息分发</p><ol><li><p>解析消息是否是Actor消息，非Actor消息调用<code>MessageDispatcherComponent</code>消息分发组件处理消息</p></li><li><p>Actor消息会通过<code>EventSystem</code>查找发送过来的ActorID（也就是对象的InstanceId）对应对象是否存在，不存在则直接返回<code>获取Actor失败异常</code></p></li><li><p>获取对象身上的<code>MailBoxComponent</code>邮箱组件，（如果获取不到则返回<code>获取邮箱失败异常</code>）将Session和Actor消息封装成<code>ActorMessageInfo</code>存入邮箱组件中</p></li><li><p>邮箱组件会在循环中读取消息并调用<code>MailboxDispatcherComponent</code>邮箱分发组件的<code>Handle</code>方法进行二次分发消息</p></li><li><p><code>Handle</code>方法根据前面的邮箱组件类型分发给<code>MailboxGateSessionHandler或MailboxMessageDispatcherHandler</code>的<code>Handle</code>方法做处理</p><ul><li><p><code>MailboxGateSessionHandler</code>直接将第三步获取的对象转换成<code>Session</code>向客户端发送消息</p></li><li><p><code>MailboxMessageDispatcherHandler</code>通过<code>ActorMessageDispatcherComponent</code>Actor消息分发组件的<code>Handle</code>方法，将消息进行最终分发处理</p><p><code>ActorMessageDispatcherComponent</code>Handle方法会查找注册在组件中消息操作码对应的消息处理实例，有该实例完成消息最终的处理</p></li></ul></li></ol></li><li><p><code>OuterMessageDispatcher</code>外网消息分发</p><ol><li><p>解析消息是否是ActorLocation消息，非ActorLocation消息调用<code>MessageDispatcherComponent</code>消息分发组件处理消息</p></li><li><p>ActorLocation消息通过Session绑定的<code>SessionPlayerCompoennt</code>组件获取Player，再通过Player获取UnitId；</p></li><li><p>通过<code>ActorLocationSenderComponent</code>ActorLocation消息发送器管理组件创建<code>ActorLocationSender</code>ActorLocation消息发送器，指定该对象的Id为UnitId，并将UnitId作为Key和ActorLocation消息发送器一起保存到字典中</p><blockquote><p>由于可能产生Bug或者进程挂掉而导致ActorLocationSender没有返回，所以在ActorLocationSenderComponent的Start事件中开启了一个携程，用于清理超时1分钟没有返回的ActorLocation消息发送器</p></blockquote></li></ol><blockquote><p>由于对象可能进行跨服转移，所以消息的接收不能直接使用对象身上挂在组件，需要生成一个代理对象来收发消息、对消息进行阻塞，也就是<code>ActorLocationSender</code></p></blockquote><ul><li>在<code>ActorLocationSender</code>的Start事件中，通过向<code>LocationProxyComponent</code>位置代理组件传入UnitId调用<code>Get</code>方法获取唯一ID</li><li>在<code>Get</code>方法中建立一个链接位置服务器的内网Session，并通过该Session发送<code>ObjectGetResponse</code>请求，传入UnitID</li><li>在位置服务器中，通过接收到的UnitId向<code>LocationComponent</code>位置组件<code>GetAsync</code>异步获取方法获取Unit的唯一Id</li><li>在<code>ActorLocationSender</code>的Start事件中，还开启了一个携程循环，用于读取<code>ActorTask</code>队列</li></ul><ol><li><p>调用<code>ActorLocationSender</code>ActorLocation消息发送器的<code>Call或Send</code>方法，创建一个<code>ActorTask</code>Actor消息任务，并保存到队列中</p></li><li><p>在<code>ActorLocationSender</code>ActorLocation消息发送器的<code>UpdateAsync</code>方法中，会循环读取队列中的<code>ActoTask</code>Actor消息任务，并调用<code>RunTask</code>方法发送消息</p><p><code>RunTask</code>方法流程</p><ol><li>先通过<code>ActorMessageSenderComponent</code>Actor消息发送器管理组件的<code>Get</code>方法获取一个<code>ActorMessageSender</code>Actor消息发送器</li></ol><ul><li><pre><code class="hljs">Get</code></pre><p>方法会使用传入的Unit的唯一ID提取对应的服务器设备ID，再通过设备ID获取对应服务器内网地址</p><ul><li>将Unit唯一ID和服务器地址作为初始参数创建一个<code>ActorMessageSender</code>Actor消息发送器</li></ul></li></ul><ol><li>使用<code>ActorMessageSender.CallWithoutException</code>不抛出异常的方式发送消息，这里后续逻辑就接入了前面所说的<code>InnerMessageDispatcher</code>内网消息分发</li><li>检测上一步消息是否发送成功<ul><li>如果发送成功，则完成ActorLocation消息的收发流程</li><li>如果是获取Actor失败异常，则等待半秒，然后重新从上面第五步开始<code>UpdateAsync</code>方法开始执行，注意该流程会重复5次，超过五次会将<code>ActorLocationSender</code>自身销毁，并抛出异常</li><li>如果是获取邮箱失败异常，则直接将自身销毁，并抛出异常</li></ul></li></ol></li></ol></li></ul><h2 id="对象跨服跳转"><a href="#对象跨服跳转" class="headerlink" title="对象跨服跳转"></a>对象跨服跳转</h2><p>参考<code>Actor_TransferHandler</code></p><ul><li>Map服务器A<ol><li>调用<code>LocationProxyComponent</code>位置代理组件的<code>Lock</code>方法（传入上锁对象ID和上锁时长），建立与位置服务器链接的内网Session，并发送上锁消息<code>ObjectLockRequest</code></li></ol></li><li>Location服务器<ol><li>调用<code>LocationComponent</code>的<code>Lock</code>方法，在Lock方法中会将上锁对象ID和唯一ID保存到容器中，建立一个计时器，超时后从容器中去除对象</li></ol></li><li>Map服务器A<ol><li>从<code>EventSystem</code>中删除对象，保存对象原有唯一ID</li><li>通过转移的目标服务器设备ID获取目标服务器地址，并建立内网Session</li><li>通过内网Session，向目标服务器发送转移对象。</li></ol></li><li>Map服务器B<ol><li>将收到的对象反序列化（注意这里反序列化会重新生成对象的唯一ID）</li><li>将对象加入<code>EventSystem</code>事件系统中</li><li>重新添加<code>MailBoxComponent</code>邮箱组件，来构建Actor模型</li><li>返回给服务器A新的唯一ID</li></ol></li><li>Map服务器A<ol><li>将对象销毁</li><li>调用<code>LocationProxyComponent</code>位置代理组件的<code>UnLock</code>方法（传入上锁对象ID和新的唯一ID），建立与位置服务器链接的内网Session，并发送上锁消息<code>ObjectUnLockRequest</code></li></ol></li><li>Location服务器<ol><li>调用<code>LocationComponent</code>的<code>UnLockAndUpdate</code>方法</li><li>在UnLockAndUpdate方法中会将上锁对象的唯一ID进行更新</li><li>调用<code>UnLock</code>方法，从上锁容器中删除对象，然后将上锁期间收到堵塞的Location消息重新进行发送</li></ol></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>消息分类：</p><ul><li><p>S2C:</p><ul><li>IMessage</li><li>IRequest</li></ul></li><li><p>C2S:</p><ul><li><p>IMessage</p></li><li><p>IRequest</p></li><li><p>IActorLocationMessage</p><p>前提是服务端对链接客户端的Session绑定的对象进行了ActorLocation绑定处理（挂载了邮箱组件，并注册到位置服务器中），使用Session按正常方式发送消息即可</p></li><li><p>IActorLocationRequest</p></li></ul></li><li><p>S2S:</p><ul><li><p>IMessage</p></li><li><p>IRequest</p></li><li><p>IActorMessage</p><p>前提是知道接收对象的唯一ID，且接收对象挂在了邮箱组件</p><p>通过<code>ActorMessageSenderComponent</code>组件传入对象的唯一ID，建立<code>ActorMessageSender</code>，通过<code>ActorMessageSender</code>发送消息</p><p>由于Actor是走内网组件所以只能在服务器内部传输使用，如果希望外网也能调用，需要自己手动扩展<code>OuterMessageDispatcher</code></p></li><li><p>IActorRequest</p></li><li><p>IActorLocationMessage</p><p>前提是接收对象有绑定邮箱组件，并在地址服务中进行了注册。</p><p>使用<code>ActorLocationSenderComponent</code>组件传入对象Id，获取<code>ActorLocationSender</code>，通过<code>ActorLocationSender</code>发送消息</p></li><li><p>IActorLocationRequest</p></li></ul></li></ul><p>登录流程：</p><ol><li>Client建立一个链接Realm的Session</li><li>Client向Realm发送登录请求，验证登录账成功后</li><li>Realm向Gate获取登录Gate的key和Gate的地址</li><li>Realm返回给Client登录Gate的key和Gate的地址</li><li>Client通过Gate地址建立一个新的Session，并销毁之前的Session</li><li>Client向Gate发送登录Gate请求，验证之前返回Key成功后在Gate创建Player<ol><li>将Client地址保存到Player中，方便后续对Client建立Session</li><li>给当前Gate链接Client的Session添加邮箱组件，将Session注册成Actor</li></ol></li><li>Gate返回给Client Player的ID，在客户端建立Player</li><li>Client向Gate发送登录Map请求</li><li>Gate向Map发送创建Unit请求</li><li>Map创建Unit，并返回UnitId<ol><li>给Unit添加邮箱组件，注册成Actor</li><li>再调用邮箱组件的AddLocation方法，将Unit注册到Location服务器中</li></ol></li><li>Gate返回给Client在Map返回的UnitId</li><li>Client通过UnitId建立Unit</li></ol>]]></content>
    
    
    <categories>
      
      <category>Framework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Socket</tag>
      
      <tag>GameFramework</tag>
      
      <tag>Unity</tag>
      
      <tag>ET</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2022/01/03/Algo/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2022/01/03/Algo/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>下面是冒泡排序的详细步骤：</p><ol><li>从数组的第一个元素开始，依次比较相邻的两个元素，如果它们的顺序不正确就交换它们的位置，使得较大（或较小）的元素向右移动一位。</li><li>继续从数组的第一个元素开始，重复步骤1，直到数组的倒数第二个元素被比较完毕。</li><li>重复步骤1和2，直到所有元素都排好序为止。</li></ol><p>例如<code>2 5 3 1 4</code>排序过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xichujn/image/img/image-20210428093055336.png" alt="image-20210428093055336"></p><p>实现代码为：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] data</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (data.Length == <span class="hljs-literal">null</span> || data.Length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = data.Length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        &#123;<span class="hljs-comment">//从尾部开始往左遍历 轮次</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)<br>            &#123;<span class="hljs-comment">//每一轮都在对比j和j+1的大小 大于交换位置</span><br>                <span class="hljs-keyword">if</span> (data[j] &gt; data[j + <span class="hljs-number">1</span>])<br>                &#123;<br>                    (data[j], data[j + <span class="hljs-number">1</span>]) = (data[j + <span class="hljs-number">1</span>], data[j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序是一种高效的排序算法，它的基本思想是通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后再分别对这两部分记录继续进行排序，以达到整个序列有序的目的。具体步骤如下：</p><ol><li>选择一个基准元素，通常选择第一个元素作为基准元素。</li><li>从序列的右端开始向左扫描，找到第一个比基准元素小的元素，将其与基准元素交换。</li><li>从序列的左端开始向右扫描，找到第一个比基准元素大的元素，将其与基准元素交换。</li><li>重复步骤2和3，直到左右两个扫描的位置相遇。</li><li>将基准元素与相遇位置的元素交换。</li><li>对左右两个子序列分别进行快速排序，直到整个序列有序。</li></ol><ul><li><img src="https://cdn.jsdelivr.net/gh/xichujn/image/img/image-20210428093203178.png" alt="image-20210428093203178"></li></ul><p>实现代码为：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">QuickSort</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] data</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (data.Length == <span class="hljs-literal">null</span> || data.Length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br><br>        Sort(data, <span class="hljs-number">0</span>, data.Length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Sort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] data, <span class="hljs-built_in">int</span> left, <span class="hljs-built_in">int</span> right</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> l = left, r = right;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">//分区</span><br>        <span class="hljs-built_in">int</span> k = Parttion(data, l, r);<br>        Sort(data, l, k - <span class="hljs-number">1</span>);<br>        Sort(data, k, r);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Parttion</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] data, <span class="hljs-built_in">int</span> low, <span class="hljs-built_in">int</span> hight</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//使用最右边的作为基点</span><br>        <span class="hljs-built_in">int</span> pivot = data[hight];<br>        <span class="hljs-built_in">int</span> less = low,<br>            great = low;<br><br>        <span class="hljs-keyword">for</span> (; great &lt;= hight - <span class="hljs-number">1</span>; great++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (data[great] &lt; pivot)<br>            &#123;<br>                (data[less], data[great]) = (data[great], data[less]);<br>                less++;<br>            &#125;<br>        &#125;<br><br>        (data[less], data[hight]) = (data[hight], data[less]);<br>        <span class="hljs-keyword">return</span> less;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插入类排序"><a href="#插入类排序" class="headerlink" title="插入类排序"></a>插入类排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>插入排序的基本思想是将待排序的元素分成两个部分，一部分是已排序的元素，另一部分是未排序的元素。初始时，已排序的部分只有一个元素，即第一个元素。然后，从未排序的部分取出一个元素，插入到已排序的部分中的正确位置，使得插入后仍然保持已排序部分有序。重复这个过程，直到所有元素都被插入到已排序的部分中，排序完成。</p><p>具体步骤如下：</p><ol><li>从第一个元素开始，认为它已经是一个有序序列。</li><li>取出下一个元素，在已经排序的序列中从后向前扫描。</li><li>如果已排序的序列中的元素大于新元素，将该元素移到下一个位置。</li><li>重复步骤3，直到已排序的序列中的元素小于等于新元素。</li><li>将新元素插入到该位置后。</li><li>重复步骤2~5，直到所有元素都被插入到有序序列中，排序完成</li></ol><p><img src="https://cdn.jsdelivr.net/gh/xichujn/image/img/11.png"></p><p>实现代码为：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 插入排序</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InSertSort</span><br>&#123;<br>    <span class="hljs-comment">//第0个是有序的，依次往后遍历，比较大小然后交换位置</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Sort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] data</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (data.Length == <span class="hljs-literal">null</span> || data.Length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">//0~1是有序的从1开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; data.Length; i++)<br>        &#123;<br>            <span class="hljs-comment">//0~i是想有序的</span><br>            <span class="hljs-comment">// j从i-1开始向前遍历，找到第一个比当前元素大的位置</span><br>            <span class="hljs-comment">// 并且j要大于等于0，避免越界</span><br>            <span class="hljs-comment">// 如果找到了符合条件的位置，就将j+1到i-1的元素向右移动一位</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; data[j] &gt; data[j + <span class="hljs-number">1</span>]; j--)<br>            &#123;<br>                (data[j], data[j+<span class="hljs-number">1</span>]) = (data[j+<span class="hljs-number">1</span>], data[j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是一种基于插入排序的排序算法，也称为缩小增量排序。它通过将待排序的数组分成若干个子序列，对每个子序列进行插入排序，然后逐渐缩小子序列的长度，最终将整个数组排序。</p><p>希尔排序的步骤如下：</p><ol><li>选择一个增量序列，通常为 n&#x2F;2、n&#x2F;4、n&#x2F;8…直到增量为1，其中n为待排序数组的长度。</li><li>对于每个增量，将待排序数组分成若干个子序列，每个子序列包含相距为增量的元素，对每个子序列进行插入排序。</li><li>逐渐减小增量，重复步骤2，直到增量为1时，整个数组排序完成。</li></ol><p>需要注意的是，希尔排序的时间复杂度是O(nlogn)到O(n^2)不等，具体取决于增量序列的选择。</p><p><img src="https://cdn.jsdelivr.net/gh/xichujn/image/img/xrpx.png"></p><p>实现代码为：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 希尔排序</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ShellSort</span><br>&#123;<br>    <span class="hljs-comment">//1.间隔排序 通常为长度的一半</span><br>    <span class="hljs-comment">//2.组内排序</span><br>    <span class="hljs-comment">//3.重新设置间隔分组,为前一次分组的一半</span><br>    <span class="hljs-comment">//4、插入排序</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Sort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] data</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (data.Length == <span class="hljs-literal">null</span> || data.Length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-built_in">int</span> n = data.Length;<br>        <span class="hljs-built_in">int</span> h, j,temp; <span class="hljs-comment">//h为步长 </span><br><br>        <span class="hljs-keyword">for</span> (h = n / <span class="hljs-number">2</span>; h &gt; <span class="hljs-number">0</span>; h /= <span class="hljs-number">2</span>)<br>        &#123;<span class="hljs-comment">//按照增量式子 改变步数h</span><br><br>            <span class="hljs-comment">//组内排序</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = h; i &lt; n; i++)<br>            &#123;<br>                <span class="hljs-comment">//临时保存 步长的值</span><br>                temp = data[i];<br><br>                <span class="hljs-keyword">for</span> (j = i - h; j &gt;= <span class="hljs-number">0</span> &amp;&amp; temp &lt; data[j]; j = j - h)<br>                &#123;<span class="hljs-comment">//从0开始到步长 比较步长和开头的值, 通过j=j-h 改变0位置指针j的位置</span><br>                    data[j + h] = data[j];<br>                &#125;<br>                data[j + h] = temp;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="选择类排序"><a href="#选择类排序" class="headerlink" title="选择类排序"></a>选择类排序</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>选择排序的步骤如下：</p><ol><li>遍历待排序数组，找到最小元素。</li><li>将最小元素与待排序数组的第一个元素交换位置。</li><li>在剩余的元素中继续寻找最小元素，重复步骤1和2，直到所有元素均排序完毕。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/xichujn/image/img/image-20210428094415919.png" alt="image-20210428094415919"></p><p>实现代码为：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 选择排序</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 第一趟从所有的n个记录中选择最小的记录放在第一位，</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 第二趟从n-1个记录中选择最小的记录放到第二位。以此类推，经过n-1趟排序之后，整个待排序序列就成为有序序列了。</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SelectSort</span><br>&#123;<br>    <span class="hljs-comment">//两个指针一个0一个1开始</span><br>    <span class="hljs-comment">//比较两个索引下元素大小，然后交换位置</span><br>    <span class="hljs-comment">//每次选择最小或者最大的放在已经排序集合的后面</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Sort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] data</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (data.Length == <span class="hljs-literal">null</span> || data.Length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; data.Length; i++)<br>        &#123;<br>            <br>            <span class="hljs-built_in">int</span> minIndex = i;<br>            <span class="hljs-comment">//将i之后的值与对比</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = i + <span class="hljs-number">1</span>; j &lt; data.Length; j++)<br>            &#123;<br>                <span class="hljs-comment">//存储j的索引</span><br>                minIndex = data[j] &lt; data[minIndex] ? j : minIndex;<br>            &#125;<br>            <span class="hljs-comment">//将找到的小于i的值进行交换</span><br>            (data[i], data[minIndex]) = (data[minIndex], data[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="归并类排序"><a href="#归并类排序" class="headerlink" title="归并类排序"></a>归并类排序</h2><p>在归并类排序一般只讲归并排序，但是归并排序也分二路归并、多路归并，这里就讲较多的二路归并排序，且用递归方式实现。</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是一种基于分治思想的排序算法，它将待排序的数组分成两个子数组，对每个子数组进行递归排序，最后将两个有序子数组合并成一个有序数组。</p><p>归并排序的步骤如下：</p><ol><li>将待排序的数组分成两个子数组，每个子数组包含大约一半的元素。</li><li>对每个子数组进行递归排序，直到子数组的长度为1。</li><li>将两个有序子数组合并成一个有序数组。合并过程中，比较两个子数组的第一个元素，将较小的元素放入新的数组中，并将该元素所在的子数组的指针向后移动一位，重复该过程直到一个子数组的所有元素都被合并到新的数组中。</li><li>重复步骤3，直到所有的元素都被合并到新的数组中。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/xichujn/image/img/image-20210428094541727.png" alt="image-20210428094541727"></p><p>合并为一个O(n)的过程：</p><p><img src="https://cdn.jsdelivr.net/gh/xichujn/image/img/image-20210428094602560.png" alt="image-20210428094602560"></p><p>实现代码为：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 归并排序</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MergeSort</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Sort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] data</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (data.Length == <span class="hljs-literal">null</span> || data.Length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">//1.拆分为左右两部</span><br>        Splitprocess(data, <span class="hljs-number">0</span>, data.Length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 拆分过程</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 分为左右两部分，然后对他进行排序</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Splitprocess</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] data, <span class="hljs-built_in">int</span> left, <span class="hljs-built_in">int</span> right</span>)</span><br>    &#123;<span class="hljs-comment">//一直拆，拆到两个的元素就进行merge</span><br>        <span class="hljs-keyword">if</span> (left == right) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-built_in">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">//计算得到中间的位置</span><br>        Splitprocess(data, left, mid); <span class="hljs-comment">//归并左边的</span><br>        Splitprocess(data, mid + <span class="hljs-number">1</span>, right); <span class="hljs-comment">//归并右边的</span><br>        merge(data, left, mid, right); <span class="hljs-comment">//将所有序列的归并</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] data, <span class="hljs-built_in">int</span> left, <span class="hljs-built_in">int</span> mid, <span class="hljs-built_in">int</span> right</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//临时空间，比原来数组大1，用来存储合并后的序列</span><br>        <span class="hljs-built_in">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[right - left + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>,<br>            L = left,<br>            M = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//这个其实就是right</span><br>        <span class="hljs-keyword">while</span> (L &lt;= mid &amp;&amp; M &lt;= right)<br>        &#123;<span class="hljs-comment">//将data后一个位置排序到result上，使其有序 然后++ 改变值</span><br>            <span class="hljs-comment">//如果L上的数小于M上的数</span><br>            <span class="hljs-comment">//拷贝到i上 然后++ 下移开始下一个数的比较</span><br>            result[i++] = data[L] &lt;= data[M] ? data[L++] : data[M++];<br>        &#125;<br><br>        <span class="hljs-comment">//越界情况 一般两个中一个</span><br>        <span class="hljs-keyword">while</span> (L &lt;= mid)<br>        &#123;<br>            result[i++] = data[L++];<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (M &lt;= right)<br>        &#123;<br>            result[i++] = data[M++];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> t = <span class="hljs-number">0</span>; t &lt; result.Length; t++)<br>        &#123;<br>            data[left + t] = result[t];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="桶类排序"><a href="#桶类排序" class="headerlink" title="桶类排序"></a>桶类排序</h2><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>桶排序是一种线性排序算法，它的基本思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序，最后将所有的桶中的数据依次取出，组成有序序列。</p><p>具体实现步骤如下：</p><ol><li>确定桶的个数以及每个桶的取值范围。</li><li>遍历待排序数组，将每个元素放入对应的桶中。</li><li>对每个桶中的元素进行排序。</li><li>将所有桶中的元素依次取出，组成有序序列。</li></ol><p>桶排序的时间复杂度取决于桶的个数和每个桶内部排序所用的算法。如果每个桶内部采用快速排序等高效的排序算法，那么桶排序的时间复杂度可以达到 O(nlogn)。但是，如果桶的个数过多，每个桶内部的数据又比较少，那么桶排序的时间复杂度就会退化为 O(n+k)，其中 k 表示桶的个数。此外，桶排序还需要额外的存储空间来存放桶，因此空间复杂度也较高。</p><p><img src="https://cdn.jsdelivr.net/gh/xichujn/image/img/image-20210428094617790.png" alt="image-20210428094617790"></p><p>实现一个简单桶排序：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 桶排序</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BucketSort</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Sort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] data</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (data.Length == <span class="hljs-literal">null</span> || data.Length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">//得到最大值 确定桶的个数</span><br>        <span class="hljs-built_in">int</span> maxValue = data[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> data)<br>        &#123;<br>            maxValue = Math.Max(maxValue, i);<br>        &#125;<br><br>        <span class="hljs-comment">//这里需要注意的是：bucketNum 的计算是根据场景确定的，不同的场景 bucketNum 的计算方式是不同的</span><br>        <span class="hljs-comment">//所以 bucketNum 的计算之前，需要确定桶排序使用的场景 maxValue / 10 + 1; // 39 / 10 + 1 = 4</span><br><br>        <span class="hljs-comment">//这里使用动态计算，即数组长度的平方根向下取整</span><br>        <span class="hljs-built_in">int</span> bucketNum = (<span class="hljs-built_in">int</span>)Math.Floor(Math.Sqrt(data.Length));<br>        List&lt;<span class="hljs-built_in">int</span>&gt;[] buckets = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;[bucketNum];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; bucketNum; i++)<br>        &#123;<br>            buckets[i] = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;(); <span class="hljs-comment">//初始化桶</span><br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; data.Length; i++)<br>        &#123;<br>            <span class="hljs-built_in">int</span> bucketIndex = (<span class="hljs-built_in">int</span>)Math.Floor(data[i] * (bucketNum - <span class="hljs-number">1</span>) / (<span class="hljs-built_in">double</span>)maxValue);<br>            buckets[bucketIndex].Add(data[i]);<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; bucketNum; i++)<br>        &#123;<br>            <span class="hljs-comment">//将每过桶里的值转数组，然后插入排序</span><br>            <span class="hljs-built_in">int</span>[] temp = buckets[i].ToArray();<br><br>            InsertSort(temp);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; temp.Length; j++)<br>            &#123;<span class="hljs-comment">//将排序后的值存会data里</span><br>                data[index++] = temp[j];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InsertSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] data</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; data.Length; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; data[j + <span class="hljs-number">1</span>] &lt; data[j]; j--)<br>            &#123;<br>                (data[j], data[j + <span class="hljs-number">1</span>]) = (data[j + <span class="hljs-number">1</span>], data[j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序是一种特殊的桶排序，每个桶的大小为1，每个桶不在用List表示，而通常用一个值用来计数。</p><ol><li>找出待排序序列中的最大值和最小值。</li><li>统计待排序序列中每个元素出现的次数，可以使用一个计数数组来记录。</li><li>对于每个元素，确定其在有序序列中的位置，可以使用前缀和的方式来计算。</li><li>根据统计信息，将待排序序列中的每个元素放到有序序列中的正确位置上。</li><li>最后得到的就是一个有序的序列。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/xichujn/image/img/image-20210428094631980.png" alt="image-20210428094631980"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 计数排序</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 适合计数范围比较小的数列</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CountSort</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Sort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] data</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (data.Length == <span class="hljs-literal">null</span> || data.Length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br><br><br>        <span class="hljs-comment">//1.通过最大值减去最小值，确定data的取值范围</span><br>        <span class="hljs-built_in">int</span> max = GetMax(data);<br><br>        <span class="hljs-comment">//使用下标来保存，元素出现的次数</span><br>        <span class="hljs-comment">//2.计数数组</span><br>        <span class="hljs-built_in">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[max + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; data.Length; i++)<br>        &#123;<br>            count[data[i]]++;<br>        &#125;<br><br>        <span class="hljs-comment">//计算前缀和 元素+下标为下一个下标的元素值</span><br>        <span class="hljs-comment">//通过前缀和来确定每个元素在排序数组中的最终位置</span><br>        <span class="hljs-comment">//3.累计数组</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; count.Length; i++)<br>        &#123;<br>            <span class="hljs-comment">//从1开始</span><br>            count[i] = count[i] + count[i - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-comment">//排序过程</span><br>        <span class="hljs-comment">//4.结果数组</span><br>        <span class="hljs-built_in">int</span>[] output = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[data.Length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = data.Length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        &#123;<span class="hljs-comment">//因为数组下标是从0开始的，所以当我们要把一个元素放到排序后的数组中时，</span><br>         <span class="hljs-comment">//需要将其下标减1，才能得到正确的位置</span><br>            output[count[data[i]] - <span class="hljs-number">1</span>] = data[i];<br>            count[data[i]]--;<br>        &#125;<br><br>        <span class="hljs-comment">//复制数组回原数组</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; data.Length; i++)<br>        &#123;<br>            data[i] = output[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetMax</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] data</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> max = data[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> data)<br>        &#123;<br>            max = Math.Max(max, i);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><ol><li>将待排序数组中的所有元素统一转化为同样位数的字符串，位数不够的在前面补0。</li><li>从字符串的最右侧（即最低位）开始，按照每一位的大小将所有元素分配到桶中。</li><li>将所有桶中的元素按照桶的顺序依次取出，组成一个新的序列。</li><li>重复步骤2和3，直到所有位都被处理完毕，得到的序列就是排好序的结果。</li></ol><p>需要注意的是，基数排序只适用于元素可以按照位数划分的情况，例如整数、字符串等。在实现过程中，需要使用桶来存储元素，每个桶中的元素需要保持原始顺序不变。同时，为了保证排序的稳定性，每个桶中的元素需要按照进入桶中的顺序依次取出</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 基数排序</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RadixSort</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Sort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] data</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (data.Length == <span class="hljs-literal">null</span> || data.Length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">int</span> max = GetMax(data);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> exp = <span class="hljs-number">1</span>; max / exp &gt; <span class="hljs-number">0</span>; exp *= <span class="hljs-number">10</span>)<br>        &#123;<br>            <span class="hljs-comment">//计算每一位 个位 十位 百位。。。</span><br>            countSort(data, exp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] data, <span class="hljs-built_in">int</span> exp</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//一个存储排序结果，一个存储数字出现的次数</span><br>        <span class="hljs-built_in">int</span>[] output = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[data.Length];<br>        <span class="hljs-built_in">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">10</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; data.Length; i++)<br>        &#123;<br>            <span class="hljs-comment">//取余计算每一位的数字 存储到次数数组对应的下标上加1</span><br>            count[(data[i] / exp) % <span class="hljs-number">10</span>]++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>        &#123;<span class="hljs-comment">//前缀和算法 注意从1开始</span><br>            count[i] = count[i] + count[i - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = data.Length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        &#123;<span class="hljs-comment">//将数字按照位置存储到输出数组中</span><br>            output[count[(data[i] / exp) % <span class="hljs-number">10</span>] - <span class="hljs-number">1</span>] = data[i];<br>            count[(data[i] / exp) % <span class="hljs-number">10</span>]--;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; data.Length; i++)<br>        &#123;<span class="hljs-comment">//复制回原数组</span><br>            data[i] = output[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetMax</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] data</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> max = data[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> data)<br>        &#123;<br>            max = Math.Max(max, i);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">排序算法</th><th align="left">平均时间复杂度</th><th align="left">最好</th><th align="left">最坏</th><th align="left">空间复杂度</th><th align="left">稳定性</th></tr></thead><tbody><tr><td align="left">冒泡排序</td><td align="left">O(n^2)</td><td align="left">O(n)</td><td align="left">O(n^2)</td><td align="left">O(1)</td><td align="left">稳定</td></tr><tr><td align="left">快速排序</td><td align="left">O(nlogn)</td><td align="left">O(nlogn)</td><td align="left">O(n^2)</td><td align="left">O(logn)</td><td align="left">不稳定</td></tr><tr><td align="left">插入排序</td><td align="left">O(n^2)</td><td align="left">O(n)</td><td align="left">O(n^2)</td><td align="left">O(1)</td><td align="left">稳定</td></tr><tr><td align="left">希尔排序</td><td align="left">O(n^1.3)</td><td align="left">O(n)</td><td align="left">O(nlog2n)</td><td align="left">O(1)</td><td align="left">不稳定</td></tr><tr><td align="left">选择排序</td><td align="left">O(n^2)</td><td align="left">O(n^2)</td><td align="left">O(n^2)</td><td align="left">O(1)</td><td align="left">不稳定</td></tr><tr><td align="left">堆排序</td><td align="left">O(nlogn)</td><td align="left">O(nlogn)</td><td align="left">O(nlogn)</td><td align="left">O(1)</td><td align="left">不稳定</td></tr><tr><td align="left">归并排序</td><td align="left">O(nlogn)</td><td align="left">O(nlogn)</td><td align="left">O(nlogn)</td><td align="left">O(n)</td><td align="left">稳定</td></tr><tr><td align="left">桶排序</td><td align="left">O(n+k)</td><td align="left">O(n+k)</td><td align="left">O(n+k)</td><td align="left">O(n+k)</td><td align="left">稳定</td></tr><tr><td align="left">计数排序</td><td align="left">O(n+k)</td><td align="left">O(n+k)</td><td align="left">O(n+k)</td><td align="left">O(k)</td><td align="left">稳定</td></tr><tr><td align="left">基数排序</td><td align="left">O(n*k)</td><td align="left">O(n*k)</td><td align="left">O(n*k)</td><td align="left">O(n+k)</td><td align="left">稳定</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ILRuntime代码热更</title>
    <link href="/2021/12/30/Engine/ILRuntime%E7%83%AD%E6%9B%B4/"/>
    <url>/2021/12/30/Engine/ILRuntime%E7%83%AD%E6%9B%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="1-HelloWord"><a href="#1-HelloWord" class="headerlink" title="1.HelloWord"></a>1.HelloWord</h3><p>将ILRuntime导入在Console中发现大量CS0227报错，那么在Player设置中打开允许不安全代码选项（ILRuntime中使用了指针等不安全代码），如此报错信息就解决了， 随后在Demo目录下有一个HotFix_Project<del>文件夹  这个文件夹以</del>结尾，Unity会忽略掉它。打开HotFix这个项目，生成解决方案，还有报错的话就回到Unity 将 .Net.2.0改成4x。再生成解决方案。</p><p>Unity会生成一个 文件</p><img src="/2021/12/30/Engine/ILRuntime%E7%83%AD%E6%9B%B4/StreamingAssets.png" class=""><p>同时我们在HotFix这个项目内新建一个HotFixHelloWorld的类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">HotFix_Project</span><br>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HotFixHelloWorld</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HelloWorld</span>()</span><br>        &#123;<br>            UnityEngine.Debug.Log(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><p>在HotFix项目外新建一个HotFixMgr的类 来调用这个HotFixHelloWorld的类内的方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HotFixMgr</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">//AppDomain是ILRuntime的入口，最好在一个单例类内保存</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HotFixMgr minstance;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HotFixMgr instance<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (minstance == <span class="hljs-literal">null</span>)<br>            &#123;<br>                minstance = <span class="hljs-keyword">new</span> GameObject(<span class="hljs-string">&quot;HotFixMgr&quot;</span>).AddComponent&lt;HotFixMgr&gt;();<br>                minstance.LoadHotFixAssembly();<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> minstance;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//AppDomain是ILRuntime的入口，最好是在一个单例类中保存，整个游戏全局就一个，这里为了示例方便，每个例子里面都单独做了一个</span><br>    <span class="hljs-comment">//大家在正式项目中请全局只创建一个AppDomain</span><br>    <span class="hljs-keyword">public</span> AppDomain appdomain;<br>    System.IO.MemoryStream fs;<br>    System.IO.MemoryStream p;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoadHotFixAssembly</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//首先实例化ILRuntime的AppDomain，AppDomain是一个应用程序域，每个AppDomain都是一个独立的沙盒</span><br>        appdomain = <span class="hljs-keyword">new</span> ILRuntime.Runtime.Enviorment.AppDomain();<br>        <span class="hljs-comment">//正常项目中应该是自行从其他地方下载dll，或者打包在AssetBundle中读取，平时开发以及为了演示方便直接从StreammingAssets中读取，</span><br>        <span class="hljs-comment">//正式发布的时候需要大家自行从其他地方读取dll</span><br><br>        <span class="hljs-comment">//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br>        <span class="hljs-comment">//这个DLL文件是直接编译HotFix_Project.sln生成的，已经在项目中设置好输出目录为StreamingAssets，在VS里直接编译即可生成到对应目录，无需手动拷贝</span><br>        <span class="hljs-comment">//工程目录在Assets\Samples\ILRuntime\1.6\Demo\HotFix_Project~</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> UNITY_ANDROID</span><br>        WWW www = <span class="hljs-keyword">new</span> WWW(Application.streamingAssetsPath + <span class="hljs-string">&quot;/HotFix_Project.dll&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        WWW www = <span class="hljs-keyword">new</span> WWW(<span class="hljs-string">&quot;file:///&quot;</span> + Application.streamingAssetsPath + <span class="hljs-string">&quot;/HotFix_Project.dll&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        <span class="hljs-keyword">while</span> (!www.isDone)<br>        &#123;<br>            Thread.Sleep(<span class="hljs-number">100</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">string</span>.IsNullOrEmpty(www.error))<br>            UnityEngine.Debug.LogError(www.error);<br>        <span class="hljs-built_in">byte</span>[] dll = www.bytes;<br>        www.Dispose();<br><br>        <span class="hljs-comment">//PDB文件是调试数据库，如需要在日志中显示报错的行号，则必须提供PDB文件，不过由于会额外耗用内存，正式发布时请将PDB去掉，下面LoadAssembly的时候pdb传null即可</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> UNITY_ANDROID</span><br>        www = <span class="hljs-keyword">new</span> WWW(Application.streamingAssetsPath + <span class="hljs-string">&quot;/HotFix_Project.pdb&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        www = <span class="hljs-keyword">new</span> WWW(<span class="hljs-string">&quot;file:///&quot;</span> + Application.streamingAssetsPath + <span class="hljs-string">&quot;/HotFix_Project.pdb&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        <span class="hljs-keyword">while</span> (!www.isDone)<br>        &#123;<br>            Thread.Sleep(<span class="hljs-number">100</span>);<br>        &#125;<br>     <br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">string</span>.IsNullOrEmpty(www.error))<br>            UnityEngine.Debug.LogError(www.error);<br>        <span class="hljs-built_in">byte</span>[] pdb = www.bytes;<br>        fs = <span class="hljs-keyword">new</span> MemoryStream(dll);<br>        p = <span class="hljs-keyword">new</span> MemoryStream(pdb);<br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            appdomain.LoadAssembly(fs, p, <span class="hljs-keyword">new</span> ILRuntime.Mono.Cecil.Pdb.PdbReaderProvider());<br>        &#125;<br>        <span class="hljs-keyword">catch</span><br>        &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;加载热更DLL失败，请确保已经通过VS打开Assets/Samples/ILRuntime/1.6/Demo/HotFix_Project/HotFix_Project.sln编译过热更DLL&quot;</span>);<br>        &#125;<br><br><br>        InitializeILRuntime();<br>        OnHotFixLoaded();<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnHotFixLoaded</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//HotFixMgr.instance.appdomain.Invoke(&quot;HotFix_Project.HotFixHelloWorld&quot;, &quot;HelloWorld&quot;, null, null);</span><br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitializeILRuntime</span>()</span><br>    &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG &amp;&amp; (UNITY_EDITOR || UNITY_ANDROID || UNITY_IPHONE)</span><br>        <span class="hljs-comment">//由于Unity的Profiler接口只允许在主线程使用，为了避免出异常，需要告诉ILRuntime主线程的线程ID才能正确将函数运行耗时报告给Profiler</span><br>        appdomain.UnityMainThreadID = System.Threading.Thread.CurrentThread.ManagedThreadId;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        <span class="hljs-comment">//这里做一些ILRuntime的注册，HelloWorld示例暂时没有需要注册的</span><br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (fs != <span class="hljs-literal">null</span>)<br>            fs.Close();<br>        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">null</span>)<br>            p.Close();<br>        fs = <span class="hljs-literal">null</span>;<br>        p = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><hr><p>随后我们试着输出HelloWord</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Demo_HelloWorld</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">string</span> className = <span class="hljs-string">&quot;HotFix_Project.HotFixHelloWorld&quot;</span>;<br>        <span class="hljs-built_in">string</span> funcName = <span class="hljs-string">&quot;HelloWorld&quot;</span>;<br>        HotFixMgr.instance.appdomain.Invoke(className, funcName, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br><br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><img src="/2021/12/30/Engine/ILRuntime%E7%83%AD%E6%9B%B4/Snipaste_2021-12-30_15-15-35.png" class=""><p>总结：ILRuntime热更的一个基本的流程是将项目代码打包为dll，这个dll可以直接放在项目文件中（DEBUG阶段），也可以打包到AB包中并从远端下载后加载（RELEASE阶段）。在工程中，使用AppDomain调用dll文件中的相应方法即可实现热更新（可以提供一个固定的开始热更新方法并调用这个方法，然后热更新部分再在这个方法中调用其他热更新资源）。</p><h3 id="2-基于ILRuntime实现MonoBehaviour行为"><a href="#2-基于ILRuntime实现MonoBehaviour行为" class="headerlink" title="2.基于ILRuntime实现MonoBehaviour行为"></a>2.基于ILRuntime实现MonoBehaviour行为</h3><p>热更程序集里拥有MonoBehaviour能力</p><p>方法一：继承MonoBehaviour</p><p>因为MonoBehaviour隶属于主程序集，热更程序集 继承 主程序集 属于跨域继承</p><p>运行性能低，而且需要编写接口适配，无论是性能和开发效率都不具备优势</p><p>方法二：自行架构</p><p>主工程 适配器</p><p>HotFixMonoBehaviourAdapter（通过字符串实例化热更对象，并且调用生命周期的方法，例如Awake Start等）</p><p>HotFixMonoBehaviour（实现生命周期函数）</p><hr><p>我们新建HotFixMonoBehaviourAdapter类</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HotFixMonoBehaviourAdapter</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> bindClass;<br>    <span class="hljs-keyword">private</span> IType classType;<br>    <span class="hljs-keyword">private</span> ILTypeInstance instance;<br><br>    <span class="hljs-keyword">private</span> IMethod start_method;<br>    <span class="hljs-keyword">private</span> IMethod update_method;<br>    <span class="hljs-keyword">private</span> IMethod OnDestroy_method;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//需要创建的类型</span><br>        classType = HotFixMgr.instance.appdomain.LoadedTypes[bindClass];<br><br>        <span class="hljs-comment">//创建实例</span><br>        instance = (classType <span class="hljs-keyword">as</span> ILType).Instantiate();<br><br>        <span class="hljs-comment">//通过反射获得生命周期</span><br>        IMethod awake_method = classType.GetMethod(<span class="hljs-string">&quot;Awake&quot;</span>, <span class="hljs-number">0</span>);<br>        start_method = classType.GetMethod(<span class="hljs-string">&quot;Start&quot;</span>, <span class="hljs-number">0</span>);<br>        update_method = classType.GetMethod(<span class="hljs-string">&quot;Update&quot;</span>, <span class="hljs-number">0</span>);<br>        OnDestroy_method = classType.GetMethod(<span class="hljs-string">&quot;OnDestroy&quot;</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">if</span> (awake_method != <span class="hljs-literal">null</span>)<br>        &#123;<br>            HotFixMgr.instance.appdomain.Invoke(awake_method, instance);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (start_method != <span class="hljs-literal">null</span>)<br>        &#123;<br>            HotFixMgr.instance.appdomain.Invoke(start_method, instance);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (update_method != <span class="hljs-literal">null</span>)<br>        &#123;<br>            HotFixMgr.instance.appdomain.Invoke(update_method, instance);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (OnDestroy_method != <span class="hljs-literal">null</span>)<br>        &#123;<br>            HotFixMgr.instance.appdomain.Invoke(OnDestroy_method, instance);<br>        &#125;<br>        instance = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>HotFixMonoBehaviour类</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">namespace</span> <span class="hljs-title">HotFix_Project</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">HotFixMonoBehaviour</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span><br>        &#123;<br>            Debug.Log(<span class="hljs-string">&quot;Awake&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>        &#123;<br>            Debug.Log(<span class="hljs-string">&quot;Start&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>        &#123;<br>            Debug.Log(<span class="hljs-string">&quot;Update&quot;</span>);<br>        &#125; <br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span>()</span><br>        &#123;<br>            Debug.Log(<span class="hljs-string">&quot;OnDestroy&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>将HotFixMonoBehaviourAdapter挂到游戏物体上，传入命名空间和类名</p><img src="/2021/12/30/Engine/ILRuntime%E7%83%AD%E6%9B%B4/Snipaste_2021-12-30_15-37-51.png" class=""><p>随后运行后，我们可以看到我们热更程序集里的脚本都运行了，删除游戏对象后，OnDestroy也执行了</p><img src="/2021/12/30/Engine/ILRuntime%E7%83%AD%E6%9B%B4/1640860053260.png" class=""><h3 id="3-自定义委托注册"><a href="#3-自定义委托注册" class="headerlink" title="3.自定义委托注册"></a>3.自定义委托注册</h3><p>我们在HotFix_Project中添加TestRun脚本写一个点击，同时也要记得把Unity的UIDLl引用添加到我们的HotFix_Project中</p><p>默认情况下只支持Action Func委托</p><p>因为ILRuntime默认情况下只支持系统默认的委托，而UnityAction属于自定义委托，所以我们要自己写委托来兼容，回到HotFixMgr脚本InitializeILRuntime 添加委托</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitializeILRuntime</span>()</span><br>    &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG &amp;&amp; (UNITY_EDITOR || UNITY_ANDROID || UNITY_IPHONE)</span><br>        <span class="hljs-comment">//由于Unity的Profiler接口只允许在主线程使用，为了避免出异常，需要告诉ILRuntime主线程的线程ID才能正确将函数运行耗时报告给Profiler</span><br>        appdomain.UnityMainThreadID = System.Threading.Thread.CurrentThread.ManagedThreadId;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        <span class="hljs-comment">//这里做一些ILRuntime的注册，HelloWorld示例暂时没有需要注册的</span><br><br>        appdomain.DelegateManager.RegisterDelegateConvertor&lt;UnityEngine.Events.UnityAction&gt;((act) =&gt;<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UnityEngine.Events.UnityAction((() =&gt;<br>            &#123;<br>                ((Action) act).Invoke();<br>            &#125;));<br>        &#125;);<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>运行 这时候能看到我们的点击已经被调用了</p><img src="/2021/12/30/Engine/ILRuntime%E7%83%AD%E6%9B%B4/image-20211230185605258.png" class=""><p><strong>CLR优化</strong></p><p>如果，我们在HotFix_Project中访问了Vector3这个成员，由于该结构体的主程序是unity的程序集，这种跨程序集的访问使用的是反射的方法进行访问的，我们就可以使用CLR的绑定避开反射的访问</p><img src="/2021/12/30/Engine/ILRuntime%E7%83%AD%E6%9B%B4/image-20211230190213184.png" class=""><img src="/2021/12/30/Engine/ILRuntime%E7%83%AD%E6%9B%B4/image-20211230190345279.png" class=""><p>接着我们在HotFixMgr类的InitializeILRuntime方法内注册绑定</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//注册CLR绑定,避免过多的反射访问,提升性能</span><br>       ILRuntime.Runtime.Generated.CLRBindings.Initialize(appdomain);<br></code></pre></td></tr></table></figure><p>绑定后，热更工程内的Vector3就不会使用反射的形式了从而提高了性能</p><img src="/2021/12/30/Engine/ILRuntime%E7%83%AD%E6%9B%B4/image-20211230190852367.png" class=""><p>需要热更的部分为两个部分 </p><ul><li>变化频率低的通用业务</li><li>变化频率高的游戏业务</li></ul>]]></content>
    
    
    <categories>
      
      <category>Engine</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSharp</tag>
      
      <tag>ILRuntime</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity资源统一加载</title>
    <link href="/2021/12/25/Engine/Unity%E8%B5%84%E6%BA%90%E7%BB%9F%E4%B8%80%E5%8A%A0%E8%BD%BD/"/>
    <url>/2021/12/25/Engine/Unity%E8%B5%84%E6%BA%90%E7%BB%9F%E4%B8%80%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h4 id="资源类型及加载方式"><a href="#资源类型及加载方式" class="headerlink" title="资源类型及加载方式"></a>资源类型及加载方式</h4><p>1.Resources 直接使用Resource.Load 可以直接加载到资源</p><img src="/2021/12/25/Engine/Unity%E8%B5%84%E6%BA%90%E7%BB%9F%E4%B8%80%E5%8A%A0%E8%BD%BD/image-20211225161613673.png" class="" title="image-20211225161613673"><p>2.Asset Bundles 做打包更新必须需要使用的方式</p><table><thead><tr><th><a href="https://docs.unity3d.com/ScriptReference/AssetBundle.LoadFromMemory.html">AssetBundle.LoadFromMemory</a> 从内存加载，多用在需要严谨的等待逻辑执行完，并且中间不做其他事情</th></tr></thead><tbody><tr><td><a href="https://docs.unity3d.com/ScriptReference/AssetBundle.LoadFromMemoryAsync.html">AssetBundle.LoadFromMemoryAsync</a> 从内存区域异步创建 AssetBundle</td></tr><tr><td><a href="https://docs.unity3d.com/2018.4/Documentation/ScriptReference/AssetBundle.LoadFromFile.html">AssetBundle.LoadFromFile</a> 从硬盘上的文件上加载 支持任何压缩类型的包</td></tr><tr><td><a href="https://docs.unity3d.com/2018.4/Documentation/ScriptReference/AssetBundle.LoadFromFileAsync.html">AssetBundle.LoadFromFileAsync</a> 异步</td></tr><tr><td><a href="https://docs.unity3d.com/2018.4/Documentation/ScriptReference/AssetBundle.LoadFromStream.html">AssetBundle.LoadFromStream</a> 流的方式 边下载边加载 只要是基于流的数据都能创建Bundle 对于要在网络实时加载 最优选择</td></tr><tr><td><a href="https://docs.unity3d.com/2018.4/Documentation/ScriptReference/AssetBundle.LoadFromStreamAsync.html">AssetBundle.LoadFromStreamAsync</a></td></tr></tbody></table><p>3.Raw(Image\Movie) 直接在编辑器或者运行场景中放置的</p><h4 id="Unity资源加载需求"><a href="#Unity资源加载需求" class="headerlink" title="Unity资源加载需求"></a>Unity资源加载需求</h4><p>分析</p><ul><li>发布平台。每一个发布平台的加载情况都不相同</li><li>动态更新&#x2F;流式加载 将运行必须的基础数据放到一个包上 其他内容放到另外一个包上</li><li>压缩加密</li><li>自定义数据包</li></ul><p>关键因数</p><p> Unity资源路径</p><img src="/2021/12/25/Engine/Unity%E8%B5%84%E6%BA%90%E7%BB%9F%E4%B8%80%E5%8A%A0%E8%BD%BD/20220407120919.png" class=""><img src="/2021/12/25/Engine/Unity%E8%B5%84%E6%BA%90%E7%BB%9F%E4%B8%80%E5%8A%A0%E8%BD%BD/20220407120938.png" class=""><img src="/2021/12/25/Engine/Unity%E8%B5%84%E6%BA%90%E7%BB%9F%E4%B8%80%E5%8A%A0%E8%BD%BD/20220407120954.png" class=""><h4 id="Unity资源加载模块设计"><a href="#Unity资源加载模块设计" class="headerlink" title="Unity资源加载模块设计"></a>Unity资源加载模块设计</h4><img src="/2021/12/25/Engine/Unity%E8%B5%84%E6%BA%90%E7%BB%9F%E4%B8%80%E5%8A%A0%E8%BD%BD/20220407121008.png" class=""><p><strong>流程设计</strong></p><img src="/2021/12/25/Engine/Unity%E8%B5%84%E6%BA%90%E7%BB%9F%E4%B8%80%E5%8A%A0%E8%BD%BD/20220407121019.png" class=""><h4 id="Unity自动更新"><a href="#Unity自动更新" class="headerlink" title="Unity自动更新"></a>Unity自动更新</h4><p><strong>实现方案</strong></p><p>服务器为主的优点</p><ul><li>动态生成十几需要更新的版本清单</li><li>一次更新多个版本</li><li>动态更新策略（渠道 区域 比例）</li></ul><p>缺点</p><ul><li><p>机制完善的更新系统，开发成本高</p></li><li><p>服务器压力大，运营成本高</p></li></ul><p>客户端为主优点</p><ul><li>服务器仅作存储压力小</li><li>无服务器逻辑，无开发成本</li></ul><p>缺点</p><ul><li>难以支持动态策略，不灵活</li><li>一次更新到最新成本高</li><li>适合逐版本增量升级</li></ul><p>更新流程</p><img src="/2021/12/25/Engine/Unity%E8%B5%84%E6%BA%90%E7%BB%9F%E4%B8%80%E5%8A%A0%E8%BD%BD/20220407121036.png" class="">]]></content>
    
    
    <categories>
      
      <category>Engine</category>
      
    </categories>
    
    
    <tags>
      
      <tag>花里胡哨</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity AssetBundle</title>
    <link href="/2021/12/24/Engine/%E8%B5%84%E6%BA%90%E6%89%93%E5%8C%85/"/>
    <url>/2021/12/24/Engine/%E8%B5%84%E6%BA%90%E6%89%93%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h4 id="AssetBundle的作用"><a href="#AssetBundle的作用" class="headerlink" title="AssetBundle的作用"></a>AssetBundle的作用</h4><ul><li>AssetBundle相当于是一个资源压缩包，里面的一个个对象，对象有两大类 一类是纯资源的对象，另外一个是Unity序列化的一些游戏对象。包含模型、贴图、预制体、声音、甚至整个场景。</li><li>AssetBundle自身保存着互相的依赖关系;<br>压缩包可以使用LZMA和LZ4压缩算法，减少包大小，更快的进行网络传输；</li><li>把一些可以下载内容放在AssetBundle里面，可以减少安装包的大小；</li><li>版本更新</li><li>减少运行时的内存压力</li><li>DownLoaddable Content（DLC）</li></ul><h4 id="AssetBundle的创建"><a href="#AssetBundle的创建" class="headerlink" title="AssetBundle的创建"></a>AssetBundle的创建</h4><p>设置 Asset Bundle Name</p><img src="/2021/12/24/Engine/%E8%B5%84%E6%BA%90%E6%89%93%E5%8C%85/image-20211224225401208.png" class="" title="image-20211224225401208"><p><strong>Build AssetBundle</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BuildTool</span> <br>&#123;<br>    [<span class="hljs-meta">MenuItem(<span class="hljs-string">&quot;BuildTool/Clear AssetBundles&quot;</span>)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ClearAllAssetBundles</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> allBundles = AssetDatabase.GetAllAssetBundleNames();<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> bundle <span class="hljs-keyword">in</span> allBundles)<br>        &#123;<br>            AssetDatabase.RemoveAssetBundleName(bundle,<span class="hljs-literal">true</span>);<br>            Debug.LogFormat(<span class="hljs-string">&quot;BuildTool:Remove Old Bundle:&#123;0&#125;&quot;</span>,bundle);<br>        &#125;<br>    &#125;<br><br>    [<span class="hljs-meta">MenuItem(<span class="hljs-string">&quot;BuildTool/Build AssetBundles&quot;</span>)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildAllAssetBundles</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">string</span> assetBundleDirectory = <span class="hljs-string">&quot;Assets/AssetBundles&quot;</span>;<br>        <span class="hljs-keyword">if</span> (!Directory.Exists(assetBundleDirectory))<br>        &#123;<br>            Directory.CreateDirectory(assetBundleDirectory);<br>        &#125;<br>        BuildPipeline.BuildAssetBundles(assetBundleDirectory,BuildAssetBundleOptions.None,BuildTarget.StandaloneWindows64);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="AssetBundle的加载"><a href="#AssetBundle的加载" class="headerlink" title="AssetBundle的加载"></a>AssetBundle的加载</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BundleTest</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        StartCoroutine(LoadCharacter(<span class="hljs-string">&quot;Test&quot;</span>));<br>    &#125;<br><br> <span class="hljs-function">IEnumerator <span class="hljs-title">LoadCharacter</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> assetBundleName</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">string</span> uri = <span class="hljs-string">&quot;file:///Assets/AssetBundles/Test&quot;</span>+assetBundleName.ToLower()+<span class="hljs-string">&quot;.asset&quot;</span>;<br>        UnityWebRequest request = UnityWebRequestAssetBundle.GetAssetBundle(uri);<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> request.SendWebRequest();<br>        AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request);<br>        GameObject gameObject=bundle.LoadAsset&lt;GameObject&gt;(assetBundleName);<br>        Instantiate(gameObject); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AB加载方式：</p><ol><li><p>AssetBundle.LoadFromFile 从本地加载</p></li><li><p>AssetBundle.LoadFromMemory 从内存加载</p></li><li><p><a href="WWW.LoadFromCacheOrDownload">WWW.LoadFromCacheOrDownload</a> 下载后放在缓存中备用(该方法逐渐被弃用)</p></li><li><p>UnityWebRequest 从服务器下载</p></li></ol><p>从AB中加载资源：</p><ol><li><p>AssetBundle.LoadAsset(assetName)</p></li><li><p>AssetBundle.LoadAllAssets() 加载AB包中所有的对象，不包含依赖的包</p></li><li><p>AssetBundle.LoadAssetAsync() 异步加载，加载较大资源的时候</p></li><li><p>AssetBundle.LoadAllAssetsAsync() 异步加载全部资源</p></li><li><p>AssetBundle.LoadAssetWithSubAssets 加载资源及其子资源</p></li></ol><p>AB的卸载</p><ol><li>减少内存的使用</li><li>有可能导致丢失</li><li>在切换场景，或者确定不使用的时候卸载<br>AssetBundle.Unload(true) &#x2F;&#x2F;卸载AB文件的内存镜像，且包含所有Load创建出来的对象<br>AssetBundle.Unload(false) &#x2F;&#x2F;卸载AB文件的内存镜像，但是除了Load创建出来的对象<br>Reources.UnloadAsset(Object) &#x2F;&#x2F;释放已加载的资源Object<br>Resources.UnloadUnusedAssets &#x2F;&#x2F;卸载所有没有被场景引用的资源对象</li></ol><h4 id="AssetBundle的进阶"><a href="#AssetBundle的进阶" class="headerlink" title="AssetBundle的进阶"></a>AssetBundle的进阶</h4><h5 id="AssetBundle依赖关系"><a href="#AssetBundle依赖关系" class="headerlink" title="AssetBundle依赖关系"></a>AssetBundle依赖关系</h5><p>1.打包依赖</p><img src="/2021/12/24/Engine/%E8%B5%84%E6%BA%90%E6%89%93%E5%8C%85/20211224233504.png" class=""><p><strong>原本只需要3M的内存，而打包后会发生冗余。</strong></p><p><strong>优化，将共享的资源单独打包一个Bundle</strong></p><img src="/2021/12/24/Engine/%E8%B5%84%E6%BA%90%E6%89%93%E5%8C%85/image-20211224234059208.png" class="" title="image-20211224234059208"><p>同时也要记得在加载Bundle的时候加上加载材质Bundle的代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BundleTest</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        StartCoroutine(LoadCharacter(<span class="hljs-string">&quot;Test&quot;</span>));<br>    &#125;<br><br> <span class="hljs-function">IEnumerator <span class="hljs-title">LoadCharacter</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> assetBundleName</span>)</span><br>    &#123;<br>    <span class="hljs-comment">//Bundle 1</span><br>        <span class="hljs-built_in">string</span> uri = <span class="hljs-string">&quot;file:///Assets/AssetBundles/Test&quot;</span>+assetBundleName.ToLower()+<span class="hljs-string">&quot;.asset&quot;</span>;<br>        UnityWebRequest request = UnityWebRequestAssetBundle.GetAssetBundle(uri);<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> request.SendWebRequest();<br>        AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request);<br>        <br>        <span class="hljs-comment">//Bundle 2</span><br>        <span class="hljs-built_in">string</span> uri2 = <span class="hljs-string">&quot;file:///Assets/AssetBundles/Test/Test.mat.asset&quot;</span>;<br>        UnityWebRequest request2 = UnityWebRequestAssetBundle.GetAssetBundle(uri2);<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> request2.SendWebRequest();<br>        AssetBundle bundle2 = DownloadHandlerAssetBundle.GetContent(request2);<br>        <br>        GameObject gameObject=bundle.LoadAsset&lt;GameObject&gt;(assetBundleName);<br>        Instantiate(gameObject); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.加载依赖</p><img src="/2021/12/24/Engine/%E8%B5%84%E6%BA%90%E6%89%93%E5%8C%85/image-20211225104534276.png" class="" title="image-20211225104534276"><p>这种方式加载，会出现一个问题就是，加载一个model时要加载Bundle里所有的M 加载一个纹理也要加载包里所有的material 贴图也是，出现了资源冗余，那我们就需要一个好的分配</p><h5 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h5><p><strong>1.按类型分组</strong></p><ul><li>强类型关联，将相同的资源打包在一个Bundle</li><li>平台相关，将不同平台下的资源分别打包</li><li>本地化相关</li><li>无交叉依赖 不会对另外一个Bundle产生依赖</li><li>所有声音资源打成一个包，所有shader打成一个包，所有模型打成一个包，所有材质打成一个包</li></ul><p><strong>2.按并发分组</strong></p><ul><li>加载时机一致，在很短的时间内同时发生的资源都打包到一个Bundle</li><li>无交叉依赖</li></ul><p><strong>3.按逻辑单元分组</strong></p><ul><li>逻辑功能 如UI资源 相对独立</li><li>逻辑对象 一个角色或者所有角色一个包</li><li>共享对象 所有的场景所共享的部分一个包</li></ul><h4 id="其他建议"><a href="#其他建议" class="headerlink" title="其他建议"></a><strong>其他建议</strong></h4><ul><li>对频繁更新的对象进行拆分</li><li>同时加载的对象打包到一起</li><li>拆分加载时机不一致的Bundle</li><li>合并频繁加载的小粒度Bundle</li></ul><h4 id="Manifest文件"><a href="#Manifest文件" class="headerlink" title="Manifest文件"></a>Manifest文件</h4><img src="/2021/12/24/Engine/%E8%B5%84%E6%BA%90%E6%89%93%E5%8C%85/image-20211225112845781.png" class="" title="image-20211225112845781"><p>crc为校验码，通过其检查是否完整</p><p>Assets 表示包里包含多少资源</p><p>Dependencies 表示包有哪些依赖</p><p>注意：在加载这些包之前，也需要加载依赖的包，不然会丢失这部分内容，显示效果不正确</p><h4 id="通过Manifest文件得到某个包的依赖"><a href="#通过Manifest文件得到某个包的依赖" class="headerlink" title="通过Manifest文件得到某个包的依赖"></a>通过Manifest文件得到某个包的依赖</h4><img src="/2021/12/24/Engine/%E8%B5%84%E6%BA%90%E6%89%93%E5%8C%85/image-20211225112924258.png" class="" title="image-20211225112924258"><p>可以注意到scene&#x2F;cube.jy依赖于material.jy，而material.jy依赖于texture.jy</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#">AssetBundle manifestAB = AssetBundle.LoadFromFile(<span class="hljs-string">&quot;AssetBundles/AssetBundles&quot;</span>);<br>AssetBundleManifest manifest = manifestAB.LoadAsset&lt;AssetBundleManifest&gt;(<span class="hljs-string">&quot;AssetBundleManifest&quot;</span>);<br><span class="hljs-comment">//GetAllDependencies获取到所有的依赖对象</span><br><span class="hljs-built_in">string</span>[] strs = manifest.GetAllDependencies(<span class="hljs-string">&quot;scene/cube.jy&quot;</span>);<br><span class="hljs-comment">//将所有依赖对象依次加载出来</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> strs)<br>&#123;<br>    Debug.Log(item);  <br>    AssetBundle.LoadFromFile(<span class="hljs-string">&quot;AssetBundles/&quot;</span> + item);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>CRC、MD5、SHA1都是通过对数据进行计算，来生成一个校验值，该校验值用来校验数据的完整性。</p><p>CRC一般用于通信数据的校验，MD5和SHA1用于安全领域，例如文件校验，密码加密等</p><h4 id="AssetBundles浏览工具"><a href="#AssetBundles浏览工具" class="headerlink" title="AssetBundles浏览工具"></a>AssetBundles浏览工具</h4><p><a href="https://github.com/Unity-Technologies/AssetBundles-Browser">工具地址</a></p><img src="/2021/12/24/Engine/%E8%B5%84%E6%BA%90%E6%89%93%E5%8C%85/image-20211225113245114.png" class="" title="image-20211225113245114"><img src="/2021/12/24/Engine/%E8%B5%84%E6%BA%90%E6%89%93%E5%8C%85/image-20211225113256705.png" class="" title="image-20211225113256705"><p>Build Target 用于设置AB包的目标平台</p><p>OutPut Path 设置AB的输出路径</p><p>Build 一键打包</p>]]></content>
    
    
    <categories>
      
      <category>Engine</category>
      
    </categories>
    
    
    <tags>
      
      <tag>花里胡哨</tag>
      
      <tag>Unity</tag>
      
      <tag>AssetBundle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏安全</title>
    <link href="/2021/12/24/Engine/%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8/"/>
    <url>/2021/12/24/Engine/%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="游戏安全"><a href="#游戏安全" class="headerlink" title="游戏安全"></a>游戏安全</h1><h3 id="常见威胁"><a href="#常见威胁" class="headerlink" title="常见威胁"></a>常见威胁</h3><p>1.<strong>外挂</strong></p><ul><li>加速挂 单机加速，修改本地计算机的时钟周期 网络加速 加快发包速度</li><li>协议挂 破解通讯协议 模拟游戏行为 功能丰富，支持脱机</li><li>内存挂 基于Hook（拦截系统对API的调用行为）和注入技术 功能强大</li><li>脚本辅助 键盘鼠标模拟 不易检测</li></ul><p>2.破解</p><p>3.数据篡改</p><ul><li>内存数据</li><li>存档数据</li><li>通讯数据</li></ul><h3 id="游戏安全的基础应对"><a href="#游戏安全的基础应对" class="headerlink" title="游戏安全的基础应对"></a>游戏安全的基础应对</h3><p><strong>通用方案</strong></p><ul><li><p>进程检测：获取电脑后台进程，对常见外挂的进程创建黑名单</p></li><li><p>窗口检测：因为很多外挂都有窗口的特性，对外挂窗口进行关闭</p></li><li><p>HOOK检测：自己创建一个Hook，通过对方攻击的手段，修复</p><p><strong>加密 混淆 加壳</strong></p></li></ul><p>对数据进行保护 内存及存档</p><p><strong>内存分析工具 WireShark</strong></p><p><strong>Cheat Engine</strong></p><img src="/2021/12/24/Engine/%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8/image-20211224211902025.png" class="" title="image-20211224211902025"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SateTest</span> ：<span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-built_in">int</span> magic = <span class="hljs-number">0x1110004</span>;<br>    <br>    <span class="hljs-keyword">public</span> Text hpText;<br>    <span class="hljs-keyword">public</span> Text mpText;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> hp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> HP<br>    &#123;<br>        <span class="hljs-keyword">get</span>&#123; <span class="hljs-keyword">return</span> hp; &#125;<br>        <span class="hljs-keyword">set</span>&#123; hp = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> mp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MP<br>    &#123;<br>        <span class="hljs-keyword">get</span>&#123; <span class="hljs-keyword">return</span> mp; &#125;<br>        <span class="hljs-keyword">set</span>&#123; mp = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>()</span><br>    &#123;<br>    <span class="hljs-keyword">this</span>.HP += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">this</span>.MP += <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>    <span class="hljs-keyword">this</span>.hpText.text = HP.ToString(); <br>        <span class="hljs-keyword">this</span>.mpText.text = ((<span class="hljs-built_in">int</span>)MP).ToString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 开启<strong>Cheat Engine</strong>选择Unity的进程</p><img src="/2021/12/24/Engine/%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8/image-20211224212605532.png" class="" title="image-20211224212605532"><p>重复Add操作和数值扫描操作</p><p>随后选中一个地址将地址加入到地址列表，然后修改数值 如30改成300</p><img src="/2021/12/24/Engine/%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8/image-20211224212937708.png" class="" title="image-20211224212937708"><p>可以看见对进程内存进行修改后 Unity的值也同样修改了。</p><p>实现了对内存值的修改。</p><p>所以我们应该对进程进行加密，让别人找不到这些地址</p><p><strong>位运算异或</strong></p><p>修改的代码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SateTest</span> ：MonoBehaviour<br>&#123;<br>    <span class="hljs-type">int</span> magic = <span class="hljs-number">0x1110004</span>;<br>    <br>    <span class="hljs-keyword">public</span> Text hpText;<br>    <span class="hljs-keyword">public</span> Text mpText;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> hp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> HP<br>    &#123;<br>        get&#123; <span class="hljs-keyword">return</span> hp ^ magic ; &#125;<br>        set&#123; hp = value ^ magic ; &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> Long mp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> MP;<br>    &#123;<br>        get&#123; <span class="hljs-keyword">return</span> (<span class="hljs-type">float</span>)System.BitConverter.<span class="hljs-built_in">Int64BitsToDouble</span>(mp ^ magic); &#125;<br>        set&#123; mp = System.BitConverter. <span class="hljs-built_in">Int64BitsToDouble</span>(value)^ magic; &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>    <span class="hljs-keyword">this</span>.HP += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">this</span>.MP += <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Update</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>    <span class="hljs-keyword">this</span>.hpText.text = HP.<span class="hljs-built_in">ToString</span>(); <br>        <span class="hljs-keyword">this</span>.mpText.text = ((<span class="hljs-type">int</span>)MP).<span class="hljs-built_in">ToString</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个简单的位运算操作。就会让别人找不到你的数值地址</p><img src="/2021/12/24/Engine/%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8/image-20211224214207625.png" class="" title="image-20211224214207625"><p>对于常规的数值修改很有效</p>]]></content>
    
    
    <categories>
      
      <category>Engine</category>
      
    </categories>
    
    
    <tags>
      
      <tag>花里胡哨</tag>
      
      <tag>Unity</tag>
      
      <tag>技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程和线程安全</title>
    <link href="/2021/12/23/CSharp/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <url>/2021/12/23/CSharp/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程和线程安全"><a href="#多线程和线程安全" class="headerlink" title="多线程和线程安全"></a>多线程和线程安全</h1><p><strong>多线程解决什么问题：多任务，提升计算性能</strong></p><h5 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h5><ul><li>单线程单任务 (Task1 &#x3D;&gt; Task2 &#x3D;&gt; Task3)</li><li>单线程多任务 (Task1 &#x3D;&gt; Task2 &#x3D;&gt; Task3 &#x3D;&gt; Task1 &#x3D;&gt; Task2 &#x3D;&gt; Task3 &#x3D;&gt; Task1 &#x3D;&gt; Task2 &#x3D;&gt; Task3)</li><li>多线程单任务 (任务Task 开启多线程 Task1-1 Task1-2 Task1-3 Task1-4)</li><li>多任务多线程 （Task1-1 Task1-2 Task1-3 Task1-4)(Task2-1 Task2-2)(Task3)(Task4)</li></ul><p><strong>线程的数量最好是CPU核的倍数</strong></p><h5 id="如何安全的使用多线程"><a href="#如何安全的使用多线程" class="headerlink" title="如何安全的使用多线程"></a>如何安全的使用多线程</h5><p><strong>多线程的问题：线程安全和非线程安全</strong></p><p><strong>1、线程与数据&#x2F;资源</strong></p><p>因为每一个线程都会访问到数据，而数据不做手段保护，就有可能会出现数据混乱(因为数据是在多个线程中共享的)，而在Unity中把所有于逻辑相关的东西，强制必须都是在单线程内，其他线程不访问，在底层做了一层防范，保证所有的事情是在一个线程内发生，就不会出现这种情况。</p><p><strong>同步与锁</strong></p><p>用于同步的对象 当你考虑好你的线程方案后，会有各种锁选择</p><h6 id="1-lock"><a href="#1-lock" class="headerlink" title="1.lock"></a>1.<strong>lock</strong></h6><p>最暴力简单，使用起来没什么成本，但加锁后可能会有性能问题。使后进入的线程不会中断当前的线程，而是等待当前线程结束后再继续执行。</p><h6 id="2-Monitor（对象）"><a href="#2-Monitor（对象）" class="headerlink" title="2.Monitor（对象）"></a>2.<strong>Monitor（对象）</strong></h6><p>属于lock的底层 更加开放 lock是对Monitor的Enter和Exit的一个封装，因此Monitor类的Enter()和Exit()方法的组合使用可以用lock关键字替代。</p><p>Monitor类除了具有lock的功能外，还有以下功能：</p><p>TryEnter()解决长期死等的问题，如果一个并发经常发生，并且持续时间很长，使用TryEnter，可以有效防止死锁或者长时间 的等待。  </p><p>Wait()释放对象上的锁，以便允许其他线程锁定和访问该对象。在其他线程访问对象时，调用线程将等待。脉冲信号用于通知等待线程有关对象状态的更改。</p><p>Pulse(),PulseAll()向一个或多个等待线程发送信号。该信号通知等待线程锁定对象的状态已更改，并且锁的所有者准备释放该锁。等待线程被放置在对象的就绪队列中以便它可以最后接收对象锁。一旦线程拥有了锁，它就可以检查对象的新状态以查看是否达到所需状态。</p><p>注意：Pulse、PulseAll和Wait方法必须从同步的代码块内调用。</p><h6 id="3-Mutex-（互斥）"><a href="#3-Mutex-（互斥）" class="headerlink" title="3.Mutex （互斥）"></a>3.<strong>Mutex （互斥）</strong></h6><p>Mutex的突出特点是可以跨应用程序域边界对资源进行独占访问，即可以用于同步不同进程中的线程，这种功能是以牺牲更多的系统资源为代价的。  </p><p>互斥体Mutex和事件对象EventWaitHandler属于内核对象，利用内核对象进行线程同步，线程必须要在用户模式和内核模式间切换，所以一般效率很低，但利用互斥对象和事件对象这样的内核对象，可以在多个进程中的各个线程间进行同步。</p><p>互斥体Mutex类似于一个接力棒，拿到接力棒的线程才可以开始跑，当然接力棒一次只属于一个线程(Thread Affinity)，如果这个线程不释放接力棒(Mutex.ReleaseMutex)，那么其他所有需要接力棒运行的线程只能等着看热闹</p><h6 id="4、ReaderWriterLockSlim（多线程读单线程写）"><a href="#4、ReaderWriterLockSlim（多线程读单线程写）" class="headerlink" title="4、ReaderWriterLockSlim（多线程读单线程写）**"></a>4、ReaderWriterLockSlim（多线程读单线程写）**</h6><p>当线程A已经获取到ReaderWriterLockSlim实例的读锁（RedLock,UpgradeableReaLock）后，其它线程只能再获取到该ReaderWriterLockSlim实例的读锁，再申请获取写锁会被阻塞</p><p>当线程A已获取到ReaderWriterLockSlim实例的写锁后，其它线程再申请获取到该ReaderWriterLockSlim实例的写锁和读锁时会被阻塞，直到线程A释放写锁</p><p>注意事项</p><p>（1）线程A如果通过EnterReadLock获取到读锁（ReadLock）后，不能在持有读锁的情况下再申请获取写锁（WriteLock）</p><p>如果违反了这个规定就报如下错：<br>Write lock may not be acquired with read lock held. This pattern is prone to deadlocks. Please ensure that read locks are released before taking a write lock. If an upgrade is necessary, use an upgrade lock in place of the read lock.</p><p>（2）线程A如果通过EnterReadLock获取到读锁（ReadLock）后，不能在持有读锁的情况下再申请获取可升级读锁（UpgradeableReadLock）</p><p>如果违反了这个规定就报如下错：<br>Upgradeable lock may not be acquired with read lock held</p><p>（3）线程A如果通过EnterUpgradeableReadLock获取到可升级读锁（UpgradeableReadLockk）后，可以再持有可升级读锁的情况通过EnterWriteLock获取写锁</p><h6 id="5-Semaphore（信号量）"><a href="#5-Semaphore（信号量）" class="headerlink" title="5.Semaphore（信号量）"></a>5.<strong>Semaphore</strong>（信号量）</h6><p>可理解为允许线程执行信号的池子，池子中放入多少个信号就允许多少线程同时执行。</p><p>说明：</p><p>1、如果semaphore.Release(n)，n&gt;semaphore最大容纳信号量，将出异常。<br>2、当semaphore拥有的信号量为1时，Semaphore相当于Mutex<br>3、当semaphore拥有的信号量&gt;1时，信号量的数量即可供多个线程同时获取的个数，此时可认为获取到信号量的线程将同时执行（实际情况可能与CPU核心数、CPU同时支出线程数有关）</p><p>在调控线程的资源方面更加的灵活</p><h6 id="6、Interlocked（原子锁）"><a href="#6、Interlocked（原子锁）" class="headerlink" title="6、Interlocked（原子锁）"></a>6、Interlocked（原子锁）</h6><p>提供对变量快速操作的一种方式 从而实现线程的同步</p><img src="/2021/12/23/CSharp/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/%E5%8E%9F%E5%AD%90%E9%94%81.png" class=""><h5 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h5><p>对象 如：对列表加锁，列表所有的增删改都等待。</p><p>操作 如：只写读操作和写操作</p><p>变量 如：原子锁 锁定的级别越小 影响的范围越小</p><p><strong>只在必要时候加锁，加锁的力度越小越好</strong></p>]]></content>
    
    
    <categories>
      
      <category>CSharp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSharp</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>粘包和拆包</title>
    <link href="/2021/12/23/CSharp/%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/"/>
    <url>/2021/12/23/CSharp/%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="粘包和拆包-解决方法"><a href="#粘包和拆包-解决方法" class="headerlink" title="粘包和拆包 解决方法"></a>粘包和拆包 解决方法</h1><h2 id="拆包-粘包"><a href="#拆包-粘包" class="headerlink" title="拆包 粘包"></a>拆包 粘包</h2><p>当客户端向服务器连续发送两个数据包后，服务端接收数据可以分成三种情况</p><p>一、服务端正常的收到这两个数据包 没有发生粘包和拆包的情况</p><p>二、服务端只接收到一个数据包 ，而TCP是不会发生丢包的情况的，所以这一个数据包就包含了客户端发送的两个数据包 这就被称为粘包。</p><p>发送的时候，数据是有一个数据缓冲区的，比如数据缓冲区是200，我们一个包是100 就会把缓冲区填满，填满之后呢 我们数据缓冲区就会把这个包发送出去，这两个包呢就会被粘在一起，合并成了一个发送。相当于我们人发快递，发送两根笔，一根笔是一份快递钱，那么我们就会把两根笔合成一份快递发送。而缓冲区呢，当第一次没有填满，那么它就会等到填满了，一块往服务端发送，这样就出现粘包的问题。</p><p>三、服务端接收到了两个数据包，但是这两个数据包，会出现要么不完整，或者多出来一部分的情况，这种情况呢就是发生了拆包和粘包。</p><p>就相当于在数据缓冲区中，我们数据缓冲区是200，而我们一个包的长度呢是150 这时候进入缓冲区，而缓冲区没有被填满，就会等待填满，而缓冲区填满后就出现了另外一个数据包不全的情况 一个数据包多出了一部分 这就是发生了拆包和粘包</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>粘包、拆包发生原因 （常见几种）</p><ol><li><p>要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。</p></li><li><p>待发送数据大于最大报文长度，TCP在传输前将进行拆包。</p></li><li><p>要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。</p></li><li><p>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</p></li></ol><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>发送端给每一个数据包构造一个包头与包尾，包头内包含了数据包的长度，包尾才是真正的数据包 当接收端接收到数据包后，首先先读取数据包的前四个字节（int值只占四个字节）拿到数据包的长度后，再往后依次读取我们的数据包。</p><h2 id="构造包和解析包"><a href="#构造包和解析包" class="headerlink" title="构造包和解析包"></a>构造包和解析包</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.IO;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">MyServer</span><br>&#123;<br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> /构造包 包头+包尾</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EncodeTool</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">byte</span>[] <span class="hljs-title">EncodePacket</span>(<span class="hljs-params"><span class="hljs-built_in">byte</span>[] data</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">using</span> (MemoryStream ms = <span class="hljs-keyword">new</span> MemoryStream())<br>            &#123;<br>                <span class="hljs-keyword">using</span> (BinaryWriter bw=<span class="hljs-keyword">new</span> BinaryWriter(ms))<br>                &#123;<br>                    <span class="hljs-comment">//写入包头（数据的长度）</span><br>                    bw.Write(data.Length);<br>                    <span class="hljs-comment">//写入包尾（数据）</span><br>                    bw.Write(data);<br>                    <span class="hljs-built_in">byte</span>[] packet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[ms.Length];<br>                    Buffer.BlockCopy(ms.GetBuffer(), <span class="hljs-number">0</span>, packet, <span class="hljs-number">0</span>, (<span class="hljs-built_in">int</span>)ms.Length);<br>                    <span class="hljs-keyword">return</span> packet;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> /解析包，从缓冲区里取出一个完整的包</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;cache&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">byte</span>[] <span class="hljs-title">DecodePacket</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> List&lt;<span class="hljs-built_in">byte</span>&gt; cache</span>)</span><br>        &#123;<br>            <span class="hljs-comment">//如果数据长度小于四个字节，说明没有包</span><br>            <span class="hljs-keyword">if</span> (cache.Count &lt; <span class="hljs-number">4</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-keyword">using</span> (MemoryStream ms=<span class="hljs-keyword">new</span> MemoryStream(cache.ToArray()))<br>            &#123;<br>                <span class="hljs-keyword">using</span>(BinaryReader br=<span class="hljs-keyword">new</span> BinaryReader(ms))<br>                &#123;<br>                    <span class="hljs-comment">//读取包的长度</span><br>                    <span class="hljs-built_in">int</span> length = br.ReadInt32();<br>                    <span class="hljs-comment">//当前的长度减去，读取字节后游标的长度，就是包的数据 </span><br>                    <span class="hljs-built_in">int</span> remainLength = (<span class="hljs-built_in">int</span>)(ms.Length - ms.Position);<br>                    <span class="hljs-keyword">if</span> (length &gt; remainLength)<br>                    &#123;<br>                        <span class="hljs-comment">//如果大于减去后的长度麻将构不能一个包</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                    &#125;<br>                    <span class="hljs-built_in">byte</span>[] data = br.ReadBytes(length);<br>                    <span class="hljs-comment">//更新缓冲数据</span><br>                    cache.Clear();<br>                    cache.AddRange(br.ReadBytes(remainLength));<br>                    <span class="hljs-keyword">return</span> data;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CSharp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>花里胡哨</tag>
      
      <tag>CSharp</tag>
      
      <tag>Socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSahrp Socket连接</title>
    <link href="/2021/12/23/CSharp/Socket%E8%BF%9E%E6%8E%A5/"/>
    <url>/2021/12/23/CSharp/Socket%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="C-实现Socket连接"><a href="#C-实现Socket连接" class="headerlink" title="C#实现Socket连接"></a>C#实现Socket连接</h1><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ol><li><p>建立Socket</p><p>AddressFamily.InterNetwork内网，SocketType.Stream以流来通信，Tcp为协议</p></li><li><p>电脑主机和端口和ip地址进行绑定</p></li><li><p>监听客户端连接</p></li><li><p>阻塞方法  生成Socket 接受客户端连接</p></li><li><p>声明数组，存放聊天的缓冲区。</p></li><li><p>使用while方法 , 接收数据并存放在数组中 实现多次接消息</p></li><li><p>还原接收信息为明文</p></li><li><p>实现客服给客户发消息</p></li></ol><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Net;<br><span class="hljs-keyword">using</span> System.Net.Sockets;<br><span class="hljs-keyword">using</span> System.Text;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">SocketDemo</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-comment">//创建Socket 相当于是通信的主机</span><br>            <span class="hljs-comment">//监听打进来的电话，并转接给客服</span><br>            Socket serverSocket = <span class="hljs-keyword">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);<br><br>            <span class="hljs-comment">//绑定ip和端口</span><br>            EndPoint iped = IPEndPoint.Parse(<span class="hljs-string">&quot;192.168.43.227:1234&quot;</span>);<br>            serverSocket.Bind(iped);<br><br>            <span class="hljs-comment">//监听有没有电话连接，顺便规划客服人数,如果是0就是无限个客服</span><br>            serverSocket.Listen(<span class="hljs-number">100</span>);<br><br>            <span class="hljs-comment">//接电话</span><br>            <span class="hljs-comment">//分配客服和客户进行一对一通信</span><br>            <span class="hljs-comment">//阻塞方法 没有电话打进来，那么代码就执行到这里 Accept</span><br>            Socket kefuScoket = serverSocket.Accept();<br>            System.Console.WriteLine(<span class="hljs-string">&quot;客户的本地端口是：&quot;</span> + kefuScoket.LocalEndPoint.ToString());<br>            System.Console.WriteLine(<span class="hljs-string">&quot;打电话进来的客户端是：&quot;</span> + kefuScoket.RemoteEndPoint.ToString());<br><br>            <span class="hljs-comment">//接消息，需要一个消息的缓冲区</span><br>            <span class="hljs-built_in">byte</span>[] readBuff = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">1024</span>];<br><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>            &#123;<br>                <span class="hljs-comment">//消息拿到，并存放在缓冲区，并记住消息的长度</span><br>                <span class="hljs-built_in">int</span> receiveCount = kefuScoket.Receive(readBuff);<br>                <span class="hljs-built_in">string</span> receiveMessage = Encoding.UTF8.GetString(readBuff, <span class="hljs-number">0</span>, receiveCount);<br>                System.Console.WriteLine(<span class="hljs-string">&quot;客户端发过来的消息：&quot;</span> + receiveMessage);<br><br>                <span class="hljs-comment">//string backMessage = &quot;我是你的专属客服，有什么可以帮助你的&quot;;</span><br>                kefuScoket.Send(Encoding.UTF8.GetBytes(<span class="hljs-string">&quot;服务器已经接到你发来的消息：&quot;</span> + receiveMessage));<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ol><li>建立Socket</li><li>Connect连接服务端</li><li>try catch语句 捕捉异常</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Net;<br><span class="hljs-keyword">using</span> System.Net.Sockets;<br><span class="hljs-keyword">using</span> System.Text;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">clientSocket</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br><br>            Socket clientSocket = <span class="hljs-keyword">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);<br>            <span class="hljs-comment">//接收服务器的回馈</span><br>            <span class="hljs-built_in">byte</span>[] readBuff = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">1024</span>];<br><br>            <span class="hljs-comment">//连接服务器</span><br>            clientSocket.Connect(<span class="hljs-string">&quot;192.168.43.227&quot;</span>, <span class="hljs-number">1234</span>);<br><br>            <span class="hljs-comment">//连接上服务器，就能发消息</span><br>            <span class="hljs-built_in">string</span> sendMessage;<br><br>            <span class="hljs-comment">//计数器</span><br>            <span class="hljs-built_in">int</span> num = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>)<br>                &#123;<br>                    sendMessage = <span class="hljs-string">&quot;你好，我是192用户&quot;</span>;<br>                    num++;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    sendMessage = Console.ReadLine();<br>                &#125;<br><br>                <span class="hljs-comment">//转码，转成0101010的格式</span><br>                <span class="hljs-built_in">byte</span>[] sendBytes = Encoding.UTF8.GetBytes(sendMessage);<br><br>                <span class="hljs-comment">//把二进制的消息发出去</span><br>                clientSocket.Send(sendBytes);<br>                <span class="hljs-built_in">int</span> count = clientSocket.Receive(readBuff);<br>                System.Console.WriteLine(<span class="hljs-string">&quot;服务器发送的消息是：&quot;</span> + Encoding.UTF8.GetString(readBuff, <span class="hljs-number">0</span>, count));<br><br>            &#125;<br><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="C-Socket各种类"><a href="#C-Socket各种类" class="headerlink" title="C#Socket各种类"></a>C#Socket各种类</h4><p>一、IP地址操作类</p><p>1、IPAddress类</p><p>在该类中有一个Parse()方法，可以把点分的十进制转换成IPAddress类，方法1如下：IPAddress address&#x3D;IPAddress.Parse(“192.168.0.1”);</p><p>IPAddress 提供4个只读字段</p><ol><li>Any 用于代表本地系统可用的任何IP地址 常用来表示本机所有的IP地址 方便于对Socket服务进行监听，</li><li>Broadcase用于代表本地网络的IP广播地址 UDP的IP广播</li><li>Loopback用于代表系统的回送地址</li><li>None用于代表系统是没有网络接口</li></ol><p>2、IPEndPoint类</p><p>我们可以通过二种构造方法创建IPEndPoint类   就是一个IP地址端口的绑定 可以代表一个服务，用来Socket通讯</p><p>a、IPEndPoint(long address,int port)</p><p>b、IPEndPoint(IPAddress address,int port)</p><p>四种属性：Address  AddressFamily Port MaxPort  MinPort</p><p>二、DNS相关类</p><p>DNS类有四个静态方法，来获取主机DNS相关信息</p><ol><li>GetHostName（） 通过DNS.GetHostName()可以获得本地计算机的主机名</li><li>GetHostByName() 根据主机名称，返回一个IPHostEntry对象：IPHostEntry GetHostByName(string hostName) 其中IPHostEntry 把一个DNS主机名与一个别名和IP地址的数组相关联，包括三个属性：AddressList：一个IPAddress对象的数组   Aliases：一个字符串对象数组 HostName一个用于主机名的字符串对象</li><li>GetHostByAddress() 类似于GetHostByName(),只不过这里的参数是IP地址，而不是主机名，返回一个IPHostEntry对象。  IPHostEntry GetHostByAddress(IPAddress address)   IPHostEntry GetHostByAddress(string address)</li><li>Resolve()   当我们不知道输入的主机的地址是哪种格式时，用以上两种方法来实现，我们可能还要通过判断客户输入的格式，才能正确使用，但DNS类提供更简单的方法Resolve（），该方法可以接收或者是主机名格式或者是IP地址格式的任何一种地址，并返回IPHostEntry对象</li></ol>]]></content>
    
    
    <categories>
      
      <category>CSharp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>花里胡哨</tag>
      
      <tag>CSharp</tag>
      
      <tag>Socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络基础</title>
    <link href="/2021/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h1><h2 id="OSI-TCP-UDP"><a href="#OSI-TCP-UDP" class="headerlink" title="OSI TCP UDP"></a>OSI TCP UDP</h2><img src="/2021/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png" class=""><p>OSI七层协议除了最高层，下面每一层都给上面一层提供服务。</p><p>TCP面向连接（如打电话要先拨号建立连接）；UDP是无连接的既发送数据之前不需要建立连接</p><p>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，既不保证可靠交付。（QQ和微信通话就是UDP，因为不需要保证可靠的交付，服务器是TCP，因为要保证客户数据无差错的 不丢失的）</p><p>TCP面向 字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文</p><p>每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信</p><h2 id="IP-端口号"><a href="#IP-端口号" class="headerlink" title="IP 端口号"></a>IP 端口号</h2><p>主机是有一个IP地址的，主机与主机之间想要互相通信，联系的话，就需要通过IP地址，服务器要给客户端发送一个消息的话，服务器如果想要识别到客户端在我们主机上的哪一个位置的话，就需要用到端口号 端口号相当于人的姓名一样。</p><img src="/2021/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%9F%8E%E5%9F%9F.png" class=""><p>应用层-套接字Socket</p><p>应用程序和网络之间的应用程序接口API，是在网络是建立网络应用程序的可编程接口</p><p>应用层-进程</p><img src="/2021/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B.png" class=""><p>进程类似房子 套接字是进程的门 </p><p>进程通过套接字在网络上发送和接收报文</p><p>发送进程；把报文退出门（套接字）</p><p>传送报文；通过下面网络把报文传送到目的进程门口</p><p>接收进程：通过门（套接字）接收报文</p><img src="/2021/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%BF%87%E7%A8%8B.png" class=""><p>Socket编程</p><p>服务端</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Net;<br><span class="hljs-keyword">using</span> System.Net.Sockets;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">SocketServerTest</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-keyword">static</span> Socket serverSocket;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            serverSocket = <span class="hljs-keyword">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);<br><br>            <span class="hljs-comment">//绑定端口和ip 端口在0-65535之间</span><br>            serverSocket.Bind(<span class="hljs-keyword">new</span> IPEndPoint(IPAddress.Parse(<span class="hljs-string">&quot;127.0.0.1&quot;</span>), <span class="hljs-number">6666</span>));<br>            serverSocket.Listen(<span class="hljs-number">10</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;服务器启动成功&quot;</span>);<br>            Thread thread = <span class="hljs-keyword">new</span> Thread(AcceptClient);<br>            <span class="hljs-comment">//启动</span><br>            thread.Start();<br><br>            Console.ReadKey();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AcceptClient</span>()</span><br>        &#123;<br>            Socket clientSocket = serverSocket.Accept();<br>            <span class="hljs-built_in">byte</span>[] data = Encoding.Default.GetBytes(<span class="hljs-string">&quot;服务器告诉你连接成功了&quot;</span>);<br>            clientSocket.Send(data);<br>            <span class="hljs-comment">//生成方法</span><br>            Thread thread = <span class="hljs-keyword">new</span> Thread(ReveiveMsg);<br>            thread.Start(clientSocket);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReveiveMsg</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> clientSocket</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-built_in">int</span> length = (clientSocket <span class="hljs-keyword">as</span> Socket).Receive(data);<br>            Console.WriteLine(Encoding.Default.GetString(data, <span class="hljs-number">0</span>, length));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Net;<br><span class="hljs-keyword">using</span> System.Net.Sockets;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">SocketClientTest</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Socket clientScoket;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            clientScoket = <span class="hljs-keyword">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);<br>            clientScoket.Connect(<span class="hljs-keyword">new</span> IPEndPoint(IPAddress.Parse(<span class="hljs-string">&quot;127.0.0.1&quot;</span>), <span class="hljs-number">6666</span>));<br>            Console.WriteLine(<span class="hljs-string">&quot;与服务器建立了连接&quot;</span>);<br>            clientScoket.Send(Encoding.Default.GetBytes(<span class="hljs-string">&quot;客户端发送的一条消息&quot;</span>));<br>            Thread thread = <span class="hljs-keyword">new</span> Thread(Receive);<br>            thread.Start();<br><br>            Console.ReadKey();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Receive</span>()</span><br>        &#123;<br>            <span class="hljs-built_in">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-built_in">int</span> length = clientScoket.Receive(data);<br>            Console.WriteLine(Encoding.Default.GetString(data, <span class="hljs-number">0</span>, length));<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>花里胡哨</tag>
      
      <tag>Socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AOI</title>
    <link href="/2021/12/23/Engine/AOI/"/>
    <url>/2021/12/23/Engine/AOI/</url>
    
    <content type="html"><![CDATA[<h2 id="AOI"><a href="#AOI" class="headerlink" title="AOI"></a>AOI</h2><h4 id="概念-广播的类型"><a href="#概念-广播的类型" class="headerlink" title="概念-广播的类型"></a>概念-广播的类型</h4><p>广播范围</p><ol><li>全服广播 特点：每一个玩家都能接收，频率不会太高，15帧左右</li><li>地图广播 特点：频率越高越好 ，玩家同步，地图同步类型 实时同步给身边的人</li><li>社交关系 特点：频率不会特别高，根据社交定</li><li>交互目标 特点：和别人进行的一对一的，点对点的，PVP的 频率低</li><li>玩家自身 特点：严格不能算广播，客户端与服务器的广播。大部分行为只需要自身知道的</li></ol><h5 id="地图消息同步"><a href="#地图消息同步" class="headerlink" title="地图消息同步"></a>地图消息同步</h5><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211206092201838.png" alt="image-20211206092201838"></p><p>将上面比作一个地图，点比作玩家，每一个点动了，应该把他的行为同步给身边的玩家（100X100 1s同步10次 1s&#x3D;10000次消息处理 ~3.mb&#x2F;s&#x3D;24mb&#x2F;s ），频率过高，性能越差</p><p>而不是所有玩家范围都需要接受到你的的同步，只针对一个兴趣范围</p><ul><li>建立兴趣范围清单</li><li>只对兴趣兴趣范围内的目标广播</li><li>极大的降低消息处理压力和网络负载</li></ul><h5 id="AOI的设计-设计原则"><a href="#AOI的设计-设计原则" class="headerlink" title="AOI的设计-设计原则"></a>AOI的设计-设计原则</h5><ol><li>分析核心需求：减少压力消耗 降低带宽 提高负载</li><li>明确设计目标 对象 数据 算法</li><li>不为设计而设计 优化思想 忘记技术</li></ol><h5 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h5><ol><li>兴趣范围规划方案</li><li>对象与数据结构</li><li>高性能算法</li></ol><h5 id="场景分析与方案设计-一"><a href="#场景分析与方案设计-一" class="headerlink" title="场景分析与方案设计 (一)"></a>场景分析与方案设计 (一)</h5><h6 id=""><a href="#" class="headerlink" title=""></a></h6><h6 id="级别设定"><a href="#级别设定" class="headerlink" title="级别设定"></a>级别设定</h6><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211206210243018.png" alt="image-20211206210243018"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnEntityMove</span>(<span class="hljs-params">who</span>)</span>&#123;<br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> entity <span class="hljs-keyword">in</span> entities)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (who==entity)<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">bool</span> nowinAOI=who.Distance(entity)&lt;who.AOIRange;<br>        <span class="hljs-built_in">bool</span> alreadyInAOI=who.AOI.contains(entity);<br>        <span class="hljs-keyword">if</span> (alreadyInAOI&amp;&amp;!nowinAOI)<br>        &#123;<br>            who.OnLeaveAOI(entity);<br>            entity.OnLeaveAOI(who);<br>        &#125;  <br>        <span class="hljs-keyword">if</span> (!alreadyInAOI&amp;&amp;nowinAOI)<br>        &#123;<br>            who.onEnterAOI(entity);<br>            entity.onEnterAOI(who);<br>        &#125;<br>     &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>优点</p><ul><li>不需要特殊的数据结构</li><li>易于实现</li></ul><p>缺点</p><ul><li>计算成本较高（1+n）*n&#x2F;2</li><li>1000人&#x3D;500500次</li></ul><p>改善方案</p><ul><li>多线程 并行计算，提升计算效率</li><li>延迟计算 减少计算间隔</li><li>分批计算 100&#x2F;Frame</li></ul><h5 id="场景分析与方案设计-二"><a href="#场景分析与方案设计-二" class="headerlink" title="场景分析与方案设计 (二)"></a>场景分析与方案设计 (二)</h5><p>区域划分</p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211206212501192.png" alt="image-20211206212501192"></p><p>将区域划分为一个一个格子 如8X8</p><p>代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnEntityMove</span>(<span class="hljs-params">who</span>)</span>&#123;   <br><span class="hljs-built_in">int</span> new_x=(<span class="hljs-built_in">int</span>)(who.position.x/size);<br>    <span class="hljs-built_in">int</span> new_y=(<span class="hljs-built_in">int</span>)(who.position.y/size);<br>    <span class="hljs-keyword">if</span>(new_x!=who.grid_X||new_y!=who.grid_y)&#123;<br>        who.LeaveGrid(who.grid_x,who.grid_y);<br>        who.EnterGrid(new_x,new_y);<br>        <span class="hljs-keyword">this</span>.grid_x=new_x;<br>        <span class="hljs-keyword">this</span>.grid_y=new_y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优点</p><ul><li>计算速度快</li></ul><p>缺点</p><ul><li>需要额外数据结构存储格子信息</li><li>需要额外的格子管理逻辑</li><li>实现复杂度高</li><li><strong>格子边界问题</strong></li></ul><h6 id="场景分析与方案设计-三"><a href="#场景分析与方案设计-三" class="headerlink" title="场景分析与方案设计 (三)"></a>场景分析与方案设计 (三)</h6><p>基于方案二做优化</p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211206213228669.png" alt="image-20211206213228669"></p><p>九宫格，一个格子一个格子广播</p><p>进一步的优化思考</p><p>算法优化</p><ul><li>优化数据结构</li><li>降低运算消耗</li></ul><p>ECS架构</p><ul><li>采用面向数据概念优化架构，提升运算性能</li></ul><p>并行运算与GPU加速</p><ul><li>采用并行计算提升性能</li><li>采用GPU加速减少CPU消耗</li></ul><h5 id="优化性价比曲线"><a href="#优化性价比曲线" class="headerlink" title="优化性价比曲线"></a>优化性价比曲线</h5><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211206213733619.png" alt="image-20211206213733619"></p><h6 id="优化方案参考"><a href="#优化方案参考" class="headerlink" title="优化方案参考"></a>优化方案参考</h6><p>背景</p><p>由于正在开发的游戏涉及到10万个移动角色，如果单服10000玩家的话，采用双向循环查找，那就是10亿的量级，太恐怖了，不得不对算法做优化</p><p>场景：1000*1000的地图，10000客户端角色两个角色间的距离是10时，有效</p><p>优化前</p><p>随机生成10000角色的位置信息，然后计算那些角色的信息需要发给范围的客户端。原始：使用最简单的双向循环查找算法，两重for循环，每找到一个时数量+1结果如下，找到40030个有效值，耗时880ms</p><p>优化一</p><p>位置是双向的，也就是A在B的范围内，B在A的范围内，因此只需要循环N<em>（N-1）&#x2F;2次，优化结果耗时*<em>416ms</em></em></p><p>优化二</p><p>由于大部分的角色位置相距较远，因此对地图进行分区，以100为单位，整个地图被分成100个区域，创建区域数组Player[100][]，然后计算每个客户端的更新范围所在的区域，并将客户端加入到区域中，注意客户端的四个顶点可能在不同的区域上，此时在几个区域就要加入几个区域。最后计算角色所在区域，并和区域内的Player计算距离。此算法得到的结果是<strong>22.5ms</strong></p><p>优化三</p><p>区域大小用2AN来表示，从而在计算角色所在<br>区域时可以用移位来处理，使用64作为区域大<br>小，优化后平均耗时是：<strong>15.5ms</strong></p><p>优化四</p><p>从算法的耗时来看，区域小一些，则区域数量<br>变多，但每个区域内的角色数量就少了，需要<br>计算的量也会变少，使用32作为区域大小后，<br>耗时为：<strong>9.5ms</strong></p><p>优化五</p><p>如果地图变大一些，角色更加稀疏，则计算量<br>会更少，使用10000<em>10000的地图后， 同样64<br>大小的区域，耗时是：*<em>1.8ms</em></em></p><p>其他案例</p><p><a href="http://cppblog.com/jaxe/archive/2011/06/20/148998.html">http://cppblog.com/jaxe/archive/2011/06/20/148998.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Engine</category>
      
    </categories>
    
    
    <tags>
      
      <tag>花里胡哨</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity-资源优化</title>
    <link href="/2021/12/23/Engine/Unity%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/"/>
    <url>/2021/12/23/Engine/Unity%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="资源优化"><a href="#资源优化" class="headerlink" title="资源优化"></a>资源优化</h3><p>目标： 一般从两个方面 性能 品质</p><p>内存占用 大小&#x2F;容量 运行效率（帧率高不高）</p><p>先考虑资源</p><p>基础资源类型</p><p>模型 动作 纹理 声音 字体</p><p>综合资源类型</p><p>场景（地形 光源）UI（图集）粒子系统</p><p><strong>游戏资源的制作规范</strong></p><p>模型：三角形数量 UV LOD</p><p>动作：时长 帧率</p><p>贴图：尺寸 格式</p><img src="/2021/12/23/Engine/Unity%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/image-20211209094742121.png" class="" title="image-20211209094742121"><p><strong>模型导入优化</strong></p><p>模型压缩 网格优化 可读写 Lightmap UV</p><p>动作导入 动画压缩 Rig-优化游戏对象</p><p>纹理格式 POT 纹理大小 压缩选项</p><p><strong>场景优化</strong></p><p>资源的组织 引用及依赖 资源复用</p><p><strong>优化流程自动化</strong></p><p>Unity MeshCompression 网格优化</p><img src="/2021/12/23/Engine/Unity%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/image-20211209100212083.png" class="" title="image-20211209100212083"><img src="/2021/12/23/Engine/Unity%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/image-20211209100358273.png" class="" title="image-20211209100358273"><p>模型的Optimize GameObject开启后 ，模型的子节点将压缩成一个节点</p><p>资源后处理 代码</p><p>Unity AssetPostProcessor</p><p><a href="https://docs.unity3d.com/2019.2/Documentation/ScriptReference/AssetPostprocessor.OnPreprocessTexture.html">https://docs.unity3d.com/2019.2/Documentation/ScriptReference/AssetPostprocessor.OnPreprocessTexture.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Engine</category>
      
    </categories>
    
    
    <tags>
      
      <tag>花里胡哨</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity性能优化</title>
    <link href="/2021/12/23/Engine/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2021/12/23/Engine/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="性能优化-CPU"><a href="#性能优化-CPU" class="headerlink" title="性能优化-CPU"></a>性能优化-CPU</h4><p><strong>干扰 内部与外部</strong></p><p>内部：Profiler，Vertical Sync（垂直同步），Log output 凹操作性能耗费很高</p><p>外部：CPU 内存 IO</p><p><strong>工具</strong></p><p><strong>Unity Profiler</strong></p><img src="/2021/12/23/Engine/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20211213161040737.png" class="" title="image20211213161040737"><p><strong>Custom Profiler</strong>（自定义的Profiler）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>&#123;<br>    CustomProfrile();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CustomProfrile</span>()</span><br>&#123;<br>    UnityEngine.Profiling.Profiler.BeginSample(<span class="hljs-string">&quot;CustomProfrile&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>    &#123;<br>        CustomFunction();<br>    &#125;<br>    UnityEngine.Profiling.Profiler.EndSample();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CustomFunction</span>()</span><br>&#123;<br>    UnityEngine.Profiling.Profiler.BeginSample(<span class="hljs-string">&quot;CustomFunction&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>    &#123;<br>        CustomCale();<br>    &#125;<br>    UnityEngine.Profiling.Profiler.EndSample();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CustomCale</span>()</span><br>&#123;<br>    UnityEngine.Profiling.Profiler.BeginSample(<span class="hljs-string">&quot;CustomCale&quot;</span>);<br>    <span class="hljs-built_in">float</span> t = <span class="hljs-number">100</span>, f = <span class="hljs-number">0f</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>    &#123;<br>        f += Mathf.Pow(Mathf.Sin(i), t);<br>    &#125;<br>    UnityEngine.Profiling.Profiler.EndSample();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Timer&amp;Log</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ProTimer</span> :<span class="hljs-title">IDisposable</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br>   <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> times;<br>   <span class="hljs-keyword">private</span> Stopwatch watch;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ProTimer</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>):<span class="hljs-title">this</span>(<span class="hljs-params">name,<span class="hljs-number">0</span></span>)</span>&#123;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ProTimer</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name,<span class="hljs-built_in">int</span> times</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>        <span class="hljs-keyword">this</span>.times=times;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.times&lt;=<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">this</span>.times=<span class="hljs-number">1</span>;<br>        watch=Stopwatch.StartNew();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>()</span>&#123;<br>        watch.Stop();<br>        <span class="hljs-built_in">float</span> ms=watch.ElapsedMinlliseconds;<br>        <span class="hljs-keyword">if</span>(times&gt;<span class="hljs-number">1</span>)&#123;<br>            Debug.Debug.Log(<span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;ProTimer : [&#123;0&#125;] finished: [&#123;1:0.00&#125;ms] total, [&#123;2:0.000000&#125;ms] per peroid for [&#123;3&#125;] times&quot;</span><br>            ,name ,ms,ms/timer,times));<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            Debug.Debug.Log(<span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;ProTimer : [&#123;0&#125;] finished: [&#123;1:0.00&#125;ms] total&quot;</span>,name,ms ));<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="CPU优化要点"><a href="#CPU优化要点" class="headerlink" title="CPU优化要点"></a>CPU优化要点</h5><p>CPU优化要点：Unity脚本最佳做法 数据结构优化 算法优化</p><p><strong>Unity脚本最佳做法</strong></p><ul><li>Component的缓冲与获取</li><li><strong>移除空声明</strong></li><li>避免Find和SendMessage(大概比直接函数调用慢2000倍)</li><li>禁止未使用的游戏脚本与对象 （生存周期 可见性 距离）</li><li>对象池</li></ul><p>Component获取的三种方式</p><ul><li>(CompTest)Component(“Testcomponent”)</li><li>GetComponent<CompTest>();</li><li>(CompTest)GetComponent(typeof(CompTest))</li></ul><p>性能消耗</p><img src="/2021/12/23/Engine/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20211213202822084.png" class="" title="image20211213202822084"><p>避免Find和SendMessage-替代方案</p><ul><li>直接引用游戏对象</li><li>静态类</li><li>单例组件</li><li>自定义消息系统</li></ul><p>性能分析注意事项</p><ul><li>分析第一，优化第二</li><li>分析要透彻，避免一知半解盲目优化</li><li>避免为性能分析增加过多临时代码</li><li>增加的日志在头花完成及时移除</li><li>尽量通过DeBug发现问题</li></ul><h4 id="性能优化-GPU"><a href="#性能优化-GPU" class="headerlink" title="性能优化-GPU"></a>性能优化-GPU</h4><p><strong>原理</strong></p><img src="/2021/12/23/Engine/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20211213204405189.png" class="" title="image20211213204405189"><h6 id="工具"><a href="#工具" class="headerlink" title="工具"></a><strong>工具</strong></h6><p>Unity Profiler Frame Debug GPU Profiler</p><h6 id="GPU优化要点"><a href="#GPU优化要点" class="headerlink" title="GPU优化要点"></a><strong>GPU优化要点</strong></h6><ul><li>Drawcall</li><li>Batching</li><li>图集</li><li>移动设备优化</li></ul><p>渲染对象关系</p><img src="/2021/12/23/Engine/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20211213205858211.png" class="" title="image20211213205858211"><p>Dynamic Batching</p><ul><li>所有Mesh实例具有相同的材质引用</li><li>只有Partucle System和MeshRenderer可以动态批*（随Unity版本不同）</li><li>Vertex Attribute总数必须小于900</li><li>所有实例必须采用Uniform Scale或所有Mesh都采用Nonuniform Scale，不能混合使用。</li><li>必须引用相同的LightMap</li><li>材质Shader不用使用Multiple Passes</li><li>Mesh实例不能接受实时阴影</li><li>每个Batch最大300Mesh</li><li>最多32000Mesh可以Batch</li></ul><p>Static Batching</p><ul><li>所有Mesh实例具有相同的材质引用</li><li>所有Mesh必须标记为Static</li><li>额外的内存占用</li><li>静态对象无法通过原始的Transform移动</li><li>任何一点可见，全部渲染</li></ul><p>移动设备优化要点</p><ul><li>最小的Drawcall</li><li>最小的材质数量</li><li>最小的纹理尺寸</li><li>方形&amp;POT纹理</li><li>Shader中使用尽可能低的数据类型</li><li>避免Alpha测试</li></ul><h4 id="性能优化-内存"><a href="#性能优化-内存" class="headerlink" title="性能优化-内存"></a>性能优化-内存</h4><h6 id="内存占用优化"><a href="#内存占用优化" class="headerlink" title="内存占用优化"></a>内存占用优化</h6><p>分析工具 <strong>Unity Profiler</strong></p><img src="/2021/12/23/Engine/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20211216194107133.png" class="" title="image20211216194107133"><p>除此之外，unity还有另外一个更加直观的工具</p><p><strong>Memory Profiler</strong> (开源库之中)</p><img src="/2021/12/23/Engine/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20211216194721571.png" class="" title="image20211216194721571"><h6 id="Unity占用组成"><a href="#Unity占用组成" class="headerlink" title="Unity占用组成"></a><strong>Unity占用组成</strong></h6><ul><li><p>Unity</p></li><li><p>Mono</p></li><li><p>GfxDriver(显卡驱动消耗的内存)</p></li><li><p>FMOD（音频引擎）</p></li><li><p>细分(Texture Mesh Animation Shader Font)</p><img src="/2021/12/23/Engine/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20211216211225511.png" class="" title="image20211216211225511"><img src="/2021/12/23/Engine/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20211216212601027.png" class="" title="image20211216212601027"><img src="/2021/12/23/Engine/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20211216212655362.png" class="" title="image20211216212655362"></li></ul><h6 id="GC优化"><a href="#GC优化" class="headerlink" title="GC优化"></a>GC优化</h6><p>GC 内存堆栈 垃圾回收</p><p><a href="https://zhuanlan.zhihu.com/p/265217138">https://zhuanlan.zhihu.com/p/265217138</a></p><img src="/2021/12/23/Engine/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20211216213311223.png" class="" title="image20211216213311223"><p>优化要点</p><ul><li>减少频繁的对象创建</li><li>避免装箱</li><li>善用缓存<img src="/2021/12/23/Engine/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20211216213529292.png" class="" title="image-20211216213529292"></li></ul>]]></content>
    
    
    <categories>
      
      <category>Engine</category>
      
    </categories>
    
    
    <tags>
      
      <tag>花里胡哨</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
